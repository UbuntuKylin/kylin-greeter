/* unity-greeter.c generated by valac 0.22.1, the Vala compiler
 * generated from unity-greeter.vala, do not modify */

/* -*- Mode: Vala; indent-tabs-mode: nil; tab-width: 4 -*-
 *
 * Copyright (C) 2011 Canonical Ltd
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 3 as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Authored by: Robert Ancell <robert.ancell@canonical.com>
 */

#include <glib.h>
#include <glib-object.h>
#include <stdlib.h>
#include <string.h>
#include <cairo-xlib.h>
#include <gtk/gtk.h>
#include <lightdm.h>
#include <canberra.h>
#include <gio/gio.h>
#include <gdk/gdk.h>
#include <glib/gstdio.h>
#include <cairo.h>
#include <X11/Xlib.h>
#include <X11/Xatom.h>
#include <X11/Xutil.h>
#include <X11/Xregion.h>
#include <gdk/gdkx.h>
#include <stdio.h>
#include <sys/mman.h>
#include <locale.h>
#include <glib/gi18n-lib.h>
#include "config.h"
#include "libido/libido.h"
#include <unistd.h>
#include <float.h>
#include <math.h>
#include <glib-unix.h>
#include <signal.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <gobject/gvaluecollector.h>


#define TYPE_UNITY_GREETER (unity_greeter_get_type ())
#define UNITY_GREETER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_UNITY_GREETER, UnityGreeter))
#define UNITY_GREETER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_UNITY_GREETER, UnityGreeterClass))
#define IS_UNITY_GREETER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_UNITY_GREETER))
#define IS_UNITY_GREETER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_UNITY_GREETER))
#define UNITY_GREETER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_UNITY_GREETER, UnityGreeterClass))

typedef struct _UnityGreeter UnityGreeter;
typedef struct _UnityGreeterClass UnityGreeterClass;
typedef struct _UnityGreeterPrivate UnityGreeterPrivate;

#define TYPE_SETTINGS_DAEMON (settings_daemon_get_type ())
#define SETTINGS_DAEMON(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_SETTINGS_DAEMON, SettingsDaemon))
#define SETTINGS_DAEMON_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_SETTINGS_DAEMON, SettingsDaemonClass))
#define IS_SETTINGS_DAEMON(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_SETTINGS_DAEMON))
#define IS_SETTINGS_DAEMON_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_SETTINGS_DAEMON))
#define SETTINGS_DAEMON_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_SETTINGS_DAEMON, SettingsDaemonClass))

typedef struct _SettingsDaemon SettingsDaemon;
typedef struct _SettingsDaemonClass SettingsDaemonClass;

#define TYPE_MAIN_WINDOW (main_window_get_type ())
#define MAIN_WINDOW(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_MAIN_WINDOW, MainWindow))
#define MAIN_WINDOW_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_MAIN_WINDOW, MainWindowClass))
#define IS_MAIN_WINDOW(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_MAIN_WINDOW))
#define IS_MAIN_WINDOW_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_MAIN_WINDOW))
#define MAIN_WINDOW_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_MAIN_WINDOW, MainWindowClass))

typedef struct _MainWindow MainWindow;
typedef struct _MainWindowClass MainWindowClass;

#define TYPE_DIALOG_DBUS_INTERFACE (dialog_dbus_interface_get_type ())
#define DIALOG_DBUS_INTERFACE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_DIALOG_DBUS_INTERFACE, DialogDBusInterface))
#define DIALOG_DBUS_INTERFACE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_DIALOG_DBUS_INTERFACE, DialogDBusInterfaceClass))
#define IS_DIALOG_DBUS_INTERFACE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_DIALOG_DBUS_INTERFACE))
#define IS_DIALOG_DBUS_INTERFACE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_DIALOG_DBUS_INTERFACE))
#define DIALOG_DBUS_INTERFACE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_DIALOG_DBUS_INTERFACE, DialogDBusInterfaceClass))

typedef struct _DialogDBusInterface DialogDBusInterface;
typedef struct _DialogDBusInterfaceClass DialogDBusInterfaceClass;
#define _g_free0(var) (var = (g_free (var), NULL))
#define _g_key_file_unref0(var) ((var == NULL) ? NULL : (var = (g_key_file_unref (var), NULL)))
#define _cairo_surface_destroy0(var) ((var == NULL) ? NULL : (var = (cairo_surface_destroy (var), NULL)))
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
#define _ca_context_destroy0(var) ((var == NULL) ? NULL : (var = (ca_context_destroy (var), NULL)))
#define _unity_greeter_unref0(var) ((var == NULL) ? NULL : (var = (unity_greeter_unref (var), NULL)))
#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))

#define TYPE_SHUTDOWN_DIALOG_TYPE (shutdown_dialog_type_get_type ())

#define TYPE_FADABLE_BOX (fadable_box_get_type ())
#define FADABLE_BOX(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_FADABLE_BOX, FadableBox))
#define FADABLE_BOX_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_FADABLE_BOX, FadableBoxClass))
#define IS_FADABLE_BOX(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_FADABLE_BOX))
#define IS_FADABLE_BOX_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_FADABLE_BOX))
#define FADABLE_BOX_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_FADABLE_BOX, FadableBoxClass))

typedef struct _FadableBox FadableBox;
typedef struct _FadableBoxClass FadableBoxClass;

#define TYPE_GREETER_LIST (greeter_list_get_type ())
#define GREETER_LIST(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_GREETER_LIST, GreeterList))
#define GREETER_LIST_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_GREETER_LIST, GreeterListClass))
#define IS_GREETER_LIST(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_GREETER_LIST))
#define IS_GREETER_LIST_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_GREETER_LIST))
#define GREETER_LIST_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_GREETER_LIST, GreeterListClass))

typedef struct _GreeterList GreeterList;
typedef struct _GreeterListClass GreeterListClass;

#define TYPE_BACKGROUND (background_get_type ())
#define BACKGROUND(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_BACKGROUND, Background))
#define BACKGROUND_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_BACKGROUND, BackgroundClass))
#define IS_BACKGROUND(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_BACKGROUND))
#define IS_BACKGROUND_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_BACKGROUND))
#define BACKGROUND_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_BACKGROUND, BackgroundClass))

typedef struct _Background Background;
typedef struct _BackgroundClass BackgroundClass;

#define BACKGROUND_TYPE_DRAW_FLAGS (background_draw_flags_get_type ())
#define _cairo_destroy0(var) ((var == NULL) ? NULL : (var = (cairo_destroy (var), NULL)))
#define _g_timer_destroy0(var) ((var == NULL) ? NULL : (var = (g_timer_destroy (var), NULL)))
#define _g_option_context_free0(var) ((var == NULL) ? NULL : (var = (g_option_context_free (var), NULL)))
typedef struct _ParamSpecUnityGreeter ParamSpecUnityGreeter;
typedef struct _DialogDBusInterfacePrivate DialogDBusInterfacePrivate;

struct _UnityGreeter {
	GTypeInstance parent_instance;
	volatile int ref_count;
	UnityGreeterPrivate * priv;
	gboolean test_mode;
	gboolean orca_needs_kick;
};

struct _UnityGreeterClass {
	GTypeClass parent_class;
	void (*finalize) (UnityGreeter *self);
};

struct _UnityGreeterPrivate {
	gchar* state_file;
	GKeyFile* state;
	cairo_surface_t* background_surface;
	SettingsDaemon* settings_daemon;
	MainWindow* main_window;
	LightDMGreeter* greeter;
	ca_context* canberra_context;
	DialogDBusInterface* dbus_object;
};

typedef enum  {
	SHUTDOWN_DIALOG_TYPE_LOGOUT,
	SHUTDOWN_DIALOG_TYPE_SHUTDOWN,
	SHUTDOWN_DIALOG_TYPE_RESTART
} ShutdownDialogType;

typedef enum  {
	BACKGROUND_DRAW_FLAGS_NONE,
	BACKGROUND_DRAW_FLAGS_GRID
} BackgroundDrawFlags;

struct _ParamSpecUnityGreeter {
	GParamSpec parent_instance;
};

struct _DialogDBusInterface {
	GObject parent_instance;
	DialogDBusInterfacePrivate * priv;
};

struct _DialogDBusInterfaceClass {
	GObjectClass parent_class;
};


static gpointer unity_greeter_parent_class = NULL;
extern UnityGreeter* unity_greeter_singleton;
UnityGreeter* unity_greeter_singleton = NULL;
static GTimer* unity_greeter_log_timer;
static GTimer* unity_greeter_log_timer = NULL;
static gpointer dialog_dbus_interface_parent_class = NULL;

#define grid_size 40
gpointer unity_greeter_ref (gpointer instance);
void unity_greeter_unref (gpointer instance);
GParamSpec* param_spec_unity_greeter (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void value_set_unity_greeter (GValue* value, gpointer v_object);
void value_take_unity_greeter (GValue* value, gpointer v_object);
gpointer value_get_unity_greeter (const GValue* value);
GType unity_greeter_get_type (void) G_GNUC_CONST;
GType settings_daemon_get_type (void) G_GNUC_CONST;
GType main_window_get_type (void) G_GNUC_CONST;
GType dialog_dbus_interface_get_type (void) G_GNUC_CONST;
guint dialog_dbus_interface_register_object (void* object, GDBusConnection* connection, const gchar* path, GError** error);
#define UNITY_GREETER_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), TYPE_UNITY_GREETER, UnityGreeterPrivate))
enum  {
	UNITY_GREETER_DUMMY_PROPERTY
};
static UnityGreeter* unity_greeter_new (gboolean test_mode_);
static UnityGreeter* unity_greeter_construct (GType object_type, gboolean test_mode_);
static cairo_surface_t* unity_greeter_create_root_surface (GdkScreen* screen);
static void __lambda48_ (UnityGreeter* self, const gchar* text, LightDMMessageType type);
static void ___lambda48__lightdm_greeter_show_message (LightDMGreeter* _sender, const gchar* text, LightDMMessageType type, gpointer self);
static void __lambda49_ (UnityGreeter* self, const gchar* text, LightDMPromptType type);
static void ___lambda49__lightdm_greeter_show_prompt (LightDMGreeter* _sender, const gchar* text, LightDMPromptType type, gpointer self);
static void __lambda50_ (UnityGreeter* self);
static void ___lambda50__lightdm_greeter_autologin_timer_expired (LightDMGreeter* _sender, gpointer self);
static void __lambda51_ (UnityGreeter* self);
static void ___lambda51__lightdm_greeter_authentication_complete (LightDMGreeter* _sender, gpointer self);
SettingsDaemon* settings_daemon_new (void);
SettingsDaemon* settings_daemon_construct (GType object_type);
void settings_daemon_start (SettingsDaemon* self);
MainWindow* main_window_new (void);
MainWindow* main_window_construct (GType object_type);
DialogDBusInterface* dialog_dbus_interface_new (void);
DialogDBusInterface* dialog_dbus_interface_construct (GType object_type);
static void __lambda52_ (UnityGreeter* self, guint32 type);
GType shutdown_dialog_type_get_type (void) G_GNUC_CONST;
void main_window_show_shutdown_dialog (MainWindow* self, ShutdownDialogType type);
static void ___lambda52__dialog_dbus_interface_open_dialog (DialogDBusInterface* _sender, guint32 type, gpointer self);
static void __lambda53_ (UnityGreeter* self, DialogDBusInterface* type);
void main_window_close_shutdown_dialog (MainWindow* self);
static void ___lambda53__dialog_dbus_interface_close_dialog (DialogDBusInterface* _sender, gpointer self);
static void __lambda54_ (UnityGreeter* self, GDBusConnection* c);
static void ___lambda54__gbus_acquired_callback (GDBusConnection* connection, const gchar* name, gpointer self);
static void __lambda55_ (UnityGreeter* self);
static void ___lambda55__gbus_name_lost_callback (GDBusConnection* connection, const gchar* name, gpointer self);
static void unity_greeter_start_fake_wm (UnityGreeter* self);
static gboolean unity_greeter_ready_cb (UnityGreeter* self);
static gboolean _unity_greeter_ready_cb_gsource_func (gpointer self);
gchar* unity_greeter_get_state (UnityGreeter* self, const gchar* key);
void unity_greeter_set_state (UnityGreeter* self, const gchar* key, const gchar* value);
GType fadable_box_get_type (void) G_GNUC_CONST;
GType greeter_list_get_type (void) G_GNUC_CONST;
void unity_greeter_push_list (UnityGreeter* self, GreeterList* widget);
void main_window_push_list (MainWindow* self, GreeterList* widget);
void unity_greeter_pop_list (UnityGreeter* self);
void main_window_pop_list (MainWindow* self);
void unity_greeter_add_style_class (GtkWidget* widget);
GType background_get_type (void) G_GNUC_CONST;
gboolean unity_greeter_start_session (UnityGreeter* self, const gchar* session, Background* bg);
GType background_draw_flags_get_type (void) G_GNUC_CONST;
void background_draw_full (Background* self, cairo_t* c, BackgroundDrawFlags flags);
static void unity_greeter_refresh_background (GdkScreen* screen, cairo_surface_t* surface);
static gboolean unity_greeter_session_is_valid (UnityGreeter* self, const gchar* session);
gboolean ug_settings_get_boolean (const gchar* key);
#define UG_SETTINGS_KEY_PLAY_READY_SOUND "play-ready-sound"
void unity_greeter_show (UnityGreeter* self);
void main_window_set_keyboard_state (MainWindow* self);
gboolean unity_greeter_is_authenticated (UnityGreeter* self);
void unity_greeter_authenticate (UnityGreeter* self, const gchar* userid);
void unity_greeter_authenticate_as_guest (UnityGreeter* self);
void unity_greeter_authenticate_remote (UnityGreeter* self, const gchar* session, const gchar* userid);
void unity_greeter_cancel_authentication (UnityGreeter* self);
void unity_greeter_respond (UnityGreeter* self, const gchar* response);
gchar* unity_greeter_authentication_user (UnityGreeter* self);
gchar* unity_greeter_default_session_hint (UnityGreeter* self);
gchar* unity_greeter_select_user_hint (UnityGreeter* self);
gboolean unity_greeter_show_manual_login_hint (UnityGreeter* self);
gboolean unity_greeter_show_remote_login_hint (UnityGreeter* self);
gboolean unity_greeter_hide_users_hint (UnityGreeter* self);
gboolean unity_greeter_has_guest_account_hint (UnityGreeter* self);
static GdkFilterReturn unity_greeter_focus_upon_map (UnityGreeter* self, GdkXEvent* gxevent, GdkEvent* event);
GtkWindow* main_window_get_keyboard_window (MainWindow* self);
static GdkFilterReturn _unity_greeter_focus_upon_map_gdk_filter_func (GdkXEvent* xevent, GdkEvent* event, gpointer self);
static void unity_greeter_log_cb (const gchar* log_domain, GLogLevelFlags log_level, const gchar* message);
gint unity_greeter_main (gchar** args, int args_length1);
static void _unity_greeter_log_cb_glog_func (const gchar* log_domain, GLogLevelFlags log_levels, const gchar* message, gpointer self);
gchar* ug_settings_get_string (const gchar* key);
#define UG_SETTINGS_KEY_THEME_NAME "theme-name"
#define UG_SETTINGS_KEY_ICON_THEME_NAME "icon-theme-name"
#define UG_SETTINGS_KEY_FONT_NAME "font-name"
gdouble ug_settings_get_double (const gchar* key);
#define UG_SETTINGS_KEY_XFT_DPI "xft-dpi"
#define UG_SETTINGS_KEY_XFT_ANTIALIAS "xft-antialias"
#define UG_SETTINGS_KEY_XFT_HINTSTYLE "xft-hintstyle"
#define UG_SETTINGS_KEY_XFT_RGBA "xft-rgba"
static gboolean __lambda56_ (void);
static gboolean ___lambda56__gsource_func (gpointer self);
static void g_cclosure_user_marshal_VOID__STRING_INT (GClosure * closure, GValue * return_value, guint n_param_values, const GValue * param_values, gpointer invocation_hint, gpointer marshal_data);
static void unity_greeter_finalize (UnityGreeter* obj);
enum  {
	DIALOG_DBUS_INTERFACE_DUMMY_PROPERTY
};
void dialog_dbus_interface_open (DialogDBusInterface* self, guint32 type, guint32 timestamp, guint32 seconds_to_stay_open, char** inhibitor_object_paths, int inhibitor_object_paths_length1);
void dialog_dbus_interface_close (DialogDBusInterface* self);
static void _dbus_dialog_dbus_interface_open (DialogDBusInterface* self, GVariant* parameters, GDBusMethodInvocation* invocation);
static void _dbus_dialog_dbus_interface_close (DialogDBusInterface* self, GVariant* parameters, GDBusMethodInvocation* invocation);
static void dialog_dbus_interface_dbus_interface_method_call (GDBusConnection* connection, const gchar* sender, const gchar* object_path, const gchar* interface_name, const gchar* method_name, GVariant* parameters, GDBusMethodInvocation* invocation, gpointer user_data);
static GVariant* dialog_dbus_interface_dbus_interface_get_property (GDBusConnection* connection, const gchar* sender, const gchar* object_path, const gchar* interface_name, const gchar* property_name, GError** error, gpointer user_data);
static gboolean dialog_dbus_interface_dbus_interface_set_property (GDBusConnection* connection, const gchar* sender, const gchar* object_path, const gchar* interface_name, const gchar* property_name, GVariant* value, GError** error, gpointer user_data);
static void _dbus_dialog_dbus_interface_open_dialog (GObject* _sender, guint32 type, gpointer* _data);
static void _dbus_dialog_dbus_interface_close_dialog (GObject* _sender, gpointer* _data);
static void _dialog_dbus_interface_unregister_object (gpointer user_data);
static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func);
static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func);

static const GDBusArgInfo _dialog_dbus_interface_dbus_arg_info_open_type = {-1, "type", "u"};
static const GDBusArgInfo _dialog_dbus_interface_dbus_arg_info_open_timestamp = {-1, "timestamp", "u"};
static const GDBusArgInfo _dialog_dbus_interface_dbus_arg_info_open_seconds_to_stay_open = {-1, "seconds_to_stay_open", "u"};
static const GDBusArgInfo _dialog_dbus_interface_dbus_arg_info_open_inhibitor_object_paths = {-1, "inhibitor_object_paths", "ao"};
static const GDBusArgInfo * const _dialog_dbus_interface_dbus_arg_info_open_in[] = {&_dialog_dbus_interface_dbus_arg_info_open_type, &_dialog_dbus_interface_dbus_arg_info_open_timestamp, &_dialog_dbus_interface_dbus_arg_info_open_seconds_to_stay_open, &_dialog_dbus_interface_dbus_arg_info_open_inhibitor_object_paths, NULL};
static const GDBusArgInfo * const _dialog_dbus_interface_dbus_arg_info_open_out[] = {NULL};
static const GDBusMethodInfo _dialog_dbus_interface_dbus_method_info_open = {-1, "Open", (GDBusArgInfo **) (&_dialog_dbus_interface_dbus_arg_info_open_in), (GDBusArgInfo **) (&_dialog_dbus_interface_dbus_arg_info_open_out)};
static const GDBusArgInfo * const _dialog_dbus_interface_dbus_arg_info_close_in[] = {NULL};
static const GDBusArgInfo * const _dialog_dbus_interface_dbus_arg_info_close_out[] = {NULL};
static const GDBusMethodInfo _dialog_dbus_interface_dbus_method_info_close = {-1, "Close", (GDBusArgInfo **) (&_dialog_dbus_interface_dbus_arg_info_close_in), (GDBusArgInfo **) (&_dialog_dbus_interface_dbus_arg_info_close_out)};
static const GDBusMethodInfo * const _dialog_dbus_interface_dbus_method_info[] = {&_dialog_dbus_interface_dbus_method_info_open, &_dialog_dbus_interface_dbus_method_info_close, NULL};
static const GDBusArgInfo _dialog_dbus_interface_dbus_arg_info_open_dialog_type = {-1, "type", "u"};
static const GDBusArgInfo * const _dialog_dbus_interface_dbus_arg_info_open_dialog[] = {&_dialog_dbus_interface_dbus_arg_info_open_dialog_type, NULL};
static const GDBusSignalInfo _dialog_dbus_interface_dbus_signal_info_open_dialog = {-1, "OpenDialog", (GDBusArgInfo **) (&_dialog_dbus_interface_dbus_arg_info_open_dialog)};
static const GDBusArgInfo * const _dialog_dbus_interface_dbus_arg_info_close_dialog[] = {NULL};
static const GDBusSignalInfo _dialog_dbus_interface_dbus_signal_info_close_dialog = {-1, "CloseDialog", (GDBusArgInfo **) (&_dialog_dbus_interface_dbus_arg_info_close_dialog)};
static const GDBusSignalInfo * const _dialog_dbus_interface_dbus_signal_info[] = {&_dialog_dbus_interface_dbus_signal_info_open_dialog, &_dialog_dbus_interface_dbus_signal_info_close_dialog, NULL};
static const GDBusPropertyInfo * const _dialog_dbus_interface_dbus_property_info[] = {NULL};
static const GDBusInterfaceInfo _dialog_dbus_interface_dbus_interface_info = {-1, "org.gnome.SessionManager.EndSessionDialog", (GDBusMethodInfo **) (&_dialog_dbus_interface_dbus_method_info), (GDBusSignalInfo **) (&_dialog_dbus_interface_dbus_signal_info), (GDBusPropertyInfo **) (&_dialog_dbus_interface_dbus_property_info)};
static const GDBusInterfaceVTable _dialog_dbus_interface_dbus_interface_vtable = {dialog_dbus_interface_dbus_interface_method_call, dialog_dbus_interface_dbus_interface_get_property, dialog_dbus_interface_dbus_interface_set_property};

static gpointer _unity_greeter_ref0 (gpointer self) {
	return self ? unity_greeter_ref (self) : NULL;
}


static void __lambda48_ (UnityGreeter* self, const gchar* text, LightDMMessageType type) {
	const gchar* _tmp0_ = NULL;
	LightDMMessageType _tmp1_ = 0;
	g_return_if_fail (text != NULL);
	_tmp0_ = text;
	_tmp1_ = type;
	g_signal_emit_by_name (self, "show-message", _tmp0_, _tmp1_);
}


static void ___lambda48__lightdm_greeter_show_message (LightDMGreeter* _sender, const gchar* text, LightDMMessageType type, gpointer self) {
	__lambda48_ (self, text, type);
}


static void __lambda49_ (UnityGreeter* self, const gchar* text, LightDMPromptType type) {
	const gchar* _tmp0_ = NULL;
	LightDMPromptType _tmp1_ = 0;
	g_return_if_fail (text != NULL);
	_tmp0_ = text;
	_tmp1_ = type;
	g_signal_emit_by_name (self, "show-prompt", _tmp0_, _tmp1_);
}


static void ___lambda49__lightdm_greeter_show_prompt (LightDMGreeter* _sender, const gchar* text, LightDMPromptType type, gpointer self) {
	__lambda49_ (self, text, type);
}


static void __lambda50_ (UnityGreeter* self) {
	LightDMGreeter* _tmp0_ = NULL;
	_tmp0_ = self->priv->greeter;
	lightdm_greeter_authenticate_autologin (_tmp0_);
}


static void ___lambda50__lightdm_greeter_autologin_timer_expired (LightDMGreeter* _sender, gpointer self) {
	__lambda50_ (self);
}


static void __lambda51_ (UnityGreeter* self) {
	g_signal_emit_by_name (self, "authentication-complete");
}


static void ___lambda51__lightdm_greeter_authentication_complete (LightDMGreeter* _sender, gpointer self) {
	__lambda51_ (self);
}


static void __lambda52_ (UnityGreeter* self, guint32 type) {
	ShutdownDialogType dialog_type = 0;
	guint32 _tmp0_ = 0U;
	MainWindow* _tmp1_ = NULL;
	ShutdownDialogType _tmp2_ = 0;
	_tmp0_ = type;
	switch (_tmp0_) {
		default:
		case 1:
		{
			dialog_type = SHUTDOWN_DIALOG_TYPE_LOGOUT;
			break;
		}
		case 2:
		{
			dialog_type = SHUTDOWN_DIALOG_TYPE_RESTART;
			break;
		}
	}
	_tmp1_ = self->priv->main_window;
	_tmp2_ = dialog_type;
	main_window_show_shutdown_dialog (_tmp1_, _tmp2_);
}


static void ___lambda52__dialog_dbus_interface_open_dialog (DialogDBusInterface* _sender, guint32 type, gpointer self) {
	__lambda52_ (self, type);
}


static void __lambda53_ (UnityGreeter* self, DialogDBusInterface* type) {
	MainWindow* _tmp0_ = NULL;
	g_return_if_fail (type != NULL);
	_tmp0_ = self->priv->main_window;
	main_window_close_shutdown_dialog (_tmp0_);
}


static void ___lambda53__dialog_dbus_interface_close_dialog (DialogDBusInterface* _sender, gpointer self) {
	__lambda53_ (self, _sender);
}


static void __lambda54_ (UnityGreeter* self, GDBusConnection* c) {
	GError * _inner_error_ = NULL;
	g_return_if_fail (c != NULL);
	{
		GDBusConnection* _tmp0_ = NULL;
		DialogDBusInterface* _tmp1_ = NULL;
		_tmp0_ = c;
		_tmp1_ = self->priv->dbus_object;
		dialog_dbus_interface_register_object (_tmp1_, _tmp0_, "/org/gnome/SessionManager/EndSessionDialog", &_inner_error_);
		if (_inner_error_ != NULL) {
			goto __catch30_g_error;
		}
	}
	goto __finally30;
	__catch30_g_error:
	{
		GError* e = NULL;
		GError* _tmp2_ = NULL;
		const gchar* _tmp3_ = NULL;
		e = _inner_error_;
		_inner_error_ = NULL;
		_tmp2_ = e;
		_tmp3_ = _tmp2_->message;
		g_warning ("unity-greeter.vala:131: Failed to register /org/gnome/SessionManager/E" \
"ndSessionDialog: %s", _tmp3_);
		_g_error_free0 (e);
	}
	__finally30:
	if (_inner_error_ != NULL) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return;
	}
}


static void ___lambda54__gbus_acquired_callback (GDBusConnection* connection, const gchar* name, gpointer self) {
	__lambda54_ (self, connection);
}


static void __lambda55_ (UnityGreeter* self) {
	g_debug ("unity-greeter.vala:135: Failed to acquire name com.canonical.Unity");
}


static void ___lambda55__gbus_name_lost_callback (GDBusConnection* connection, const gchar* name, gpointer self) {
	__lambda55_ (self);
}


static gboolean _unity_greeter_ready_cb_gsource_func (gpointer self) {
	gboolean result;
	result = unity_greeter_ready_cb (self);
	return result;
}


static UnityGreeter* unity_greeter_construct (GType object_type, gboolean test_mode_) {
	UnityGreeter* self = NULL;
	UnityGreeter* _tmp0_ = NULL;
	gboolean _tmp1_ = FALSE;
	GdkScreen* _tmp2_ = NULL;
	cairo_surface_t* _tmp3_ = NULL;
	LightDMGreeter* _tmp4_ = NULL;
	LightDMGreeter* _tmp5_ = NULL;
	LightDMGreeter* _tmp6_ = NULL;
	LightDMGreeter* _tmp7_ = NULL;
	LightDMGreeter* _tmp8_ = NULL;
	gboolean connected = FALSE;
	gboolean _tmp12_ = FALSE;
	gboolean _tmp13_ = FALSE;
	gboolean _tmp15_ = FALSE;
	gboolean _tmp16_ = FALSE;
	gchar* state_dir = NULL;
	const gchar* _tmp19_ = NULL;
	gchar* _tmp20_ = NULL;
	const gchar* _tmp21_ = NULL;
	gchar* xdg_seat = NULL;
	const gchar* _tmp22_ = NULL;
	gchar* _tmp23_ = NULL;
	gchar* _tmp24_ = NULL;
	gboolean _tmp25_ = FALSE;
	const gchar* _tmp26_ = NULL;
	gboolean _tmp28_ = FALSE;
	gchar* state_file_name = NULL;
	const gchar* _tmp32_ = NULL;
	gchar* _tmp33_ = NULL;
	const gchar* _tmp34_ = NULL;
	gchar* _tmp35_ = NULL;
	GKeyFile* _tmp36_ = NULL;
	MainWindow* _tmp43_ = NULL;
	DialogDBusInterface* _tmp44_ = NULL;
	DialogDBusInterface* _tmp45_ = NULL;
	DialogDBusInterface* _tmp46_ = NULL;
	GError * _inner_error_ = NULL;
	self = (UnityGreeter*) g_type_create_instance (object_type);
	_tmp0_ = _unity_greeter_ref0 (self);
	_unity_greeter_unref0 (unity_greeter_singleton);
	unity_greeter_singleton = _tmp0_;
	_tmp1_ = test_mode_;
	self->test_mode = _tmp1_;
	g_debug ("unity-greeter.vala:57: Creating background surface");
	_tmp2_ = gdk_screen_get_default ();
	_tmp3_ = unity_greeter_create_root_surface (_tmp2_);
	_cairo_surface_destroy0 (self->priv->background_surface);
	self->priv->background_surface = _tmp3_;
	_tmp4_ = lightdm_greeter_new ();
	_g_object_unref0 (self->priv->greeter);
	self->priv->greeter = _tmp4_;
	_tmp5_ = self->priv->greeter;
	g_signal_connect (_tmp5_, "show-message", (GCallback) ___lambda48__lightdm_greeter_show_message, self);
	_tmp6_ = self->priv->greeter;
	g_signal_connect (_tmp6_, "show-prompt", (GCallback) ___lambda49__lightdm_greeter_show_prompt, self);
	_tmp7_ = self->priv->greeter;
	g_signal_connect (_tmp7_, "autologin-timer-expired", (GCallback) ___lambda50__lightdm_greeter_autologin_timer_expired, self);
	_tmp8_ = self->priv->greeter;
	g_signal_connect (_tmp8_, "authentication-complete", (GCallback) ___lambda51__lightdm_greeter_authentication_complete, self);
	connected = FALSE;
	{
		gboolean _tmp9_ = FALSE;
		LightDMGreeter* _tmp10_ = NULL;
		gboolean _tmp11_ = FALSE;
		_tmp10_ = self->priv->greeter;
		_tmp11_ = lightdm_greeter_connect_sync (_tmp10_, &_inner_error_);
		_tmp9_ = _tmp11_;
		if (_inner_error_ != NULL) {
			goto __catch28_g_error;
		}
		connected = _tmp9_;
	}
	goto __finally28;
	__catch28_g_error:
	{
		GError* e = NULL;
		e = _inner_error_;
		_inner_error_ = NULL;
		g_warning ("unity-greeter.vala:72: Failed to connect to LightDM daemon");
		_g_error_free0 (e);
	}
	__finally28:
	if (_inner_error_ != NULL) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return NULL;
	}
	_tmp13_ = connected;
	if (!_tmp13_) {
		gboolean _tmp14_ = FALSE;
		_tmp14_ = self->test_mode;
		_tmp12_ = !_tmp14_;
	} else {
		_tmp12_ = FALSE;
	}
	_tmp15_ = _tmp12_;
	if (_tmp15_) {
		exit (EXIT_FAILURE);
	}
	_tmp16_ = self->test_mode;
	if (!_tmp16_) {
		SettingsDaemon* _tmp17_ = NULL;
		SettingsDaemon* _tmp18_ = NULL;
		_tmp17_ = settings_daemon_new ();
		_g_object_unref0 (self->priv->settings_daemon);
		self->priv->settings_daemon = _tmp17_;
		_tmp18_ = self->priv->settings_daemon;
		settings_daemon_start (_tmp18_);
	}
	_tmp19_ = g_get_user_cache_dir ();
	_tmp20_ = g_build_filename (_tmp19_, "unity-greeter", NULL);
	state_dir = _tmp20_;
	_tmp21_ = state_dir;
	g_mkdir_with_parents (_tmp21_, 0775);
	_tmp22_ = g_getenv ("XDG_SEAT");
	_tmp23_ = g_strdup (_tmp22_);
	xdg_seat = _tmp23_;
	_tmp26_ = xdg_seat;
	if (_tmp26_ != NULL) {
		const gchar* _tmp27_ = NULL;
		_tmp27_ = xdg_seat;
		_tmp25_ = g_strcmp0 (_tmp27_, "seat0") != 0;
	} else {
		_tmp25_ = FALSE;
	}
	_tmp28_ = _tmp25_;
	if (_tmp28_) {
		const gchar* _tmp29_ = NULL;
		gchar* _tmp30_ = NULL;
		_tmp29_ = xdg_seat;
		_tmp30_ = g_strconcat (_tmp29_, "-state", NULL);
		_g_free0 (_tmp24_);
		_tmp24_ = _tmp30_;
	} else {
		gchar* _tmp31_ = NULL;
		_tmp31_ = g_strdup ("state");
		_g_free0 (_tmp24_);
		_tmp24_ = _tmp31_;
	}
	_tmp32_ = _tmp24_;
	_tmp33_ = g_strdup (_tmp32_);
	state_file_name = _tmp33_;
	_tmp34_ = state_dir;
	_tmp35_ = g_build_filename (_tmp34_, state_file_name, NULL);
	_g_free0 (self->priv->state_file);
	self->priv->state_file = _tmp35_;
	_tmp36_ = g_key_file_new ();
	_g_key_file_unref0 (self->priv->state);
	self->priv->state = _tmp36_;
	{
		GKeyFile* _tmp37_ = NULL;
		const gchar* _tmp38_ = NULL;
		_tmp37_ = self->priv->state;
		_tmp38_ = self->priv->state_file;
		g_key_file_load_from_file (_tmp37_, _tmp38_, G_KEY_FILE_NONE, &_inner_error_);
		if (_inner_error_ != NULL) {
			goto __catch29_g_error;
		}
	}
	goto __finally29;
	__catch29_g_error:
	{
		GError* e = NULL;
		GError* _tmp39_ = NULL;
		e = _inner_error_;
		_inner_error_ = NULL;
		_tmp39_ = e;
		if (!g_error_matches (_tmp39_, G_FILE_ERROR, G_FILE_ERROR_NOENT)) {
			const gchar* _tmp40_ = NULL;
			GError* _tmp41_ = NULL;
			const gchar* _tmp42_ = NULL;
			_tmp40_ = self->priv->state_file;
			_tmp41_ = e;
			_tmp42_ = _tmp41_->message;
			g_warning ("unity-greeter.vala:98: Failed to load state from %s: %s\n", _tmp40_, _tmp42_);
		}
		_g_error_free0 (e);
	}
	__finally29:
	if (_inner_error_ != NULL) {
		_g_free0 (state_file_name);
		_g_free0 (_tmp24_);
		_g_free0 (xdg_seat);
		_g_free0 (state_dir);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return NULL;
	}
	_tmp43_ = main_window_new ();
	g_object_ref_sink (_tmp43_);
	_g_object_unref0 (self->priv->main_window);
	self->priv->main_window = _tmp43_;
	g_bus_own_name_with_closures (G_BUS_TYPE_SESSION, "com.canonical.UnityGreeter", G_BUS_NAME_OWNER_FLAGS_NONE, (GClosure*) ((NULL == NULL) ? NULL : g_cclosure_new ((GCallback) NULL, NULL, NULL)), (GClosure*) ((NULL == NULL) ? NULL : g_cclosure_new ((GCallback) NULL, NULL, NULL)), (GClosure*) ((NULL == NULL) ? NULL : g_cclosure_new ((GCallback) NULL, NULL, NULL)));
	_tmp44_ = dialog_dbus_interface_new ();
	_g_object_unref0 (self->priv->dbus_object);
	self->priv->dbus_object = _tmp44_;
	_tmp45_ = self->priv->dbus_object;
	g_signal_connect (_tmp45_, "open-dialog", (GCallback) ___lambda52__dialog_dbus_interface_open_dialog, self);
	_tmp46_ = self->priv->dbus_object;
	g_signal_connect (_tmp46_, "close-dialog", (GCallback) ___lambda53__dialog_dbus_interface_close_dialog, self);
	g_bus_own_name_with_closures (G_BUS_TYPE_SESSION, "com.canonical.Unity", G_BUS_NAME_OWNER_FLAGS_NONE, (GClosure*) ((___lambda54__gbus_acquired_callback == NULL) ? NULL : g_cclosure_new ((GCallback) ___lambda54__gbus_acquired_callback, unity_greeter_ref (self), unity_greeter_unref)), (GClosure*) ((NULL == NULL) ? NULL : g_cclosure_new ((GCallback) NULL, NULL, NULL)), (GClosure*) ((___lambda55__gbus_name_lost_callback == NULL) ? NULL : g_cclosure_new ((GCallback) ___lambda55__gbus_name_lost_callback, unity_greeter_ref (self), unity_greeter_unref)));
	unity_greeter_start_fake_wm (self);
	gdk_threads_add_idle (_unity_greeter_ready_cb_gsource_func, self);
	_g_free0 (state_file_name);
	_g_free0 (_tmp24_);
	_g_free0 (xdg_seat);
	_g_free0 (state_dir);
	return self;
}


static UnityGreeter* unity_greeter_new (gboolean test_mode_) {
	return unity_greeter_construct (TYPE_UNITY_GREETER, test_mode_);
}


gchar* unity_greeter_get_state (UnityGreeter* self, const gchar* key) {
	gchar* result = NULL;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (key != NULL, NULL);
	{
		gchar* _tmp0_ = NULL;
		GKeyFile* _tmp1_ = NULL;
		const gchar* _tmp2_ = NULL;
		gchar* _tmp3_ = NULL;
		_tmp1_ = self->priv->state;
		_tmp2_ = key;
		_tmp3_ = g_key_file_get_value (_tmp1_, "greeter", _tmp2_, &_inner_error_);
		_tmp0_ = _tmp3_;
		if (_inner_error_ != NULL) {
			goto __catch31_g_error;
		}
		result = _tmp0_;
		return result;
	}
	goto __finally31;
	__catch31_g_error:
	{
		GError* e = NULL;
		e = _inner_error_;
		_inner_error_ = NULL;
		result = NULL;
		_g_error_free0 (e);
		return result;
	}
	__finally31:
	g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
	g_clear_error (&_inner_error_);
	return NULL;
}


void unity_greeter_set_state (UnityGreeter* self, const gchar* key, const gchar* value) {
	GKeyFile* _tmp0_ = NULL;
	const gchar* _tmp1_ = NULL;
	const gchar* _tmp2_ = NULL;
	gchar* data = NULL;
	GKeyFile* _tmp3_ = NULL;
	gchar* _tmp4_ = NULL;
	GError * _inner_error_ = NULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (key != NULL);
	g_return_if_fail (value != NULL);
	_tmp0_ = self->priv->state;
	_tmp1_ = key;
	_tmp2_ = value;
	g_key_file_set_value (_tmp0_, "greeter", _tmp1_, _tmp2_);
	_tmp3_ = self->priv->state;
	_tmp4_ = g_key_file_to_data (_tmp3_, NULL, NULL);
	data = _tmp4_;
	{
		const gchar* _tmp5_ = NULL;
		_tmp5_ = self->priv->state_file;
		g_file_set_contents (_tmp5_, data, (gssize) (-1), &_inner_error_);
		if (_inner_error_ != NULL) {
			goto __catch32_g_error;
		}
	}
	goto __finally32;
	__catch32_g_error:
	{
		GError* e = NULL;
		GError* _tmp6_ = NULL;
		const gchar* _tmp7_ = NULL;
		e = _inner_error_;
		_inner_error_ = NULL;
		_tmp6_ = e;
		_tmp7_ = _tmp6_->message;
		g_debug ("unity-greeter.vala:163: Failed to write state: %s", _tmp7_);
		_g_error_free0 (e);
	}
	__finally32:
	if (_inner_error_ != NULL) {
		_g_free0 (data);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return;
	}
	_g_free0 (data);
}


void unity_greeter_push_list (UnityGreeter* self, GreeterList* widget) {
	MainWindow* _tmp0_ = NULL;
	GreeterList* _tmp1_ = NULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (widget != NULL);
	_tmp0_ = self->priv->main_window;
	_tmp1_ = widget;
	main_window_push_list (_tmp0_, _tmp1_);
}


void unity_greeter_pop_list (UnityGreeter* self) {
	MainWindow* _tmp0_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->priv->main_window;
	main_window_pop_list (_tmp0_);
}


static gpointer _g_object_ref0 (gpointer self) {
	return self ? g_object_ref (self) : NULL;
}


void unity_greeter_add_style_class (GtkWidget* widget) {
	GtkStyleContext* ctx = NULL;
	GtkWidget* _tmp0_ = NULL;
	GtkStyleContext* _tmp1_ = NULL;
	GtkStyleContext* _tmp2_ = NULL;
	g_return_if_fail (widget != NULL);
	_tmp0_ = widget;
	_tmp1_ = gtk_widget_get_style_context (_tmp0_);
	_tmp2_ = _g_object_ref0 (_tmp1_);
	ctx = _tmp2_;
	gtk_style_context_add_class (ctx, "lightdm");
	_g_object_unref0 (ctx);
}


gboolean unity_greeter_start_session (UnityGreeter* self, const gchar* session, Background* bg) {
	gboolean result = FALSE;
	cairo_t* c = NULL;
	cairo_surface_t* _tmp0_ = NULL;
	cairo_t* _tmp1_ = NULL;
	Background* _tmp2_ = NULL;
	cairo_t* _tmp3_ = NULL;
	GdkScreen* _tmp4_ = NULL;
	cairo_surface_t* _tmp5_ = NULL;
	gboolean _tmp6_ = FALSE;
	const gchar* _tmp7_ = NULL;
	gboolean _tmp8_ = FALSE;
	gboolean _result_ = FALSE;
	gboolean _tmp22_ = FALSE;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (bg != NULL, FALSE);
	_tmp0_ = self->priv->background_surface;
	_tmp1_ = cairo_create (_tmp0_);
	c = _tmp1_;
	_tmp2_ = bg;
	_tmp3_ = c;
	background_draw_full (_tmp2_, _tmp3_, BACKGROUND_DRAW_FLAGS_NONE);
	_cairo_destroy0 (c);
	c = NULL;
	_tmp4_ = gdk_screen_get_default ();
	_tmp5_ = self->priv->background_surface;
	unity_greeter_refresh_background (_tmp4_, _tmp5_);
	_tmp6_ = self->test_mode;
	if (_tmp6_) {
		g_debug ("unity-greeter.vala:198: Successfully logged in! Quitting...");
		gtk_main_quit ();
		result = TRUE;
		_cairo_destroy0 (c);
		return result;
	}
	_tmp7_ = session;
	_tmp8_ = unity_greeter_session_is_valid (self, _tmp7_);
	if (!_tmp8_) {
		const gchar* _tmp9_ = NULL;
		LightDMGreeter* _tmp10_ = NULL;
		const gchar* _tmp11_ = NULL;
		const gchar* _tmp12_ = NULL;
		LightDMGreeter* _tmp13_ = NULL;
		const gchar* _tmp14_ = NULL;
		const gchar* _tmp15_ = NULL;
		_tmp9_ = session;
		_tmp10_ = self->priv->greeter;
		_tmp11_ = lightdm_greeter_get_default_session_hint (_tmp10_);
		_tmp12_ = _tmp11_;
		g_debug ("unity-greeter.vala:205: Session %s is not available, using system defa" \
"ult %s instead", _tmp9_, _tmp12_);
		_tmp13_ = self->priv->greeter;
		_tmp14_ = lightdm_greeter_get_default_session_hint (_tmp13_);
		_tmp15_ = _tmp14_;
		session = _tmp15_;
	}
	_result_ = FALSE;
	{
		gboolean _tmp16_ = FALSE;
		LightDMGreeter* _tmp17_ = NULL;
		const gchar* _tmp18_ = NULL;
		gboolean _tmp19_ = FALSE;
		_tmp17_ = self->priv->greeter;
		_tmp18_ = session;
		_tmp19_ = lightdm_greeter_start_session_sync (_tmp17_, _tmp18_, &_inner_error_);
		_tmp16_ = _tmp19_;
		if (_inner_error_ != NULL) {
			goto __catch33_g_error;
		}
		_result_ = _tmp16_;
	}
	goto __finally33;
	__catch33_g_error:
	{
		GError* e = NULL;
		GError* _tmp20_ = NULL;
		const gchar* _tmp21_ = NULL;
		e = _inner_error_;
		_inner_error_ = NULL;
		_tmp20_ = e;
		_tmp21_ = _tmp20_->message;
		g_warning ("unity-greeter.vala:216: Failed to start session: %s", _tmp21_);
		_g_error_free0 (e);
	}
	__finally33:
	if (_inner_error_ != NULL) {
		_cairo_destroy0 (c);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return FALSE;
	}
	_tmp22_ = _result_;
	if (_tmp22_) {
		g_signal_emit_by_name (self, "starting-session");
	}
	result = _result_;
	_cairo_destroy0 (c);
	return result;
}


static gboolean unity_greeter_session_is_valid (UnityGreeter* self, const gchar* session) {
	gboolean result = FALSE;
	const gchar* _tmp0_ = NULL;
	GList* _tmp1_ = NULL;
	g_return_val_if_fail (self != NULL, FALSE);
	_tmp0_ = session;
	if (_tmp0_ == NULL) {
		result = TRUE;
		return result;
	}
	_tmp1_ = lightdm_get_sessions ();
	{
		GList* s_collection = NULL;
		GList* s_it = NULL;
		s_collection = _tmp1_;
		for (s_it = s_collection; s_it != NULL; s_it = s_it->next) {
			LightDMSession* s = NULL;
			s = (LightDMSession*) s_it->data;
			{
				LightDMSession* _tmp2_ = NULL;
				const gchar* _tmp3_ = NULL;
				const gchar* _tmp4_ = NULL;
				const gchar* _tmp5_ = NULL;
				_tmp2_ = s;
				_tmp3_ = lightdm_session_get_key (_tmp2_);
				_tmp4_ = _tmp3_;
				_tmp5_ = session;
				if (g_strcmp0 (_tmp4_, _tmp5_) == 0) {
					result = TRUE;
					return result;
				}
			}
		}
	}
	result = FALSE;
	return result;
}


static gboolean unity_greeter_ready_cb (UnityGreeter* self) {
	gboolean result = FALSE;
	ca_context* _tmp0_ = NULL;
	gboolean _tmp1_ = FALSE;
	g_return_val_if_fail (self != NULL, FALSE);
	g_debug ("unity-greeter.vala:239: starting system-ready sound");
	ca_context_create (&_tmp0_);
	_ca_context_destroy0 (self->priv->canberra_context);
	self->priv->canberra_context = _tmp0_;
	_tmp1_ = ug_settings_get_boolean (UG_SETTINGS_KEY_PLAY_READY_SOUND);
	if (_tmp1_) {
		ca_context* _tmp2_ = NULL;
		_tmp2_ = self->priv->canberra_context;
		ca_context_play (_tmp2_, (guint32) 0, CA_PROP_CANBERRA_XDG_THEME_NAME, "ubuntu", CA_PROP_EVENT_ID, "system-ready", NULL);
	}
	result = FALSE;
	return result;
}


void unity_greeter_show (UnityGreeter* self) {
	MainWindow* _tmp0_ = NULL;
	MainWindow* _tmp1_ = NULL;
	GdkWindow* _tmp2_ = NULL;
	MainWindow* _tmp3_ = NULL;
	g_return_if_fail (self != NULL);
	g_debug ("unity-greeter.vala:256: Showing main window");
	_tmp0_ = self->priv->main_window;
	gtk_widget_show ((GtkWidget*) _tmp0_);
	_tmp1_ = self->priv->main_window;
	_tmp2_ = gtk_widget_get_window ((GtkWidget*) _tmp1_);
	gdk_window_focus (_tmp2_, (guint32) GDK_CURRENT_TIME);
	_tmp3_ = self->priv->main_window;
	main_window_set_keyboard_state (_tmp3_);
}


gboolean unity_greeter_is_authenticated (UnityGreeter* self) {
	gboolean result = FALSE;
	LightDMGreeter* _tmp0_ = NULL;
	gboolean _tmp1_ = FALSE;
	gboolean _tmp2_ = FALSE;
	g_return_val_if_fail (self != NULL, FALSE);
	_tmp0_ = self->priv->greeter;
	_tmp1_ = lightdm_greeter_get_is_authenticated (_tmp0_);
	_tmp2_ = _tmp1_;
	result = _tmp2_;
	return result;
}


void unity_greeter_authenticate (UnityGreeter* self, const gchar* userid) {
	LightDMGreeter* _tmp0_ = NULL;
	const gchar* _tmp1_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->priv->greeter;
	_tmp1_ = userid;
	lightdm_greeter_authenticate (_tmp0_, _tmp1_);
}


void unity_greeter_authenticate_as_guest (UnityGreeter* self) {
	LightDMGreeter* _tmp0_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->priv->greeter;
	lightdm_greeter_authenticate_as_guest (_tmp0_);
}


void unity_greeter_authenticate_remote (UnityGreeter* self, const gchar* session, const gchar* userid) {
	UnityGreeter* _tmp0_ = NULL;
	LightDMGreeter* _tmp1_ = NULL;
	const gchar* _tmp2_ = NULL;
	const gchar* _tmp3_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = unity_greeter_singleton;
	_tmp1_ = _tmp0_->priv->greeter;
	_tmp2_ = session;
	_tmp3_ = userid;
	lightdm_greeter_authenticate_remote (_tmp1_, _tmp2_, _tmp3_);
}


void unity_greeter_cancel_authentication (UnityGreeter* self) {
	LightDMGreeter* _tmp0_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->priv->greeter;
	lightdm_greeter_cancel_authentication (_tmp0_);
}


void unity_greeter_respond (UnityGreeter* self, const gchar* response) {
	LightDMGreeter* _tmp0_ = NULL;
	const gchar* _tmp1_ = NULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (response != NULL);
	_tmp0_ = self->priv->greeter;
	_tmp1_ = response;
	lightdm_greeter_respond (_tmp0_, _tmp1_);
}


gchar* unity_greeter_authentication_user (UnityGreeter* self) {
	gchar* result = NULL;
	LightDMGreeter* _tmp0_ = NULL;
	const gchar* _tmp1_ = NULL;
	const gchar* _tmp2_ = NULL;
	gchar* _tmp3_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->greeter;
	_tmp1_ = lightdm_greeter_get_authentication_user (_tmp0_);
	_tmp2_ = _tmp1_;
	_tmp3_ = g_strdup (_tmp2_);
	result = _tmp3_;
	return result;
}


gchar* unity_greeter_default_session_hint (UnityGreeter* self) {
	gchar* result = NULL;
	LightDMGreeter* _tmp0_ = NULL;
	const gchar* _tmp1_ = NULL;
	const gchar* _tmp2_ = NULL;
	gchar* _tmp3_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->greeter;
	_tmp1_ = lightdm_greeter_get_default_session_hint (_tmp0_);
	_tmp2_ = _tmp1_;
	_tmp3_ = g_strdup (_tmp2_);
	result = _tmp3_;
	return result;
}


gchar* unity_greeter_select_user_hint (UnityGreeter* self) {
	gchar* result = NULL;
	LightDMGreeter* _tmp0_ = NULL;
	const gchar* _tmp1_ = NULL;
	const gchar* _tmp2_ = NULL;
	gchar* _tmp3_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->greeter;
	_tmp1_ = lightdm_greeter_get_select_user_hint (_tmp0_);
	_tmp2_ = _tmp1_;
	_tmp3_ = g_strdup (_tmp2_);
	result = _tmp3_;
	return result;
}


gboolean unity_greeter_show_manual_login_hint (UnityGreeter* self) {
	gboolean result = FALSE;
	LightDMGreeter* _tmp0_ = NULL;
	gboolean _tmp1_ = FALSE;
	gboolean _tmp2_ = FALSE;
	g_return_val_if_fail (self != NULL, FALSE);
	_tmp0_ = self->priv->greeter;
	_tmp1_ = lightdm_greeter_get_show_manual_login_hint (_tmp0_);
	_tmp2_ = _tmp1_;
	result = _tmp2_;
	return result;
}


gboolean unity_greeter_show_remote_login_hint (UnityGreeter* self) {
	gboolean result = FALSE;
	LightDMGreeter* _tmp0_ = NULL;
	gboolean _tmp1_ = FALSE;
	gboolean _tmp2_ = FALSE;
	g_return_val_if_fail (self != NULL, FALSE);
	_tmp0_ = self->priv->greeter;
	_tmp1_ = lightdm_greeter_get_show_remote_login_hint (_tmp0_);
	_tmp2_ = _tmp1_;
	result = _tmp2_;
	return result;
}


gboolean unity_greeter_hide_users_hint (UnityGreeter* self) {
	gboolean result = FALSE;
	LightDMGreeter* _tmp0_ = NULL;
	gboolean _tmp1_ = FALSE;
	gboolean _tmp2_ = FALSE;
	g_return_val_if_fail (self != NULL, FALSE);
	_tmp0_ = self->priv->greeter;
	_tmp1_ = lightdm_greeter_get_hide_users_hint (_tmp0_);
	_tmp2_ = _tmp1_;
	result = _tmp2_;
	return result;
}


gboolean unity_greeter_has_guest_account_hint (UnityGreeter* self) {
	gboolean result = FALSE;
	LightDMGreeter* _tmp0_ = NULL;
	gboolean _tmp1_ = FALSE;
	gboolean _tmp2_ = FALSE;
	g_return_val_if_fail (self != NULL, FALSE);
	_tmp0_ = self->priv->greeter;
	_tmp1_ = lightdm_greeter_get_has_guest_account_hint (_tmp0_);
	_tmp2_ = _tmp1_;
	result = _tmp2_;
	return result;
}


static GdkFilterReturn unity_greeter_focus_upon_map (UnityGreeter* self, GdkXEvent* gxevent, GdkEvent* event) {
	GdkFilterReturn result = 0;
	XEvent* xevent = NULL;
	GdkXEvent* _tmp0_ = NULL;
	XEvent* _tmp1_ = NULL;
	gint _tmp2_ = 0;
	g_return_val_if_fail (self != NULL, 0);
	g_return_val_if_fail (gxevent != NULL, 0);
	g_return_val_if_fail (event != NULL, 0);
	_tmp0_ = gxevent;
	xevent = (XEvent*) _tmp0_;
	_tmp1_ = xevent;
	_tmp2_ = (*_tmp1_).type;
	if (_tmp2_ == ((gint) MapNotify)) {
		GdkDisplay* display = NULL;
		XEvent* _tmp3_ = NULL;
		XMapEvent _tmp4_ = {0};
		Display* _tmp5_ = NULL;
		GdkDisplay* _tmp6_ = NULL;
		GdkDisplay* _tmp7_ = NULL;
		Window xwin = 0;
		XEvent* _tmp8_ = NULL;
		XMapEvent _tmp9_ = {0};
		Window _tmp10_ = 0;
		GdkWindow* win = NULL;
		GdkDisplay* _tmp11_ = NULL;
		Window _tmp12_ = 0;
		GdkWindow* _tmp13_ = NULL;
		GdkWindow* _tmp14_ = NULL;
		gboolean _tmp15_ = FALSE;
		GdkWindow* _tmp16_ = NULL;
		gboolean _tmp20_ = FALSE;
		_tmp3_ = xevent;
		_tmp4_ = (*_tmp3_).xmap;
		_tmp5_ = _tmp4_.display;
		_tmp6_ = gdk_x11_lookup_xdisplay (_tmp5_);
		_tmp7_ = _g_object_ref0 (_tmp6_);
		display = _tmp7_;
		_tmp8_ = xevent;
		_tmp9_ = (*_tmp8_).xmap;
		_tmp10_ = _tmp9_.window;
		xwin = _tmp10_;
		_tmp11_ = display;
		_tmp12_ = xwin;
		_tmp13_ = gdk_x11_window_foreign_new_for_display (_tmp11_, _tmp12_);
		_tmp14_ = _g_object_ref0 (_tmp13_);
		win = _tmp14_;
		_tmp16_ = win;
		if (_tmp16_ != NULL) {
			XEvent* _tmp17_ = NULL;
			XMapEvent _tmp18_ = {0};
			gboolean _tmp19_ = FALSE;
			_tmp17_ = xevent;
			_tmp18_ = (*_tmp17_).xmap;
			_tmp19_ = _tmp18_.override_redirect;
			_tmp15_ = !_tmp19_;
		} else {
			_tmp15_ = FALSE;
		}
		_tmp20_ = _tmp15_;
		if (_tmp20_) {
			Window keyboard_xid = 0;
			MainWindow* _tmp21_ = NULL;
			GtkWindow* _tmp22_ = NULL;
			GtkWindow* _tmp23_ = NULL;
			gboolean _tmp29_ = FALSE;
			Window _tmp30_ = 0;
			Window _tmp31_ = 0;
			gboolean _tmp34_ = FALSE;
			keyboard_xid = (Window) 0;
			_tmp21_ = self->priv->main_window;
			_tmp22_ = main_window_get_keyboard_window (_tmp21_);
			_tmp23_ = _tmp22_;
			if (_tmp23_ != NULL) {
				MainWindow* _tmp24_ = NULL;
				GtkWindow* _tmp25_ = NULL;
				GtkWindow* _tmp26_ = NULL;
				GdkWindow* _tmp27_ = NULL;
				Window _tmp28_ = 0;
				_tmp24_ = self->priv->main_window;
				_tmp25_ = main_window_get_keyboard_window (_tmp24_);
				_tmp26_ = _tmp25_;
				_tmp27_ = gtk_widget_get_window ((GtkWidget*) _tmp26_);
				_tmp28_ = gdk_x11_window_get_xid (_tmp27_);
				keyboard_xid = _tmp28_;
			}
			_tmp30_ = xwin;
			_tmp31_ = keyboard_xid;
			if (_tmp30_ != _tmp31_) {
				GdkWindow* _tmp32_ = NULL;
				GdkWindowTypeHint _tmp33_ = 0;
				_tmp32_ = win;
				_tmp33_ = gdk_window_get_type_hint (_tmp32_);
				_tmp29_ = _tmp33_ != GDK_WINDOW_TYPE_HINT_NOTIFICATION;
			} else {
				_tmp29_ = FALSE;
			}
			_tmp34_ = _tmp29_;
			if (_tmp34_) {
				GdkWindow* _tmp35_ = NULL;
				MainWindow* _tmp36_ = NULL;
				GtkWindow* _tmp37_ = NULL;
				GtkWindow* _tmp38_ = NULL;
				_tmp35_ = win;
				gdk_window_focus (_tmp35_, (guint32) GDK_CURRENT_TIME);
				_tmp36_ = self->priv->main_window;
				_tmp37_ = main_window_get_keyboard_window (_tmp36_);
				_tmp38_ = _tmp37_;
				if (_tmp38_ != NULL) {
					MainWindow* _tmp39_ = NULL;
					GtkWindow* _tmp40_ = NULL;
					GtkWindow* _tmp41_ = NULL;
					GdkWindow* _tmp42_ = NULL;
					_tmp39_ = self->priv->main_window;
					_tmp40_ = main_window_get_keyboard_window (_tmp39_);
					_tmp41_ = _tmp40_;
					_tmp42_ = gtk_widget_get_window ((GtkWidget*) _tmp41_);
					gdk_window_raise (_tmp42_);
				}
			}
		}
		_g_object_unref0 (win);
		_g_object_unref0 (display);
	} else {
		XEvent* _tmp43_ = NULL;
		gint _tmp44_ = 0;
		_tmp43_ = xevent;
		_tmp44_ = (*_tmp43_).type;
		if (_tmp44_ == ((gint) UnmapNotify)) {
			Window xwin = 0;
			gint revert_to = 0;
			XEvent* _tmp45_ = NULL;
			XUnmapEvent _tmp46_ = {0};
			Display* _tmp47_ = NULL;
			Window _tmp48_ = 0;
			gint _tmp49_ = 0;
			gint _tmp50_ = 0;
			_tmp45_ = xevent;
			_tmp46_ = (*_tmp45_).xunmap;
			_tmp47_ = _tmp46_.display;
			XGetInputFocus (_tmp47_, &_tmp48_, &_tmp49_);
			xwin = _tmp48_;
			revert_to = _tmp49_;
			_tmp50_ = revert_to;
			if (_tmp50_ == ((gint) RevertToNone)) {
				MainWindow* _tmp51_ = NULL;
				GdkWindow* _tmp52_ = NULL;
				MainWindow* _tmp53_ = NULL;
				GtkWindow* _tmp54_ = NULL;
				GtkWindow* _tmp55_ = NULL;
				_tmp51_ = self->priv->main_window;
				_tmp52_ = gtk_widget_get_window ((GtkWidget*) _tmp51_);
				gdk_window_focus (_tmp52_, (guint32) GDK_CURRENT_TIME);
				_tmp53_ = self->priv->main_window;
				_tmp54_ = main_window_get_keyboard_window (_tmp53_);
				_tmp55_ = _tmp54_;
				if (_tmp55_ != NULL) {
					MainWindow* _tmp56_ = NULL;
					GtkWindow* _tmp57_ = NULL;
					GtkWindow* _tmp58_ = NULL;
					GdkWindow* _tmp59_ = NULL;
					_tmp56_ = self->priv->main_window;
					_tmp57_ = main_window_get_keyboard_window (_tmp56_);
					_tmp58_ = _tmp57_;
					_tmp59_ = gtk_widget_get_window ((GtkWidget*) _tmp58_);
					gdk_window_raise (_tmp59_);
				}
			}
		}
	}
	result = GDK_FILTER_CONTINUE;
	return result;
}


static GdkFilterReturn _unity_greeter_focus_upon_map_gdk_filter_func (GdkXEvent* xevent, GdkEvent* event, gpointer self) {
	GdkFilterReturn result;
	result = unity_greeter_focus_upon_map (self, xevent, event);
	return result;
}


static void unity_greeter_start_fake_wm (UnityGreeter* self) {
	GdkWindow* root = NULL;
	GdkWindow* _tmp0_ = NULL;
	GdkWindow* _tmp1_ = NULL;
	GdkEventMask _tmp2_ = 0;
	g_return_if_fail (self != NULL);
	_tmp0_ = gdk_get_default_root_window ();
	_tmp1_ = _g_object_ref0 (_tmp0_);
	root = _tmp1_;
	_tmp2_ = gdk_window_get_events (root);
	gdk_window_set_events (root, _tmp2_ | GDK_SUBSTRUCTURE_MASK);
	gdk_window_add_filter (root, _unity_greeter_focus_upon_map_gdk_filter_func, self);
	_g_object_unref0 (root);
}


static cairo_surface_t* unity_greeter_create_root_surface (GdkScreen* screen) {
	cairo_surface_t* result = NULL;
	GdkVisual* visual = NULL;
	GdkScreen* _tmp0_ = NULL;
	GdkVisual* _tmp1_ = NULL;
	GdkVisual* _tmp2_ = NULL;
	Display* display = NULL;
	GdkScreen* _tmp3_ = NULL;
	GdkDisplay* _tmp4_ = NULL;
	Display* _tmp5_ = NULL;
	gint pixmap = 0;
	GdkScreen* _tmp6_ = NULL;
	GdkWindow* _tmp7_ = NULL;
	Window _tmp8_ = 0;
	GdkScreen* _tmp9_ = NULL;
	gint _tmp10_ = 0;
	GdkScreen* _tmp11_ = NULL;
	gint _tmp12_ = 0;
	gint _tmp13_ = 0;
	gint _tmp14_ = 0;
	cairo_surface_t* surface = NULL;
	Visual* _tmp15_ = NULL;
	GdkScreen* _tmp16_ = NULL;
	gint _tmp17_ = 0;
	GdkScreen* _tmp18_ = NULL;
	gint _tmp19_ = 0;
	cairo_surface_t* _tmp20_ = NULL;
	g_return_val_if_fail (screen != NULL, NULL);
	_tmp0_ = screen;
	_tmp1_ = gdk_screen_get_system_visual (_tmp0_);
	_tmp2_ = _g_object_ref0 (_tmp1_);
	visual = _tmp2_;
	_tmp3_ = screen;
	_tmp4_ = gdk_screen_get_display (_tmp3_);
	_tmp5_ = gdk_x11_display_get_xdisplay (_tmp4_);
	display = _tmp5_;
	_tmp6_ = screen;
	_tmp7_ = gdk_screen_get_root_window (_tmp6_);
	_tmp8_ = gdk_x11_window_get_xid (_tmp7_);
	_tmp9_ = screen;
	_tmp10_ = gdk_screen_get_width (_tmp9_);
	_tmp11_ = screen;
	_tmp12_ = gdk_screen_get_height (_tmp11_);
	_tmp13_ = gdk_visual_get_depth (visual);
	_tmp14_ = XCreatePixmap (display, (Drawable) _tmp8_, (guint) _tmp10_, (guint) _tmp12_, (guint) _tmp13_);
	pixmap = _tmp14_;
	_tmp15_ = gdk_x11_visual_get_xvisual (visual);
	_tmp16_ = screen;
	_tmp17_ = gdk_screen_get_width (_tmp16_);
	_tmp18_ = screen;
	_tmp19_ = gdk_screen_get_height (_tmp18_);
	_tmp20_ = cairo_xlib_surface_create (display, pixmap, _tmp15_, _tmp17_, _tmp19_);
	surface = _tmp20_;
	result = surface;
	_g_object_unref0 (visual);
	return result;
}


static void unity_greeter_refresh_background (GdkScreen* screen, cairo_surface_t* surface) {
	Display* display = NULL;
	GdkScreen* _tmp0_ = NULL;
	GdkDisplay* _tmp1_ = NULL;
	Display* _tmp2_ = NULL;
	cairo_surface_t* _tmp3_ = NULL;
	GdkScreen* _tmp4_ = NULL;
	GdkWindow* _tmp5_ = NULL;
	Window _tmp6_ = 0;
	cairo_surface_t* _tmp7_ = NULL;
	gint _tmp8_ = 0;
	GdkScreen* _tmp9_ = NULL;
	GdkWindow* _tmp10_ = NULL;
	Window _tmp11_ = 0;
	g_return_if_fail (screen != NULL);
	g_return_if_fail (surface != NULL);
	gdk_flush ();
	_tmp0_ = screen;
	_tmp1_ = gdk_screen_get_display (_tmp0_);
	_tmp2_ = gdk_x11_display_get_xdisplay (_tmp1_);
	display = _tmp2_;
	_tmp3_ = surface;
	cairo_surface_flush (_tmp3_);
	_tmp4_ = screen;
	_tmp5_ = gdk_screen_get_root_window (_tmp4_);
	_tmp6_ = gdk_x11_window_get_xid (_tmp5_);
	_tmp7_ = surface;
	_tmp8_ = cairo_xlib_surface_get_drawable (_tmp7_);
	XSetWindowBackgroundPixmap (display, _tmp6_, _tmp8_);
	_tmp9_ = screen;
	_tmp10_ = gdk_screen_get_root_window (_tmp9_);
	_tmp11_ = gdk_x11_window_get_xid (_tmp10_);
	XClearWindow (display, _tmp11_);
}


static void unity_greeter_log_cb (const gchar* log_domain, GLogLevelFlags log_level, const gchar* message) {
	gchar* prefix = NULL;
	GLogLevelFlags _tmp0_ = 0;
	FILE* _tmp8_ = NULL;
	GTimer* _tmp9_ = NULL;
	gdouble _tmp10_ = 0.0;
	const gchar* _tmp11_ = NULL;
	const gchar* _tmp12_ = NULL;
	g_return_if_fail (message != NULL);
	_tmp0_ = log_level;
	switch (_tmp0_ & G_LOG_LEVEL_MASK) {
		case G_LOG_LEVEL_ERROR:
		{
			gchar* _tmp1_ = NULL;
			_tmp1_ = g_strdup ("ERROR:");
			_g_free0 (prefix);
			prefix = _tmp1_;
			break;
		}
		case G_LOG_LEVEL_CRITICAL:
		{
			gchar* _tmp2_ = NULL;
			_tmp2_ = g_strdup ("CRITICAL:");
			_g_free0 (prefix);
			prefix = _tmp2_;
			break;
		}
		case G_LOG_LEVEL_WARNING:
		{
			gchar* _tmp3_ = NULL;
			_tmp3_ = g_strdup ("WARNING:");
			_g_free0 (prefix);
			prefix = _tmp3_;
			break;
		}
		case G_LOG_LEVEL_MESSAGE:
		{
			gchar* _tmp4_ = NULL;
			_tmp4_ = g_strdup ("MESSAGE:");
			_g_free0 (prefix);
			prefix = _tmp4_;
			break;
		}
		case G_LOG_LEVEL_INFO:
		{
			gchar* _tmp5_ = NULL;
			_tmp5_ = g_strdup ("INFO:");
			_g_free0 (prefix);
			prefix = _tmp5_;
			break;
		}
		case G_LOG_LEVEL_DEBUG:
		{
			gchar* _tmp6_ = NULL;
			_tmp6_ = g_strdup ("DEBUG:");
			_g_free0 (prefix);
			prefix = _tmp6_;
			break;
		}
		default:
		{
			gchar* _tmp7_ = NULL;
			_tmp7_ = g_strdup ("LOG:");
			_g_free0 (prefix);
			prefix = _tmp7_;
			break;
		}
	}
	_tmp8_ = stderr;
	_tmp9_ = unity_greeter_log_timer;
	_tmp10_ = g_timer_elapsed (_tmp9_, NULL);
	_tmp11_ = prefix;
	_tmp12_ = message;
	fprintf (_tmp8_, "[%+.2fs] %s %s\n", _tmp10_, _tmp11_, _tmp12_);
	_g_free0 (prefix);
}


static void _unity_greeter_log_cb_glog_func (const gchar* log_domain, GLogLevelFlags log_levels, const gchar* message, gpointer self) {
	unity_greeter_log_cb (log_domain, log_levels, message);
}


static gboolean __lambda56_ (void) {
	gboolean result = FALSE;
	g_debug ("unity-greeter.vala:581: Got a SIGTERM");
	gtk_main_quit ();
	result = TRUE;
	return result;
}


static gboolean ___lambda56__gsource_func (gpointer self) {
	gboolean result;
	result = __lambda56_ ();
	return result;
}


gint unity_greeter_main (gchar** args, int args_length1) {
	gint result = 0;
	GPid atspi_pid = 0;
	GPid upstart_pid = 0;
	GTimer* _tmp6_ = NULL;
	uid_t _tmp7_ = {0};
	const gchar* _tmp8_ = NULL;
	GdkWindow* _tmp9_ = NULL;
	GdkCursor* _tmp10_ = NULL;
	GdkCursor* _tmp11_ = NULL;
	gboolean do_show_version = FALSE;
	gboolean do_test_mode = FALSE;
	GOptionEntry versionOption = {0};
	GOptionEntry _tmp12_ = {0};
	GOptionEntry testOption = {0};
	GOptionEntry _tmp13_ = {0};
	GOptionEntry nullOption = {0};
	GOptionEntry _tmp14_ = {0};
	GOptionEntry* options = NULL;
	GOptionEntry _tmp15_ = {0};
	GOptionEntry _tmp16_ = {0};
	GOptionEntry _tmp17_ = {0};
	GOptionEntry* _tmp18_ = NULL;
	gint options_length1 = 0;
	gint _options_size_ = 0;
	GOptionContext* c = NULL;
	const gchar* _tmp19_ = NULL;
	GOptionContext* _tmp20_ = NULL;
	GOptionContext* _tmp21_ = NULL;
	GOptionEntry* _tmp22_ = NULL;
	gint _tmp22__length1 = 0;
	GOptionContext* _tmp23_ = NULL;
	GOptionGroup* _tmp24_ = NULL;
	gboolean _tmp34_ = FALSE;
	gboolean _tmp36_ = FALSE;
	GtkSettings* settings = NULL;
	GtkSettings* _tmp37_ = NULL;
	GtkSettings* _tmp38_ = NULL;
	gchar* value = NULL;
	gchar* _tmp39_ = NULL;
	const gchar* _tmp40_ = NULL;
	gchar* _tmp43_ = NULL;
	const gchar* _tmp44_ = NULL;
	gchar* _tmp47_ = NULL;
	const gchar* _tmp48_ = NULL;
	gdouble double_value = 0.0;
	gdouble _tmp51_ = 0.0;
	gdouble _tmp52_ = 0.0;
	gboolean boolean_value = FALSE;
	gboolean _tmp55_ = FALSE;
	GtkSettings* _tmp56_ = NULL;
	gboolean _tmp57_ = FALSE;
	gchar* _tmp58_ = NULL;
	const gchar* _tmp59_ = NULL;
	gchar* _tmp62_ = NULL;
	const gchar* _tmp63_ = NULL;
	UnityGreeter* greeter = NULL;
	gboolean _tmp66_ = FALSE;
	UnityGreeter* _tmp67_ = NULL;
	UnityGreeter* _tmp68_ = NULL;
	gboolean _tmp69_ = FALSE;
	GPid _tmp70_ = 0;
	GPid _tmp80_ = 0;
	GError * _inner_error_ = NULL;
	mlockall (MCL_CURRENT | MCL_FUTURE);
	g_unsetenv ("UBUNTU_MENUPROXY");
	setlocale (LC_ALL, "");
	bindtextdomain (GETTEXT_PACKAGE, LOCALEDIR);
	bind_textdomain_codeset (GETTEXT_PACKAGE, "UTF-8");
	textdomain (GETTEXT_PACKAGE);
	g_setenv ("GTK_MODULES", "atk-bridge", FALSE);
	atspi_pid = (GPid) 0;
	upstart_pid = (GPid) 0;
	{
		gchar** argv = NULL;
		gint argv_length1 = 0;
		gint _argv_size_ = 0;
		gchar** _tmp0_ = NULL;
		gint _tmp1_ = 0;
		gchar** _tmp2_ = NULL;
		gint _tmp2__length1 = 0;
		GPid _tmp3_ = 0;
		g_shell_parse_argv ("/usr/lib/at-spi2-core/at-spi-bus-launcher --launch-immediately", &_tmp1_, &_tmp0_, &_inner_error_);
		argv = (_vala_array_free (argv, argv_length1, (GDestroyNotify) g_free), NULL);
		argv = _tmp0_;
		argv_length1 = _tmp1_;
		_argv_size_ = argv_length1;
		if (_inner_error_ != NULL) {
			argv = (_vala_array_free (argv, argv_length1, (GDestroyNotify) g_free), NULL);
			goto __catch34_g_error;
		}
		_tmp2_ = argv;
		_tmp2__length1 = argv_length1;
		g_spawn_async (NULL, _tmp2_, NULL, G_SPAWN_SEARCH_PATH, NULL, NULL, &_tmp3_, &_inner_error_);
		atspi_pid = _tmp3_;
		if (_inner_error_ != NULL) {
			argv = (_vala_array_free (argv, argv_length1, (GDestroyNotify) g_free), NULL);
			goto __catch34_g_error;
		}
		argv = (_vala_array_free (argv, argv_length1, (GDestroyNotify) g_free), NULL);
	}
	goto __finally34;
	__catch34_g_error:
	{
		GError* e = NULL;
		GError* _tmp4_ = NULL;
		const gchar* _tmp5_ = NULL;
		e = _inner_error_;
		_inner_error_ = NULL;
		_tmp4_ = e;
		_tmp5_ = _tmp4_->message;
		g_warning ("unity-greeter.vala:491: Error starting the at-spi registry: %s", _tmp5_);
		_g_error_free0 (e);
	}
	__finally34:
	if (_inner_error_ != NULL) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return 0;
	}
	gtk_init (&args_length1, &args);
	ido_init ();
	_tmp6_ = g_timer_new ();
	_g_timer_destroy0 (unity_greeter_log_timer);
	unity_greeter_log_timer = _tmp6_;
	g_log_set_default_handler (_unity_greeter_log_cb_glog_func, NULL);
	_tmp7_ = getuid ();
	_tmp8_ = g_getenv ("LANG");
	g_debug ("unity-greeter.vala:500: Starting unity-greeter %s UID=%d LANG=%s", VERSION, (gint) _tmp7_, _tmp8_);
	g_debug ("unity-greeter.vala:503: Setting cursor");
	_tmp9_ = gdk_get_default_root_window ();
	_tmp10_ = gdk_cursor_new (GDK_LEFT_PTR);
	_tmp11_ = _tmp10_;
	gdk_window_set_cursor (_tmp9_, _tmp11_);
	_g_object_unref0 (_tmp11_);
	do_show_version = FALSE;
	do_test_mode = FALSE;
	_tmp12_.long_name = "version";
	_tmp12_.short_name = 'v';
	_tmp12_.flags = 0;
	_tmp12_.arg = G_OPTION_ARG_NONE;
	_tmp12_.arg_data = &do_show_version;
	_tmp12_.description = "Show release version";
	_tmp12_.arg_description = NULL;
	versionOption = _tmp12_;
	_tmp13_.long_name = "test-mode";
	_tmp13_.short_name = (gchar) 0;
	_tmp13_.flags = 0;
	_tmp13_.arg = G_OPTION_ARG_NONE;
	_tmp13_.arg_data = &do_test_mode;
	_tmp13_.description = "Run in test mode";
	_tmp13_.arg_description = NULL;
	testOption = _tmp13_;
	_tmp14_.long_name = NULL;
	nullOption = _tmp14_;
	_tmp15_ = versionOption;
	_tmp16_ = testOption;
	_tmp17_ = nullOption;
	_tmp18_ = g_new0 (GOptionEntry, 3);
	_tmp18_[0] = _tmp15_;
	_tmp18_[1] = _tmp16_;
	_tmp18_[2] = _tmp17_;
	options = _tmp18_;
	options_length1 = 3;
	_options_size_ = options_length1;
	g_debug ("unity-greeter.vala:517: Loading command line options");
	_tmp19_ = _ ("- Unity Greeter");
	_tmp20_ = g_option_context_new (_tmp19_);
	c = _tmp20_;
	_tmp21_ = c;
	_tmp22_ = options;
	_tmp22__length1 = options_length1;
	g_option_context_add_main_entries (_tmp21_, _tmp22_, GETTEXT_PACKAGE);
	_tmp23_ = c;
	_tmp24_ = gtk_get_option_group (TRUE);
	g_option_context_add_group (_tmp23_, _tmp24_);
	{
		GOptionContext* _tmp25_ = NULL;
		_tmp25_ = c;
		g_option_context_parse (_tmp25_, &args_length1, &args, &_inner_error_);
		if (_inner_error_ != NULL) {
			goto __catch35_g_error;
		}
	}
	goto __finally35;
	__catch35_g_error:
	{
		GError* e = NULL;
		FILE* _tmp26_ = NULL;
		GError* _tmp27_ = NULL;
		const gchar* _tmp28_ = NULL;
		FILE* _tmp29_ = NULL;
		const gchar* _tmp30_ = NULL;
		gchar** _tmp31_ = NULL;
		gint _tmp31__length1 = 0;
		const gchar* _tmp32_ = NULL;
		FILE* _tmp33_ = NULL;
		e = _inner_error_;
		_inner_error_ = NULL;
		_tmp26_ = stderr;
		_tmp27_ = e;
		_tmp28_ = _tmp27_->message;
		fprintf (_tmp26_, "%s\n", _tmp28_);
		_tmp29_ = stderr;
		_tmp30_ = _ ("Run '%s --help' to see a full list of available command line options.");
		_tmp31_ = args;
		_tmp31__length1 = args_length1;
		_tmp32_ = _tmp31_[0];
		fprintf (_tmp29_, _tmp30_, _tmp32_);
		_tmp33_ = stderr;
		fprintf (_tmp33_, "\n");
		result = EXIT_FAILURE;
		_g_error_free0 (e);
		_g_option_context_free0 (c);
		options = (g_free (options), NULL);
		return result;
	}
	__finally35:
	if (_inner_error_ != NULL) {
		_g_option_context_free0 (c);
		options = (g_free (options), NULL);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return 0;
	}
	_tmp34_ = do_show_version;
	if (_tmp34_) {
		FILE* _tmp35_ = NULL;
		_tmp35_ = stderr;
		fprintf (_tmp35_, "unity-greeter %s\n", VERSION);
		result = EXIT_SUCCESS;
		_g_option_context_free0 (c);
		options = (g_free (options), NULL);
		return result;
	}
	_tmp36_ = do_test_mode;
	if (_tmp36_) {
		g_debug ("unity-greeter.vala:542: Running in test mode");
	}
	g_debug ("unity-greeter.vala:545: Setting GTK+ settings");
	_tmp37_ = gtk_settings_get_default ();
	_tmp38_ = _g_object_ref0 (_tmp37_);
	settings = _tmp38_;
	_tmp39_ = ug_settings_get_string (UG_SETTINGS_KEY_THEME_NAME);
	value = _tmp39_;
	_tmp40_ = value;
	if (g_strcmp0 (_tmp40_, "") != 0) {
		GtkSettings* _tmp41_ = NULL;
		const gchar* _tmp42_ = NULL;
		_tmp41_ = settings;
		_tmp42_ = value;
		g_object_set ((GObject*) _tmp41_, "gtk-theme-name", _tmp42_, NULL, NULL);
	}
	_tmp43_ = ug_settings_get_string (UG_SETTINGS_KEY_ICON_THEME_NAME);
	_g_free0 (value);
	value = _tmp43_;
	_tmp44_ = value;
	if (g_strcmp0 (_tmp44_, "") != 0) {
		GtkSettings* _tmp45_ = NULL;
		const gchar* _tmp46_ = NULL;
		_tmp45_ = settings;
		_tmp46_ = value;
		g_object_set ((GObject*) _tmp45_, "gtk-icon-theme-name", _tmp46_, NULL, NULL);
	}
	_tmp47_ = ug_settings_get_string (UG_SETTINGS_KEY_FONT_NAME);
	_g_free0 (value);
	value = _tmp47_;
	_tmp48_ = value;
	if (g_strcmp0 (_tmp48_, "") != 0) {
		GtkSettings* _tmp49_ = NULL;
		const gchar* _tmp50_ = NULL;
		_tmp49_ = settings;
		_tmp50_ = value;
		g_object_set ((GObject*) _tmp49_, "gtk-font-name", _tmp50_, NULL, NULL);
	}
	_tmp51_ = ug_settings_get_double (UG_SETTINGS_KEY_XFT_DPI);
	double_value = _tmp51_;
	_tmp52_ = double_value;
	if (_tmp52_ != 0.0) {
		GtkSettings* _tmp53_ = NULL;
		gdouble _tmp54_ = 0.0;
		_tmp53_ = settings;
		_tmp54_ = double_value;
		g_object_set ((GObject*) _tmp53_, "gtk-xft-dpi", (gint) (1024 * _tmp54_), NULL, NULL);
	}
	_tmp55_ = ug_settings_get_boolean (UG_SETTINGS_KEY_XFT_ANTIALIAS);
	boolean_value = _tmp55_;
	_tmp56_ = settings;
	_tmp57_ = boolean_value;
	g_object_set ((GObject*) _tmp56_, "gtk-xft-antialias", _tmp57_, NULL, NULL);
	_tmp58_ = ug_settings_get_string (UG_SETTINGS_KEY_XFT_HINTSTYLE);
	_g_free0 (value);
	value = _tmp58_;
	_tmp59_ = value;
	if (g_strcmp0 (_tmp59_, "") != 0) {
		GtkSettings* _tmp60_ = NULL;
		const gchar* _tmp61_ = NULL;
		_tmp60_ = settings;
		_tmp61_ = value;
		g_object_set ((GObject*) _tmp60_, "gtk-xft-hintstyle", _tmp61_, NULL, NULL);
	}
	_tmp62_ = ug_settings_get_string (UG_SETTINGS_KEY_XFT_RGBA);
	_g_free0 (value);
	value = _tmp62_;
	_tmp63_ = value;
	if (g_strcmp0 (_tmp63_, "") != 0) {
		GtkSettings* _tmp64_ = NULL;
		const gchar* _tmp65_ = NULL;
		_tmp64_ = settings;
		_tmp65_ = value;
		g_object_set ((GObject*) _tmp64_, "gtk-xft-rgba", _tmp65_, NULL, NULL);
	}
	g_debug ("unity-greeter.vala:568: Creating Unity Greeter");
	_tmp66_ = do_test_mode;
	_tmp67_ = unity_greeter_new (_tmp66_);
	greeter = _tmp67_;
	g_debug ("unity-greeter.vala:571: Showing greeter");
	_tmp68_ = greeter;
	unity_greeter_show (_tmp68_);
	_tmp69_ = do_test_mode;
	if (!_tmp69_) {
	}
	g_unix_signal_add_full (G_PRIORITY_DEFAULT, (gint) SIGTERM, ___lambda56__gsource_func, NULL, NULL);
	g_debug ("unity-greeter.vala:586: Starting main loop");
	gtk_main ();
	g_debug ("unity-greeter.vala:589: Cleaning up");
	_tmp70_ = upstart_pid;
	if (_tmp70_ != ((GPid) 0)) {
		GPid _tmp71_ = 0;
		gint status = 0;
		GPid _tmp72_ = 0;
		gint _tmp73_ = 0;
		gint _tmp74_ = 0;
		gboolean _tmp75_ = FALSE;
		_tmp71_ = upstart_pid;
		kill ((pid_t) _tmp71_, SIGTERM);
		_tmp72_ = upstart_pid;
		waitpid ((pid_t) _tmp72_, &_tmp73_, 0);
		status = _tmp73_;
		_tmp74_ = status;
		_tmp75_ = WIFEXITED (_tmp74_);
		if (_tmp75_) {
			gint _tmp76_ = 0;
			gint _tmp77_ = 0;
			_tmp76_ = status;
			_tmp77_ = WEXITSTATUS (_tmp76_);
			g_debug ("unity-greeter.vala:597: Upstart exited with return value %d", _tmp77_);
		} else {
			gint _tmp78_ = 0;
			int _tmp79_ = 0;
			_tmp78_ = status;
			_tmp79_ = WTERMSIG (_tmp78_);
			g_debug ("unity-greeter.vala:599: Upstart terminated with signal %d", (gint) _tmp79_);
		}
		upstart_pid = (GPid) 0;
	}
	_tmp80_ = atspi_pid;
	if (_tmp80_ != ((GPid) 0)) {
		GPid _tmp81_ = 0;
		gint status = 0;
		GPid _tmp82_ = 0;
		gint _tmp83_ = 0;
		gint _tmp84_ = 0;
		gboolean _tmp85_ = FALSE;
		_tmp81_ = atspi_pid;
		kill ((pid_t) _tmp81_, SIGKILL);
		_tmp82_ = atspi_pid;
		waitpid ((pid_t) _tmp82_, &_tmp83_, 0);
		status = _tmp83_;
		_tmp84_ = status;
		_tmp85_ = WIFEXITED (_tmp84_);
		if (_tmp85_) {
			gint _tmp86_ = 0;
			gint _tmp87_ = 0;
			_tmp86_ = status;
			_tmp87_ = WEXITSTATUS (_tmp86_);
			g_debug ("unity-greeter.vala:609: AT-SPI exited with return value %d", _tmp87_);
		} else {
			gint _tmp88_ = 0;
			int _tmp89_ = 0;
			_tmp88_ = status;
			_tmp89_ = WTERMSIG (_tmp88_);
			g_debug ("unity-greeter.vala:611: AT-SPI terminated with signal %d", (gint) _tmp89_);
		}
		atspi_pid = (GPid) 0;
	}
	g_debug ("unity-greeter.vala:615: Exiting");
	result = EXIT_SUCCESS;
	_unity_greeter_unref0 (greeter);
	_g_free0 (value);
	_g_object_unref0 (settings);
	_g_option_context_free0 (c);
	options = (g_free (options), NULL);
	return result;
}


int main (int argc, char ** argv) {
	g_type_init ();
	return unity_greeter_main (argv, argc);
}


static void g_cclosure_user_marshal_VOID__STRING_INT (GClosure * closure, GValue * return_value, guint n_param_values, const GValue * param_values, gpointer invocation_hint, gpointer marshal_data) {
	typedef void (*GMarshalFunc_VOID__STRING_INT) (gpointer data1, const char* arg_1, gint arg_2, gpointer data2);
	register GMarshalFunc_VOID__STRING_INT callback;
	register GCClosure * cc;
	register gpointer data1;
	register gpointer data2;
	cc = (GCClosure *) closure;
	g_return_if_fail (n_param_values == 3);
	if (G_CCLOSURE_SWAP_DATA (closure)) {
		data1 = closure->data;
		data2 = param_values->data[0].v_pointer;
	} else {
		data1 = param_values->data[0].v_pointer;
		data2 = closure->data;
	}
	callback = (GMarshalFunc_VOID__STRING_INT) (marshal_data ? marshal_data : cc->callback);
	callback (data1, g_value_get_string (param_values + 1), g_value_get_int (param_values + 2), data2);
}


static void value_unity_greeter_init (GValue* value) {
	value->data[0].v_pointer = NULL;
}


static void value_unity_greeter_free_value (GValue* value) {
	if (value->data[0].v_pointer) {
		unity_greeter_unref (value->data[0].v_pointer);
	}
}


static void value_unity_greeter_copy_value (const GValue* src_value, GValue* dest_value) {
	if (src_value->data[0].v_pointer) {
		dest_value->data[0].v_pointer = unity_greeter_ref (src_value->data[0].v_pointer);
	} else {
		dest_value->data[0].v_pointer = NULL;
	}
}


static gpointer value_unity_greeter_peek_pointer (const GValue* value) {
	return value->data[0].v_pointer;
}


static gchar* value_unity_greeter_collect_value (GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	if (collect_values[0].v_pointer) {
		UnityGreeter* object;
		object = collect_values[0].v_pointer;
		if (object->parent_instance.g_class == NULL) {
			return g_strconcat ("invalid unclassed object pointer for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		} else if (!g_value_type_compatible (G_TYPE_FROM_INSTANCE (object), G_VALUE_TYPE (value))) {
			return g_strconcat ("invalid object type `", g_type_name (G_TYPE_FROM_INSTANCE (object)), "' for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		}
		value->data[0].v_pointer = unity_greeter_ref (object);
	} else {
		value->data[0].v_pointer = NULL;
	}
	return NULL;
}


static gchar* value_unity_greeter_lcopy_value (const GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	UnityGreeter** object_p;
	object_p = collect_values[0].v_pointer;
	if (!object_p) {
		return g_strdup_printf ("value location for `%s' passed as NULL", G_VALUE_TYPE_NAME (value));
	}
	if (!value->data[0].v_pointer) {
		*object_p = NULL;
	} else if (collect_flags & G_VALUE_NOCOPY_CONTENTS) {
		*object_p = value->data[0].v_pointer;
	} else {
		*object_p = unity_greeter_ref (value->data[0].v_pointer);
	}
	return NULL;
}


GParamSpec* param_spec_unity_greeter (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags) {
	ParamSpecUnityGreeter* spec;
	g_return_val_if_fail (g_type_is_a (object_type, TYPE_UNITY_GREETER), NULL);
	spec = g_param_spec_internal (G_TYPE_PARAM_OBJECT, name, nick, blurb, flags);
	G_PARAM_SPEC (spec)->value_type = object_type;
	return G_PARAM_SPEC (spec);
}


gpointer value_get_unity_greeter (const GValue* value) {
	g_return_val_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_UNITY_GREETER), NULL);
	return value->data[0].v_pointer;
}


void value_set_unity_greeter (GValue* value, gpointer v_object) {
	UnityGreeter* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_UNITY_GREETER));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, TYPE_UNITY_GREETER));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
		unity_greeter_ref (value->data[0].v_pointer);
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		unity_greeter_unref (old);
	}
}


void value_take_unity_greeter (GValue* value, gpointer v_object) {
	UnityGreeter* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_UNITY_GREETER));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, TYPE_UNITY_GREETER));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		unity_greeter_unref (old);
	}
}


static void unity_greeter_class_init (UnityGreeterClass * klass) {
	unity_greeter_parent_class = g_type_class_peek_parent (klass);
	UNITY_GREETER_CLASS (klass)->finalize = unity_greeter_finalize;
	g_type_class_add_private (klass, sizeof (UnityGreeterPrivate));
	g_signal_new ("show_message", TYPE_UNITY_GREETER, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_user_marshal_VOID__STRING_INT, G_TYPE_NONE, 2, G_TYPE_STRING, G_TYPE_INT);
	g_signal_new ("show_prompt", TYPE_UNITY_GREETER, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_user_marshal_VOID__STRING_INT, G_TYPE_NONE, 2, G_TYPE_STRING, G_TYPE_INT);
	g_signal_new ("authentication_complete", TYPE_UNITY_GREETER, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_marshal_VOID__VOID, G_TYPE_NONE, 0);
	g_signal_new ("starting_session", TYPE_UNITY_GREETER, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_marshal_VOID__VOID, G_TYPE_NONE, 0);
}


static void unity_greeter_instance_init (UnityGreeter * self) {
	self->priv = UNITY_GREETER_GET_PRIVATE (self);
	self->test_mode = FALSE;
	self->ref_count = 1;
}


static void unity_greeter_finalize (UnityGreeter* obj) {
	UnityGreeter * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, TYPE_UNITY_GREETER, UnityGreeter);
	_g_free0 (self->priv->state_file);
	_g_key_file_unref0 (self->priv->state);
	_cairo_surface_destroy0 (self->priv->background_surface);
	_g_object_unref0 (self->priv->settings_daemon);
	_g_object_unref0 (self->priv->main_window);
	_g_object_unref0 (self->priv->greeter);
	_ca_context_destroy0 (self->priv->canberra_context);
	_g_object_unref0 (self->priv->dbus_object);
}


GType unity_greeter_get_type (void) {
	static volatile gsize unity_greeter_type_id__volatile = 0;
	if (g_once_init_enter (&unity_greeter_type_id__volatile)) {
		static const GTypeValueTable g_define_type_value_table = { value_unity_greeter_init, value_unity_greeter_free_value, value_unity_greeter_copy_value, value_unity_greeter_peek_pointer, "p", value_unity_greeter_collect_value, "p", value_unity_greeter_lcopy_value };
		static const GTypeInfo g_define_type_info = { sizeof (UnityGreeterClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) unity_greeter_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (UnityGreeter), 0, (GInstanceInitFunc) unity_greeter_instance_init, &g_define_type_value_table };
		static const GTypeFundamentalInfo g_define_type_fundamental_info = { (G_TYPE_FLAG_CLASSED | G_TYPE_FLAG_INSTANTIATABLE | G_TYPE_FLAG_DERIVABLE | G_TYPE_FLAG_DEEP_DERIVABLE) };
		GType unity_greeter_type_id;
		unity_greeter_type_id = g_type_register_fundamental (g_type_fundamental_next (), "UnityGreeter", &g_define_type_info, &g_define_type_fundamental_info, 0);
		g_once_init_leave (&unity_greeter_type_id__volatile, unity_greeter_type_id);
	}
	return unity_greeter_type_id__volatile;
}


gpointer unity_greeter_ref (gpointer instance) {
	UnityGreeter* self;
	self = instance;
	g_atomic_int_inc (&self->ref_count);
	return instance;
}


void unity_greeter_unref (gpointer instance) {
	UnityGreeter* self;
	self = instance;
	if (g_atomic_int_dec_and_test (&self->ref_count)) {
		UNITY_GREETER_GET_CLASS (self)->finalize (self);
		g_type_free_instance ((GTypeInstance *) self);
	}
}


void dialog_dbus_interface_open (DialogDBusInterface* self, guint32 type, guint32 timestamp, guint32 seconds_to_stay_open, char** inhibitor_object_paths, int inhibitor_object_paths_length1) {
	guint32 _tmp0_ = 0U;
	g_return_if_fail (self != NULL);
	_tmp0_ = type;
	g_signal_emit_by_name (self, "open-dialog", _tmp0_);
}


void dialog_dbus_interface_close (DialogDBusInterface* self) {
	g_return_if_fail (self != NULL);
	g_signal_emit_by_name (self, "close-dialog");
}


DialogDBusInterface* dialog_dbus_interface_construct (GType object_type) {
	DialogDBusInterface * self = NULL;
	self = (DialogDBusInterface*) g_object_new (object_type, NULL);
	return self;
}


DialogDBusInterface* dialog_dbus_interface_new (void) {
	return dialog_dbus_interface_construct (TYPE_DIALOG_DBUS_INTERFACE);
}


static void dialog_dbus_interface_class_init (DialogDBusInterfaceClass * klass) {
	dialog_dbus_interface_parent_class = g_type_class_peek_parent (klass);
	g_signal_new ("open_dialog", TYPE_DIALOG_DBUS_INTERFACE, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_marshal_VOID__UINT, G_TYPE_NONE, 1, G_TYPE_UINT);
	g_signal_new ("close_dialog", TYPE_DIALOG_DBUS_INTERFACE, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_marshal_VOID__VOID, G_TYPE_NONE, 0);
}


static void dialog_dbus_interface_instance_init (DialogDBusInterface * self) {
}


GType dialog_dbus_interface_get_type (void) {
	static volatile gsize dialog_dbus_interface_type_id__volatile = 0;
	if (g_once_init_enter (&dialog_dbus_interface_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (DialogDBusInterfaceClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) dialog_dbus_interface_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (DialogDBusInterface), 0, (GInstanceInitFunc) dialog_dbus_interface_instance_init, NULL };
		GType dialog_dbus_interface_type_id;
		dialog_dbus_interface_type_id = g_type_register_static (G_TYPE_OBJECT, "DialogDBusInterface", &g_define_type_info, 0);
		g_type_set_qdata (dialog_dbus_interface_type_id, g_quark_from_static_string ("vala-dbus-register-object"), (void*) dialog_dbus_interface_register_object);
		g_once_init_leave (&dialog_dbus_interface_type_id__volatile, dialog_dbus_interface_type_id);
	}
	return dialog_dbus_interface_type_id__volatile;
}


static void _dbus_dialog_dbus_interface_open (DialogDBusInterface* self, GVariant* parameters, GDBusMethodInvocation* invocation) {
	GError* error = NULL;
	GVariantIter _arguments_iter;
	guint32 type = 0U;
	GVariant* _tmp218_;
	guint32 timestamp = 0U;
	GVariant* _tmp219_;
	guint32 seconds_to_stay_open = 0U;
	GVariant* _tmp220_;
	char** inhibitor_object_paths = NULL;
	int inhibitor_object_paths_length1 = 0;
	GVariant* _tmp221_;
	char** _tmp222_;
	int _tmp222__length;
	int _tmp222__size;
	int _tmp222__length1;
	GVariantIter _tmp223_;
	GVariant* _tmp224_;
	GDBusMessage* _reply_message;
	GVariant* _reply;
	GVariantBuilder _reply_builder;
	g_variant_iter_init (&_arguments_iter, parameters);
	_tmp218_ = g_variant_iter_next_value (&_arguments_iter);
	type = g_variant_get_uint32 (_tmp218_);
	g_variant_unref (_tmp218_);
	_tmp219_ = g_variant_iter_next_value (&_arguments_iter);
	timestamp = g_variant_get_uint32 (_tmp219_);
	g_variant_unref (_tmp219_);
	_tmp220_ = g_variant_iter_next_value (&_arguments_iter);
	seconds_to_stay_open = g_variant_get_uint32 (_tmp220_);
	g_variant_unref (_tmp220_);
	_tmp221_ = g_variant_iter_next_value (&_arguments_iter);
	_tmp222_ = g_new (char*, 5);
	_tmp222__length = 0;
	_tmp222__size = 4;
	_tmp222__length1 = 0;
	g_variant_iter_init (&_tmp223_, _tmp221_);
	for (; (_tmp224_ = g_variant_iter_next_value (&_tmp223_)) != NULL; _tmp222__length1++) {
		if (_tmp222__size == _tmp222__length) {
			_tmp222__size = 2 * _tmp222__size;
			_tmp222_ = g_renew (char*, _tmp222_, _tmp222__size + 1);
		}
		_tmp222_[_tmp222__length++] = g_variant_dup_string (_tmp224_, NULL);
		g_variant_unref (_tmp224_);
	}
	inhibitor_object_paths_length1 = _tmp222__length1;
	_tmp222_[_tmp222__length] = NULL;
	inhibitor_object_paths = _tmp222_;
	g_variant_unref (_tmp221_);
	dialog_dbus_interface_open (self, type, timestamp, seconds_to_stay_open, inhibitor_object_paths, inhibitor_object_paths_length1);
	_reply_message = g_dbus_message_new_method_reply (g_dbus_method_invocation_get_message (invocation));
	g_variant_builder_init (&_reply_builder, G_VARIANT_TYPE_TUPLE);
	_reply = g_variant_builder_end (&_reply_builder);
	g_dbus_message_set_body (_reply_message, _reply);
	inhibitor_object_paths = (_vala_array_free (inhibitor_object_paths, inhibitor_object_paths_length1, (GDestroyNotify) g_free), NULL);
	g_dbus_connection_send_message (g_dbus_method_invocation_get_connection (invocation), _reply_message, G_DBUS_SEND_MESSAGE_FLAGS_NONE, NULL, NULL);
	g_object_unref (invocation);
	g_object_unref (_reply_message);
}


static void _dbus_dialog_dbus_interface_close (DialogDBusInterface* self, GVariant* parameters, GDBusMethodInvocation* invocation) {
	GError* error = NULL;
	GVariantIter _arguments_iter;
	GDBusMessage* _reply_message;
	GVariant* _reply;
	GVariantBuilder _reply_builder;
	g_variant_iter_init (&_arguments_iter, parameters);
	dialog_dbus_interface_close (self);
	_reply_message = g_dbus_message_new_method_reply (g_dbus_method_invocation_get_message (invocation));
	g_variant_builder_init (&_reply_builder, G_VARIANT_TYPE_TUPLE);
	_reply = g_variant_builder_end (&_reply_builder);
	g_dbus_message_set_body (_reply_message, _reply);
	g_dbus_connection_send_message (g_dbus_method_invocation_get_connection (invocation), _reply_message, G_DBUS_SEND_MESSAGE_FLAGS_NONE, NULL, NULL);
	g_object_unref (invocation);
	g_object_unref (_reply_message);
}


static void dialog_dbus_interface_dbus_interface_method_call (GDBusConnection* connection, const gchar* sender, const gchar* object_path, const gchar* interface_name, const gchar* method_name, GVariant* parameters, GDBusMethodInvocation* invocation, gpointer user_data) {
	gpointer* data;
	gpointer object;
	data = user_data;
	object = data[0];
	if (strcmp (method_name, "Open") == 0) {
		_dbus_dialog_dbus_interface_open (object, parameters, invocation);
	} else if (strcmp (method_name, "Close") == 0) {
		_dbus_dialog_dbus_interface_close (object, parameters, invocation);
	} else {
		g_object_unref (invocation);
	}
}


static GVariant* dialog_dbus_interface_dbus_interface_get_property (GDBusConnection* connection, const gchar* sender, const gchar* object_path, const gchar* interface_name, const gchar* property_name, GError** error, gpointer user_data) {
	gpointer* data;
	gpointer object;
	data = user_data;
	object = data[0];
	return NULL;
}


static gboolean dialog_dbus_interface_dbus_interface_set_property (GDBusConnection* connection, const gchar* sender, const gchar* object_path, const gchar* interface_name, const gchar* property_name, GVariant* value, GError** error, gpointer user_data) {
	gpointer* data;
	gpointer object;
	data = user_data;
	object = data[0];
	return FALSE;
}


static void _dbus_dialog_dbus_interface_open_dialog (GObject* _sender, guint32 type, gpointer* _data) {
	GDBusConnection * _connection;
	const gchar * _path;
	GVariant *_arguments;
	GVariantBuilder _arguments_builder;
	_connection = _data[1];
	_path = _data[2];
	g_variant_builder_init (&_arguments_builder, G_VARIANT_TYPE_TUPLE);
	g_variant_builder_add_value (&_arguments_builder, g_variant_new_uint32 (type));
	_arguments = g_variant_builder_end (&_arguments_builder);
	g_dbus_connection_emit_signal (_connection, NULL, _path, "org.gnome.SessionManager.EndSessionDialog", "OpenDialog", _arguments, NULL);
}


static void _dbus_dialog_dbus_interface_close_dialog (GObject* _sender, gpointer* _data) {
	GDBusConnection * _connection;
	const gchar * _path;
	GVariant *_arguments;
	GVariantBuilder _arguments_builder;
	_connection = _data[1];
	_path = _data[2];
	g_variant_builder_init (&_arguments_builder, G_VARIANT_TYPE_TUPLE);
	_arguments = g_variant_builder_end (&_arguments_builder);
	g_dbus_connection_emit_signal (_connection, NULL, _path, "org.gnome.SessionManager.EndSessionDialog", "CloseDialog", _arguments, NULL);
}


guint dialog_dbus_interface_register_object (gpointer object, GDBusConnection* connection, const gchar* path, GError** error) {
	guint result;
	gpointer *data;
	data = g_new (gpointer, 3);
	data[0] = g_object_ref (object);
	data[1] = g_object_ref (connection);
	data[2] = g_strdup (path);
	result = g_dbus_connection_register_object (connection, path, (GDBusInterfaceInfo *) (&_dialog_dbus_interface_dbus_interface_info), &_dialog_dbus_interface_dbus_interface_vtable, data, _dialog_dbus_interface_unregister_object, error);
	if (!result) {
		return 0;
	}
	g_signal_connect (object, "open-dialog", (GCallback) _dbus_dialog_dbus_interface_open_dialog, data);
	g_signal_connect (object, "close-dialog", (GCallback) _dbus_dialog_dbus_interface_close_dialog, data);
	return result;
}


static void _dialog_dbus_interface_unregister_object (gpointer user_data) {
	gpointer* data;
	data = user_data;
	g_signal_handlers_disconnect_by_func (data[0], _dbus_dialog_dbus_interface_open_dialog, data);
	g_signal_handlers_disconnect_by_func (data[0], _dbus_dialog_dbus_interface_close_dialog, data);
	g_object_unref (data[0]);
	g_object_unref (data[1]);
	g_free (data[2]);
	g_free (data);
}


static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	if ((array != NULL) && (destroy_func != NULL)) {
		int i;
		for (i = 0; i < array_length; i = i + 1) {
			if (((gpointer*) array)[i] != NULL) {
				destroy_func (((gpointer*) array)[i]);
			}
		}
	}
}


static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	_vala_array_destroy (array, array_length, destroy_func);
	g_free (array);
}



