/* flat-button.c generated by valac 0.22.1, the Vala compiler
 * generated from flat-button.vala, do not modify */

/* -*- Mode: Vala; indent-tabs-mode: nil; tab-width: 4 -*-
 *
 * Copyright (C) 2012 Canonical Ltd
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 3 as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Authors: Michael Terry <michael.terry@canonical.com>
 */

#include <glib.h>
#include <glib-object.h>
#include <gtk/gtk.h>
#include <cairo.h>


#define TYPE_FLAT_BUTTON (flat_button_get_type ())
#define FLAT_BUTTON(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_FLAT_BUTTON, FlatButton))
#define FLAT_BUTTON_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_FLAT_BUTTON, FlatButtonClass))
#define IS_FLAT_BUTTON(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_FLAT_BUTTON))
#define IS_FLAT_BUTTON_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_FLAT_BUTTON))
#define FLAT_BUTTON_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_FLAT_BUTTON, FlatButtonClass))

typedef struct _FlatButton FlatButton;
typedef struct _FlatButtonClass FlatButtonClass;
typedef struct _FlatButtonPrivate FlatButtonPrivate;
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))

struct _FlatButton {
	GtkButton parent_instance;
	FlatButtonPrivate * priv;
};

struct _FlatButtonClass {
	GtkButtonClass parent_class;
};

struct _FlatButtonPrivate {
	gboolean did_press;
};


static gpointer flat_button_parent_class = NULL;

GType flat_button_get_type (void) G_GNUC_CONST;
#define FLAT_BUTTON_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), TYPE_FLAT_BUTTON, FlatButtonPrivate))
enum  {
	FLAT_BUTTON_DUMMY_PROPERTY
};
static gboolean flat_button_real_draw (GtkWidget* base, cairo_t* c);
static void flat_button_real_pressed (GtkButton* base);
static void flat_button_real_released (GtkButton* base);
FlatButton* flat_button_new (void);
FlatButton* flat_button_construct (GType object_type);
static GObject * flat_button_constructor (GType type, guint n_construct_properties, GObjectConstructParam * construct_properties);
void unity_greeter_add_style_class (GtkWidget* widget);
static void flat_button_finalize (GObject* obj);


static gboolean flat_button_real_draw (GtkWidget* base, cairo_t* c) {
	FlatButton * self;
	gboolean result = FALSE;
	cairo_t* _tmp0_ = NULL;
	gboolean _tmp1_ = FALSE;
	self = (FlatButton*) base;
	g_return_val_if_fail (c != NULL, FALSE);
	gtk_widget_unset_state_flags ((GtkWidget*) self, GTK_STATE_FLAG_PRELIGHT);
	_tmp0_ = c;
	_tmp1_ = GTK_WIDGET_CLASS (flat_button_parent_class)->draw ((GtkWidget*) G_TYPE_CHECK_INSTANCE_CAST (self, GTK_TYPE_BUTTON, GtkButton), _tmp0_);
	result = _tmp1_;
	return result;
}


static void flat_button_real_pressed (GtkButton* base) {
	FlatButton * self;
	self = (FlatButton*) base;
	self->priv->did_press = TRUE;
}


static void flat_button_real_released (GtkButton* base) {
	FlatButton * self;
	gboolean _tmp0_ = FALSE;
	self = (FlatButton*) base;
	_tmp0_ = self->priv->did_press;
	if (_tmp0_) {
		GTK_BUTTON_CLASS (flat_button_parent_class)->pressed (G_TYPE_CHECK_INSTANCE_CAST (self, GTK_TYPE_BUTTON, GtkButton));
		self->priv->did_press = FALSE;
	}
	GTK_BUTTON_CLASS (flat_button_parent_class)->released (G_TYPE_CHECK_INSTANCE_CAST (self, GTK_TYPE_BUTTON, GtkButton));
}


FlatButton* flat_button_construct (GType object_type) {
	FlatButton * self = NULL;
	self = (FlatButton*) g_object_new (object_type, NULL);
	return self;
}


FlatButton* flat_button_new (void) {
	return flat_button_construct (TYPE_FLAT_BUTTON);
}


static GObject * flat_button_constructor (GType type, guint n_construct_properties, GObjectConstructParam * construct_properties) {
	GObject * obj;
	GObjectClass * parent_class;
	FlatButton * self;
	GError * _inner_error_ = NULL;
	parent_class = G_OBJECT_CLASS (flat_button_parent_class);
	obj = parent_class->constructor (type, n_construct_properties, construct_properties);
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, TYPE_FLAT_BUTTON, FlatButton);
	unity_greeter_add_style_class ((GtkWidget*) self);
	{
		GtkCssProvider* style = NULL;
		GtkCssProvider* _tmp0_ = NULL;
		GtkCssProvider* _tmp1_ = NULL;
		GtkStyleContext* _tmp2_ = NULL;
		GtkCssProvider* _tmp3_ = NULL;
		_tmp0_ = gtk_css_provider_new ();
		style = _tmp0_;
		_tmp1_ = style;
		gtk_css_provider_load_from_data (_tmp1_, "* {-GtkButton-child-displacement-x: 0px;\n" \
"                                      -GtkButton-child-displacement-y:" \
" 0px;\n" \
"                                      -GtkWidget-focus-line-width: 1px" \
";\n" \
"                                      }", (gssize) (-1), &_inner_error_);
		if (_inner_error_ != NULL) {
			_g_object_unref0 (style);
			goto __catch8_g_error;
		}
		_tmp2_ = gtk_widget_get_style_context ((GtkWidget*) self);
		_tmp3_ = style;
		gtk_style_context_add_provider (_tmp2_, (GtkStyleProvider*) _tmp3_, (guint) GTK_STYLE_PROVIDER_PRIORITY_APPLICATION);
		_g_object_unref0 (style);
	}
	goto __finally8;
	__catch8_g_error:
	{
		GError* e = NULL;
		GError* _tmp4_ = NULL;
		const gchar* _tmp5_ = NULL;
		e = _inner_error_;
		_inner_error_ = NULL;
		_tmp4_ = e;
		_tmp5_ = _tmp4_->message;
		g_debug ("flat-button.vala:38: Internal error loading session chooser style: %s", _tmp5_);
		_g_error_free0 (e);
	}
	__finally8:
	if (_inner_error_ != NULL) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
	}
	return obj;
}


static void flat_button_class_init (FlatButtonClass * klass) {
	flat_button_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (FlatButtonPrivate));
	GTK_WIDGET_CLASS (klass)->draw = flat_button_real_draw;
	GTK_BUTTON_CLASS (klass)->pressed = flat_button_real_pressed;
	GTK_BUTTON_CLASS (klass)->released = flat_button_real_released;
	G_OBJECT_CLASS (klass)->constructor = flat_button_constructor;
	G_OBJECT_CLASS (klass)->finalize = flat_button_finalize;
}


static void flat_button_instance_init (FlatButton * self) {
	self->priv = FLAT_BUTTON_GET_PRIVATE (self);
}


static void flat_button_finalize (GObject* obj) {
	FlatButton * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, TYPE_FLAT_BUTTON, FlatButton);
	G_OBJECT_CLASS (flat_button_parent_class)->finalize (obj);
}


GType flat_button_get_type (void) {
	static volatile gsize flat_button_type_id__volatile = 0;
	if (g_once_init_enter (&flat_button_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (FlatButtonClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) flat_button_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (FlatButton), 0, (GInstanceInitFunc) flat_button_instance_init, NULL };
		GType flat_button_type_id;
		flat_button_type_id = g_type_register_static (GTK_TYPE_BUTTON, "FlatButton", &g_define_type_info, 0);
		g_once_init_leave (&flat_button_type_id__volatile, flat_button_type_id);
	}
	return flat_button_type_id__volatile;
}



