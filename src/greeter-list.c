/* greeter-list.c generated by valac 0.22.1, the Vala compiler
 * generated from greeter-list.vala, do not modify */

/* -*- Mode: Vala; indent-tabs-mode: nil; tab-width: 4 -*-
 *
 * Copyright (C) 2012 Canonical Ltd
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 3 as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Authors: Robert Ancell <robert.ancell@canonical.com>
 *          Michael Terry <michael.terry@canonical.com>
 *          Scott Sweeny <scott.sweeny@canonical.com>
 */

#include <glib.h>
#include <glib-object.h>
#include <gio/gio.h>
#include <gtk/gtk.h>
#include <stdlib.h>
#include <string.h>
#include <cairo.h>
#include <float.h>
#include <math.h>
#include <lightdm.h>
#include <glib/gi18n-lib.h>
#include <gdk-pixbuf/gdk-pixbuf.h>


#define TYPE_LIST_DBUS_INTERFACE (list_dbus_interface_get_type ())
#define LIST_DBUS_INTERFACE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_LIST_DBUS_INTERFACE, ListDBusInterface))
#define LIST_DBUS_INTERFACE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_LIST_DBUS_INTERFACE, ListDBusInterfaceClass))
#define IS_LIST_DBUS_INTERFACE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_LIST_DBUS_INTERFACE))
#define IS_LIST_DBUS_INTERFACE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_LIST_DBUS_INTERFACE))
#define LIST_DBUS_INTERFACE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_LIST_DBUS_INTERFACE, ListDBusInterfaceClass))

typedef struct _ListDBusInterface ListDBusInterface;
typedef struct _ListDBusInterfaceClass ListDBusInterfaceClass;
typedef struct _ListDBusInterfacePrivate ListDBusInterfacePrivate;

#define TYPE_FADABLE_BOX (fadable_box_get_type ())
#define FADABLE_BOX(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_FADABLE_BOX, FadableBox))
#define FADABLE_BOX_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_FADABLE_BOX, FadableBoxClass))
#define IS_FADABLE_BOX(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_FADABLE_BOX))
#define IS_FADABLE_BOX_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_FADABLE_BOX))
#define FADABLE_BOX_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_FADABLE_BOX, FadableBoxClass))

typedef struct _FadableBox FadableBox;
typedef struct _FadableBoxClass FadableBoxClass;

#define TYPE_GREETER_LIST (greeter_list_get_type ())
#define GREETER_LIST(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_GREETER_LIST, GreeterList))
#define GREETER_LIST_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_GREETER_LIST, GreeterListClass))
#define IS_GREETER_LIST(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_GREETER_LIST))
#define IS_GREETER_LIST_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_GREETER_LIST))
#define GREETER_LIST_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_GREETER_LIST, GreeterListClass))

typedef struct _GreeterList GreeterList;
typedef struct _GreeterListClass GreeterListClass;
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))

#define TYPE_PROMPT_BOX (prompt_box_get_type ())
#define PROMPT_BOX(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_PROMPT_BOX, PromptBox))
#define PROMPT_BOX_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_PROMPT_BOX, PromptBoxClass))
#define IS_PROMPT_BOX(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_PROMPT_BOX))
#define IS_PROMPT_BOX_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_PROMPT_BOX))
#define PROMPT_BOX_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_PROMPT_BOX, PromptBoxClass))

typedef struct _PromptBox PromptBox;
typedef struct _PromptBoxClass PromptBoxClass;
#define _g_free0(var) (var = (g_free (var), NULL))

#define TYPE_FADABLE (fadable_get_type ())
#define FADABLE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_FADABLE, Fadable))
#define IS_FADABLE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_FADABLE))
#define FADABLE_GET_INTERFACE(obj) (G_TYPE_INSTANCE_GET_INTERFACE ((obj), TYPE_FADABLE, FadableIface))

typedef struct _Fadable Fadable;
typedef struct _FadableIface FadableIface;

#define TYPE_FADE_TRACKER (fade_tracker_get_type ())
#define FADE_TRACKER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_FADE_TRACKER, FadeTracker))
#define FADE_TRACKER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_FADE_TRACKER, FadeTrackerClass))
#define IS_FADE_TRACKER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_FADE_TRACKER))
#define IS_FADE_TRACKER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_FADE_TRACKER))
#define FADE_TRACKER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_FADE_TRACKER, FadeTrackerClass))

typedef struct _FadeTracker FadeTracker;
typedef struct _FadeTrackerClass FadeTrackerClass;
typedef struct _FadableBoxPrivate FadableBoxPrivate;
typedef struct _GreeterListPrivate GreeterListPrivate;

#define TYPE_DASH_BOX (dash_box_get_type ())
#define DASH_BOX(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_DASH_BOX, DashBox))
#define DASH_BOX_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_DASH_BOX, DashBoxClass))
#define IS_DASH_BOX(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_DASH_BOX))
#define IS_DASH_BOX_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_DASH_BOX))
#define DASH_BOX_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_DASH_BOX, DashBoxClass))

typedef struct _DashBox DashBox;
typedef struct _DashBoxClass DashBoxClass;

#define GREETER_LIST_TYPE_MODE (greeter_list_mode_get_type ())

#define TYPE_BACKGROUND (background_get_type ())
#define BACKGROUND(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_BACKGROUND, Background))
#define BACKGROUND_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_BACKGROUND, BackgroundClass))
#define IS_BACKGROUND(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_BACKGROUND))
#define IS_BACKGROUND_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_BACKGROUND))
#define BACKGROUND_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_BACKGROUND, BackgroundClass))

typedef struct _Background Background;
typedef struct _BackgroundClass BackgroundClass;

#define TYPE_ANIMATE_TIMER (animate_timer_get_type ())
#define ANIMATE_TIMER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_ANIMATE_TIMER, AnimateTimer))
#define ANIMATE_TIMER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_ANIMATE_TIMER, AnimateTimerClass))
#define IS_ANIMATE_TIMER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_ANIMATE_TIMER))
#define IS_ANIMATE_TIMER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_ANIMATE_TIMER))
#define ANIMATE_TIMER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_ANIMATE_TIMER, AnimateTimerClass))

typedef struct _AnimateTimer AnimateTimer;
typedef struct _AnimateTimerClass AnimateTimerClass;

#define GREETER_LIST_TYPE_SCROLL_TARGET (greeter_list_scroll_target_get_type ())
#define __g_list_free__g_object_unref0_0(var) ((var == NULL) ? NULL : (var = (_g_list_free__g_object_unref0_ (var), NULL)))
#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))

#define TYPE_UNITY_GREETER (unity_greeter_get_type ())
#define UNITY_GREETER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_UNITY_GREETER, UnityGreeter))
#define UNITY_GREETER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_UNITY_GREETER, UnityGreeterClass))
#define IS_UNITY_GREETER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_UNITY_GREETER))
#define IS_UNITY_GREETER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_UNITY_GREETER))
#define UNITY_GREETER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_UNITY_GREETER, UnityGreeterClass))

typedef struct _UnityGreeter UnityGreeter;
typedef struct _UnityGreeterClass UnityGreeterClass;

#define TYPE_DASH_ENTRY (dash_entry_get_type ())
#define DASH_ENTRY(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_DASH_ENTRY, DashEntry))
#define DASH_ENTRY_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_DASH_ENTRY, DashEntryClass))
#define IS_DASH_ENTRY(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_DASH_ENTRY))
#define IS_DASH_ENTRY_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_DASH_ENTRY))
#define DASH_ENTRY_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_DASH_ENTRY, DashEntryClass))

typedef struct _DashEntry DashEntry;
typedef struct _DashEntryClass DashEntryClass;
#define _g_list_free0(var) ((var == NULL) ? NULL : (var = (g_list_free (var), NULL)))
typedef struct _UnityGreeterPrivate UnityGreeterPrivate;

struct _ListDBusInterface {
	GObject parent_instance;
	ListDBusInterfacePrivate * priv;
};

struct _ListDBusInterfaceClass {
	GObjectClass parent_class;
};

struct _ListDBusInterfacePrivate {
	GreeterList* list;
};

struct _FadableIface {
	GTypeInterface parent_iface;
	FadeTracker* (*get_fade_tracker) (Fadable* self);
	void (*set_fade_tracker) (Fadable* self, FadeTracker* value);
};

struct _FadableBox {
	GtkEventBox parent_instance;
	FadableBoxPrivate * priv;
};

struct _FadableBoxClass {
	GtkEventBoxClass parent_class;
	void (*draw_full_alpha) (FadableBox* self, cairo_t* c);
};

typedef enum  {
	GREETER_LIST_MODE_ENTRY,
	GREETER_LIST_MODE_SCROLLING
} GreeterListMode;

struct _GreeterList {
	FadableBox parent_instance;
	GreeterListPrivate * priv;
	gchar* greeter_authenticating_user;
	gboolean _always_show_manual;
	GList* entries;
	DashBox* greeter_box;
	GreeterListMode mode;
	gboolean will_clear;
	gboolean prompted;
	gboolean unacknowledged_messages;
	gchar* test_username;
	gboolean test_is_authenticated;
};

struct _GreeterListClass {
	FadableBoxClass parent_class;
	gchar* (*get_selected_id) (GreeterList* self);
	void (*focus_prompt) (GreeterList* self);
	void (*show_authenticated) (GreeterList* self, gboolean successful);
	void (*insert_entry) (GreeterList* self, PromptBox* entry);
	void (*add_manual_entry) (GreeterList* self);
	gint (*get_position_y) (GreeterList* self, gdouble position);
	void (*setup_prompt_box) (GreeterList* self, gboolean fade);
	void (*show_prompt_cb) (GreeterList* self, const gchar* text, LightDMPromptType type);
	void (*authentication_complete_cb) (GreeterList* self);
	void (*start_authentication) (GreeterList* self);
	gchar* (*get_lightdm_session) (GreeterList* self);
	void (*test_start_authentication) (GreeterList* self);
};

struct _GreeterListPrivate {
	Background* _background;
	PromptBox* _selected_entry;
	gboolean _start_scrolling;
	ListDBusInterface* dbus_object;
	gdouble scroll_target_location;
	gdouble scroll_start_location;
	gdouble scroll_location;
	gdouble scroll_direction;
	AnimateTimer* scroll_timer;
	GtkFixed* fixed;
	gint cached_box_height;
	guint n_above;
	guint n_below;
	gchar* _manual_name;
	PromptBox* _scrolling_entry;
};

typedef enum  {
	GREETER_LIST_SCROLL_TARGET_START,
	GREETER_LIST_SCROLL_TARGET_END,
	GREETER_LIST_SCROLL_TARGET_UP,
	GREETER_LIST_SCROLL_TARGET_DOWN
} GreeterListScrollTarget;

struct _UnityGreeter {
	GTypeInstance parent_instance;
	volatile int ref_count;
	UnityGreeterPrivate * priv;
	gboolean test_mode;
	gboolean orca_needs_kick;
};

struct _UnityGreeterClass {
	GTypeClass parent_class;
	void (*finalize) (UnityGreeter *self);
};

typedef gdouble (*AnimateTimerEasingFunc) (gdouble x, void* user_data);

static gpointer list_dbus_interface_parent_class = NULL;
static gpointer greeter_list_parent_class = NULL;
extern UnityGreeter* unity_greeter_singleton;

gint get_grid_offset (gint size);
#define grid_size 40
GType list_dbus_interface_get_type (void) G_GNUC_CONST;
guint list_dbus_interface_register_object (void* object, GDBusConnection* connection, const gchar* path, GError** error);
GType fadable_box_get_type (void) G_GNUC_CONST;
GType greeter_list_get_type (void) G_GNUC_CONST;
#define LIST_DBUS_INTERFACE_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), TYPE_LIST_DBUS_INTERFACE, ListDBusInterfacePrivate))
enum  {
	LIST_DBUS_INTERFACE_DUMMY_PROPERTY
};
ListDBusInterface* list_dbus_interface_new (GreeterList* list);
ListDBusInterface* list_dbus_interface_construct (GType object_type, GreeterList* list);
static void __lambda58_ (ListDBusInterface* self, const gchar* name);
static void ___lambda58__greeter_list_entry_selected (GreeterList* _sender, const gchar* name, gpointer self);
gchar* list_dbus_interface_get_active_entry (ListDBusInterface* self);
GType prompt_box_get_type (void) G_GNUC_CONST;
PromptBox* greeter_list_get_selected_entry (GreeterList* self);
const gchar* prompt_box_get_id (PromptBox* self);
void list_dbus_interface_set_active_entry (ListDBusInterface* self, const gchar* entry_name);
void greeter_list_set_active_entry (GreeterList* self, const gchar* name);
static void list_dbus_interface_finalize (GObject* obj);
static void _dbus_list_dbus_interface_get_active_entry (ListDBusInterface* self, GVariant* parameters, GDBusMethodInvocation* invocation);
static void _dbus_list_dbus_interface_set_active_entry (ListDBusInterface* self, GVariant* parameters, GDBusMethodInvocation* invocation);
static void list_dbus_interface_dbus_interface_method_call (GDBusConnection* connection, const gchar* sender, const gchar* object_path, const gchar* interface_name, const gchar* method_name, GVariant* parameters, GDBusMethodInvocation* invocation, gpointer user_data);
static GVariant* list_dbus_interface_dbus_interface_get_property (GDBusConnection* connection, const gchar* sender, const gchar* object_path, const gchar* interface_name, const gchar* property_name, GError** error, gpointer user_data);
static gboolean list_dbus_interface_dbus_interface_set_property (GDBusConnection* connection, const gchar* sender, const gchar* object_path, const gchar* interface_name, const gchar* property_name, GVariant* value, GError** error, gpointer user_data);
static void _dbus_list_dbus_interface_entry_selected (GObject* _sender, const gchar* entry_name, gpointer* _data);
static void _list_dbus_interface_unregister_object (gpointer user_data);
GType fade_tracker_get_type (void) G_GNUC_CONST;
GType fadable_get_type (void) G_GNUC_CONST;
GType dash_box_get_type (void) G_GNUC_CONST;
GType greeter_list_mode_get_type (void) G_GNUC_CONST;
GType background_get_type (void) G_GNUC_CONST;
GType animate_timer_get_type (void) G_GNUC_CONST;
#define GREETER_LIST_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), TYPE_GREETER_LIST, GreeterListPrivate))
enum  {
	GREETER_LIST_DUMMY_PROPERTY,
	GREETER_LIST_BACKGROUND,
	GREETER_LIST_SELECTED_ENTRY,
	GREETER_LIST_START_SCROLLING,
	GREETER_LIST_ALWAYS_SHOW_MANUAL,
	GREETER_LIST_MANUAL_NAME
};
GType greeter_list_scroll_target_get_type (void) G_GNUC_CONST;
static void _g_object_unref0_ (gpointer var);
static void _g_list_free__g_object_unref0_ (GList* self);
#define GREETER_LIST_BORDER 4
#define GREETER_LIST_BOX_WIDTH 8
#define GREETER_LIST_DEFAULT_BOX_HEIGHT 3
gchar* greeter_list_get_selected_id (GreeterList* self);
static gchar* greeter_list_real_get_selected_id (GreeterList* self);
GreeterList* greeter_list_construct (GType object_type, Background* bg);
static void greeter_list_on_bus_acquired (GreeterList* self, GObject* obj, GAsyncResult* res);
static void greeter_list_real_get_preferred_width (GtkWidget* base, gint* min, gint* nat);
static void greeter_list_real_get_preferred_height (GtkWidget* base, gint* min, gint* nat);
void greeter_list_cancel_authentication (GreeterList* self);
gpointer unity_greeter_ref (gpointer instance);
void unity_greeter_unref (gpointer instance);
GParamSpec* param_spec_unity_greeter (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void value_set_unity_greeter (GValue* value, gpointer v_object);
void value_take_unity_greeter (GValue* value, gpointer v_object);
gpointer value_get_unity_greeter (const GValue* value);
GType unity_greeter_get_type (void) G_GNUC_CONST;
void unity_greeter_cancel_authentication (UnityGreeter* self);
void greeter_list_scroll (GreeterList* self, GreeterListScrollTarget target);
void greeter_list_select_entry (GreeterList* self, PromptBox* entry, gdouble direction, gboolean do_scroll);
void greeter_list_add_with_class (GreeterList* self, GtkWidget* widget);
void unity_greeter_add_style_class (GtkWidget* widget);
void greeter_list_redraw_greeter_box (GreeterList* self);
void greeter_list_show_message (GreeterList* self, const gchar* text, gboolean is_error);
void prompt_box_clear (PromptBox* self);
void prompt_box_add_message (PromptBox* self, const gchar* text, gboolean is_error);
GType dash_entry_get_type (void) G_GNUC_CONST;
DashEntry* greeter_list_add_prompt (GreeterList* self, const gchar* text, gboolean secret);
const gchar* prompt_box_get_label (PromptBox* self);
DashEntry* prompt_box_add_prompt (PromptBox* self, const gchar* text, const gchar* accessible_text, gboolean is_secret);
void prompt_box_show_prompts (PromptBox* self);
void greeter_list_focus_prompt (GreeterList* self);
GtkComboBox* greeter_list_add_combo (GreeterList* self, GPtrArray* texts, gboolean read_only);
GtkComboBox* prompt_box_add_combo (PromptBox* self, GPtrArray* texts, gboolean read_only);
static void greeter_list_real_grab_focus (GtkWidget* base);
static void greeter_list_real_focus_prompt (GreeterList* self);
void greeter_list_show_authenticated (GreeterList* self, gboolean successful);
static void greeter_list_real_show_authenticated (GreeterList* self, gboolean successful);
PromptBox* greeter_list_find_entry (GreeterList* self, const gchar* id);
gint greeter_list_compare_entry (PromptBox* a, PromptBox* b);
gboolean greeter_list_have_entries (GreeterList* self);
void greeter_list_insert_entry (GreeterList* self, PromptBox* entry);
static void greeter_list_real_insert_entry (GreeterList* self, PromptBox* entry);
static gint _greeter_list_compare_entry_gcompare_func (gconstpointer a, gconstpointer b);
void greeter_list_add_manual_entry (GreeterList* self);
static void greeter_list_real_add_manual_entry (GreeterList* self);
void greeter_list_add_entry (GreeterList* self, PromptBox* entry);
static void greeter_list_entry_clicked_cb (GreeterList* self, PromptBox* entry);
static void _greeter_list_entry_clicked_cb_prompt_box_name_clicked (PromptBox* _sender, gpointer self);
void greeter_list_move_names (GreeterList* self);
void greeter_list_set_active_first_entry_with_prefix (GreeterList* self, const gchar* prefix);
void greeter_list_remove_entry (GreeterList* self, const gchar* name);
void greeter_list_remove_entry_by_entry (GreeterList* self, PromptBox* entry);
void greeter_list_remove_entries_with_prefix (GreeterList* self, const gchar* prefix);
gboolean unity_greeter_show_remote_login_hint (UnityGreeter* self);
gint greeter_list_get_greeter_box_height (GreeterList* self);
gint greeter_list_get_greeter_box_height_grids (GreeterList* self);
gint greeter_list_get_greeter_box_x (GreeterList* self);
static gint greeter_list_get_box_x (GreeterList* self);
gint greeter_list_get_greeter_box_y (GreeterList* self);
static gint greeter_list_get_box_y (GreeterList* self);
gint greeter_list_get_position_y (GreeterList* self, gdouble position);
static gint greeter_list_real_get_position_y (GreeterList* self, gdouble position);
static void greeter_list_move_entry (GreeterList* self, PromptBox* entry, gdouble position);
void fadable_set_alpha (Fadable* self, gdouble alpha);
void prompt_box_set_position (PromptBox* self, gdouble value);
void greeter_list_greeter_box_size_allocate_cb (GreeterList* self, GtkAllocation* allocation);
static PromptBox* greeter_list_get_scrolling_entry (GreeterList* self);
static gboolean ___lambda59_ (GreeterList* self);
static gboolean ____lambda59__gsource_func (gpointer self);
gboolean dash_box_get_has_base (DashBox* self);
gdouble dash_box_get_base_alpha (DashBox* self);
static void greeter_list_animate_scrolling (GreeterList* self, gdouble progress);
void greeter_list_setup_prompt_box (GreeterList* self, gboolean fade);
static void greeter_list_finished_scrolling (GreeterList* self);
static void greeter_list_set_scrolling_entry (GreeterList* self, PromptBox* value);
static void greeter_list_set_selected_entry (GreeterList* self, PromptBox* value);
void animate_timer_reset (AnimateTimer* self, gint temp_speed);
void dash_box_set_base (DashBox* self, GtkWidget* w);
static void greeter_list_real_setup_prompt_box (GreeterList* self, gboolean fade);
void prompt_box_add_static_prompts (PromptBox* self);
void prompt_box_fade_in_prompts (PromptBox* self);
static void greeter_list_real_realize (GtkWidget* base);
gboolean greeter_list_get_start_scrolling (GreeterList* self);
static void greeter_list_allocate_greeter_box (GreeterList* self);
void prompt_box_set_zone (PromptBox* self, GtkWidget* zone);
static void greeter_list_real_size_allocate (GtkWidget* base, GtkAllocation* allocation);
static gboolean greeter_list_real_draw (GtkWidget* base, cairo_t* c);
FadeTracker* fadable_get_fade_tracker (Fadable* self);
gdouble fade_tracker_get_alpha (FadeTracker* self);
void greeter_list_connect_to_lightdm (GreeterList* self);
void greeter_list_show_message_cb (GreeterList* self, const gchar* text, LightDMMessageType type);
static void _greeter_list_show_message_cb_unity_greeter_show_message (UnityGreeter* _sender, const gchar* text, LightDMMessageType type, gpointer self);
void greeter_list_show_prompt_cb (GreeterList* self, const gchar* text, LightDMPromptType type);
static void _greeter_list_show_prompt_cb_unity_greeter_show_prompt (UnityGreeter* _sender, const gchar* text, LightDMPromptType type, gpointer self);
void greeter_list_authentication_complete_cb (GreeterList* self);
static void _greeter_list_authentication_complete_cb_unity_greeter_authentication_complete (UnityGreeter* _sender, gpointer self);
static void greeter_list_real_show_prompt_cb (GreeterList* self, const gchar* text, LightDMPromptType type);
const gchar* greeter_list_get_manual_name (GreeterList* self);
void greeter_list_set_manual_name (GreeterList* self, const gchar* value);
gchar* unity_greeter_authentication_user (UnityGreeter* self);
static void greeter_list_real_authentication_complete_cb (GreeterList* self);
gboolean unity_greeter_is_authenticated (UnityGreeter* self);
void greeter_list_login_complete (GreeterList* self);
static void greeter_list_start_session (GreeterList* self);
Background* greeter_list_get_background (GreeterList* self);
gdouble background_get_alpha (Background* self);
static void greeter_list_background_loaded_cb (GreeterList* self, GParamSpec* pspec);
static void _greeter_list_background_loaded_cb_g_object_notify (GObject* _sender, GParamSpec* pspec, gpointer self);
void prompt_box_reset_spinners (PromptBox* self);
void greeter_list_start_authentication (GreeterList* self);
gboolean prompt_box_get_has_errors (PromptBox* self);
static void greeter_list_real_start_authentication (GreeterList* self);
void greeter_list_test_start_authentication (GreeterList* self);
void unity_greeter_authenticate (UnityGreeter* self, const gchar* userid);
void unity_greeter_authenticate_as_guest (UnityGreeter* self);
gboolean unity_greeter_start_session (UnityGreeter* self, const gchar* session, Background* bg);
gchar* greeter_list_get_lightdm_session (GreeterList* self);
void background_set_draw_grid (Background* self, gboolean value);
static gchar* greeter_list_real_get_lightdm_session (GreeterList* self);
static void greeter_list_real_test_start_authentication (GreeterList* self);
static void greeter_list_set_background (GreeterList* self, Background* value);
void greeter_list_set_start_scrolling (GreeterList* self, gboolean value);
gboolean greeter_list_get_always_show_manual (GreeterList* self);
void greeter_list_set_always_show_manual (GreeterList* self, gboolean value);
#define MAIN_WINDOW_BUTTONBOX_HEIGHT 80
void prompt_box_set_options_image (PromptBox* self, GdkPixbuf* image);
static GObject * greeter_list_constructor (GType type, guint n_construct_properties, GObjectConstructParam * construct_properties);
DashBox* dash_box_new (Background* bg);
DashBox* dash_box_construct (GType object_type, Background* bg);
static void _greeter_list___lambda60_ (GreeterList* self);
static void __greeter_list___lambda60__g_object_notify (GObject* _sender, GParamSpec* pspec, gpointer self);
static void _greeter_list_greeter_box_size_allocate_cb_gtk_widget_size_allocate (GtkWidget* _sender, GtkAllocation* allocation, gpointer self);
gdouble animate_timer_ease_out_quint (gdouble x);
static gdouble _animate_timer_ease_out_quint_animate_timer_easing_func (gdouble x, gpointer self);
#define ANIMATE_TIMER_FAST 250
AnimateTimer* animate_timer_new (AnimateTimerEasingFunc func, void* func_target, gint speed);
AnimateTimer* animate_timer_construct (GType object_type, AnimateTimerEasingFunc func, void* func_target, gint speed);
static void _greeter_list_animate_scrolling_animate_timer_animate (AnimateTimer* _sender, gdouble progress, gpointer self);
static void _greeter_list_on_bus_acquired_gasync_ready_callback (GObject* source_object, GAsyncResult* res, gpointer self);
static void greeter_list_finalize (GObject* obj);
static void _vala_greeter_list_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec);
static void _vala_greeter_list_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec);

static const GDBusArgInfo _list_dbus_interface_dbus_arg_info_get_active_entry_result = {-1, "result", "s"};
static const GDBusArgInfo * const _list_dbus_interface_dbus_arg_info_get_active_entry_in[] = {NULL};
static const GDBusArgInfo * const _list_dbus_interface_dbus_arg_info_get_active_entry_out[] = {&_list_dbus_interface_dbus_arg_info_get_active_entry_result, NULL};
static const GDBusMethodInfo _list_dbus_interface_dbus_method_info_get_active_entry = {-1, "GetActiveEntry", (GDBusArgInfo **) (&_list_dbus_interface_dbus_arg_info_get_active_entry_in), (GDBusArgInfo **) (&_list_dbus_interface_dbus_arg_info_get_active_entry_out)};
static const GDBusArgInfo _list_dbus_interface_dbus_arg_info_set_active_entry_entry_name = {-1, "entry_name", "s"};
static const GDBusArgInfo * const _list_dbus_interface_dbus_arg_info_set_active_entry_in[] = {&_list_dbus_interface_dbus_arg_info_set_active_entry_entry_name, NULL};
static const GDBusArgInfo * const _list_dbus_interface_dbus_arg_info_set_active_entry_out[] = {NULL};
static const GDBusMethodInfo _list_dbus_interface_dbus_method_info_set_active_entry = {-1, "SetActiveEntry", (GDBusArgInfo **) (&_list_dbus_interface_dbus_arg_info_set_active_entry_in), (GDBusArgInfo **) (&_list_dbus_interface_dbus_arg_info_set_active_entry_out)};
static const GDBusMethodInfo * const _list_dbus_interface_dbus_method_info[] = {&_list_dbus_interface_dbus_method_info_get_active_entry, &_list_dbus_interface_dbus_method_info_set_active_entry, NULL};
static const GDBusArgInfo _list_dbus_interface_dbus_arg_info_entry_selected_entry_name = {-1, "entry_name", "s"};
static const GDBusArgInfo * const _list_dbus_interface_dbus_arg_info_entry_selected[] = {&_list_dbus_interface_dbus_arg_info_entry_selected_entry_name, NULL};
static const GDBusSignalInfo _list_dbus_interface_dbus_signal_info_entry_selected = {-1, "EntrySelected", (GDBusArgInfo **) (&_list_dbus_interface_dbus_arg_info_entry_selected)};
static const GDBusSignalInfo * const _list_dbus_interface_dbus_signal_info[] = {&_list_dbus_interface_dbus_signal_info_entry_selected, NULL};
static const GDBusPropertyInfo * const _list_dbus_interface_dbus_property_info[] = {NULL};
static const GDBusInterfaceInfo _list_dbus_interface_dbus_interface_info = {-1, "com.canonical.UnityGreeter.List", (GDBusMethodInfo **) (&_list_dbus_interface_dbus_method_info), (GDBusSignalInfo **) (&_list_dbus_interface_dbus_signal_info), (GDBusPropertyInfo **) (&_list_dbus_interface_dbus_property_info)};
static const GDBusInterfaceVTable _list_dbus_interface_dbus_interface_vtable = {list_dbus_interface_dbus_interface_method_call, list_dbus_interface_dbus_interface_get_property, list_dbus_interface_dbus_interface_set_property};

gint get_grid_offset (gint size) {
	gint result = 0;
	gint _tmp0_ = 0;
	_tmp0_ = size;
	result = ((gint) (_tmp0_ % grid_size)) / 2;
	return result;
}


static gpointer _g_object_ref0 (gpointer self) {
	return self ? g_object_ref (self) : NULL;
}


static void __lambda58_ (ListDBusInterface* self, const gchar* name) {
	const gchar* _tmp0_ = NULL;
	_tmp0_ = name;
	g_signal_emit_by_name (self, "entry-selected", _tmp0_);
}


static void ___lambda58__greeter_list_entry_selected (GreeterList* _sender, const gchar* name, gpointer self) {
	__lambda58_ (self, name);
}


ListDBusInterface* list_dbus_interface_construct (GType object_type, GreeterList* list) {
	ListDBusInterface * self = NULL;
	GreeterList* _tmp0_ = NULL;
	GreeterList* _tmp1_ = NULL;
	GreeterList* _tmp2_ = NULL;
	g_return_val_if_fail (list != NULL, NULL);
	self = (ListDBusInterface*) g_object_new (object_type, NULL);
	_tmp0_ = list;
	_tmp1_ = _g_object_ref0 (_tmp0_);
	_g_object_unref0 (self->priv->list);
	self->priv->list = _tmp1_;
	_tmp2_ = self->priv->list;
	g_signal_connect_object (_tmp2_, "entry-selected", (GCallback) ___lambda58__greeter_list_entry_selected, self, 0);
	return self;
}


ListDBusInterface* list_dbus_interface_new (GreeterList* list) {
	return list_dbus_interface_construct (TYPE_LIST_DBUS_INTERFACE, list);
}


gchar* list_dbus_interface_get_active_entry (ListDBusInterface* self) {
	gchar* result = NULL;
	gchar* entry = NULL;
	gchar* _tmp0_ = NULL;
	gboolean _tmp1_ = FALSE;
	GreeterList* _tmp2_ = NULL;
	PromptBox* _tmp3_ = NULL;
	PromptBox* _tmp4_ = NULL;
	gboolean _tmp10_ = FALSE;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = g_strdup ("");
	entry = _tmp0_;
	_tmp2_ = self->priv->list;
	_tmp3_ = greeter_list_get_selected_entry (_tmp2_);
	_tmp4_ = _tmp3_;
	if (_tmp4_ != NULL) {
		GreeterList* _tmp5_ = NULL;
		PromptBox* _tmp6_ = NULL;
		PromptBox* _tmp7_ = NULL;
		const gchar* _tmp8_ = NULL;
		const gchar* _tmp9_ = NULL;
		_tmp5_ = self->priv->list;
		_tmp6_ = greeter_list_get_selected_entry (_tmp5_);
		_tmp7_ = _tmp6_;
		_tmp8_ = prompt_box_get_id (_tmp7_);
		_tmp9_ = _tmp8_;
		_tmp1_ = _tmp9_ != NULL;
	} else {
		_tmp1_ = FALSE;
	}
	_tmp10_ = _tmp1_;
	if (_tmp10_) {
		GreeterList* _tmp11_ = NULL;
		PromptBox* _tmp12_ = NULL;
		PromptBox* _tmp13_ = NULL;
		const gchar* _tmp14_ = NULL;
		const gchar* _tmp15_ = NULL;
		gchar* _tmp16_ = NULL;
		_tmp11_ = self->priv->list;
		_tmp12_ = greeter_list_get_selected_entry (_tmp11_);
		_tmp13_ = _tmp12_;
		_tmp14_ = prompt_box_get_id (_tmp13_);
		_tmp15_ = _tmp14_;
		_tmp16_ = g_strdup (_tmp15_);
		_g_free0 (entry);
		entry = _tmp16_;
	}
	result = entry;
	return result;
}


void list_dbus_interface_set_active_entry (ListDBusInterface* self, const gchar* entry_name) {
	GreeterList* _tmp0_ = NULL;
	const gchar* _tmp1_ = NULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (entry_name != NULL);
	_tmp0_ = self->priv->list;
	_tmp1_ = entry_name;
	greeter_list_set_active_entry (_tmp0_, _tmp1_);
}


static void list_dbus_interface_class_init (ListDBusInterfaceClass * klass) {
	list_dbus_interface_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (ListDBusInterfacePrivate));
	G_OBJECT_CLASS (klass)->finalize = list_dbus_interface_finalize;
	g_signal_new ("entry_selected", TYPE_LIST_DBUS_INTERFACE, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_marshal_VOID__STRING, G_TYPE_NONE, 1, G_TYPE_STRING);
}


static void list_dbus_interface_instance_init (ListDBusInterface * self) {
	self->priv = LIST_DBUS_INTERFACE_GET_PRIVATE (self);
}


static void list_dbus_interface_finalize (GObject* obj) {
	ListDBusInterface * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, TYPE_LIST_DBUS_INTERFACE, ListDBusInterface);
	_g_object_unref0 (self->priv->list);
	G_OBJECT_CLASS (list_dbus_interface_parent_class)->finalize (obj);
}


GType list_dbus_interface_get_type (void) {
	static volatile gsize list_dbus_interface_type_id__volatile = 0;
	if (g_once_init_enter (&list_dbus_interface_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (ListDBusInterfaceClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) list_dbus_interface_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (ListDBusInterface), 0, (GInstanceInitFunc) list_dbus_interface_instance_init, NULL };
		GType list_dbus_interface_type_id;
		list_dbus_interface_type_id = g_type_register_static (G_TYPE_OBJECT, "ListDBusInterface", &g_define_type_info, 0);
		g_type_set_qdata (list_dbus_interface_type_id, g_quark_from_static_string ("vala-dbus-register-object"), (void*) list_dbus_interface_register_object);
		g_once_init_leave (&list_dbus_interface_type_id__volatile, list_dbus_interface_type_id);
	}
	return list_dbus_interface_type_id__volatile;
}


static void _dbus_list_dbus_interface_get_active_entry (ListDBusInterface* self, GVariant* parameters, GDBusMethodInvocation* invocation) {
	GError* error = NULL;
	GVariantIter _arguments_iter;
	GDBusMessage* _reply_message;
	GVariant* _reply;
	GVariantBuilder _reply_builder;
	gchar* result;
	g_variant_iter_init (&_arguments_iter, parameters);
	result = list_dbus_interface_get_active_entry (self);
	_reply_message = g_dbus_message_new_method_reply (g_dbus_method_invocation_get_message (invocation));
	g_variant_builder_init (&_reply_builder, G_VARIANT_TYPE_TUPLE);
	g_variant_builder_add_value (&_reply_builder, g_variant_new_string (result));
	_g_free0 (result);
	_reply = g_variant_builder_end (&_reply_builder);
	g_dbus_message_set_body (_reply_message, _reply);
	g_dbus_connection_send_message (g_dbus_method_invocation_get_connection (invocation), _reply_message, G_DBUS_SEND_MESSAGE_FLAGS_NONE, NULL, NULL);
	g_object_unref (invocation);
	g_object_unref (_reply_message);
}


static void _dbus_list_dbus_interface_set_active_entry (ListDBusInterface* self, GVariant* parameters, GDBusMethodInvocation* invocation) {
	GError* error = NULL;
	GVariantIter _arguments_iter;
	gchar* entry_name = NULL;
	GVariant* _tmp0_;
	GDBusMessage* _reply_message;
	GVariant* _reply;
	GVariantBuilder _reply_builder;
	g_variant_iter_init (&_arguments_iter, parameters);
	_tmp0_ = g_variant_iter_next_value (&_arguments_iter);
	entry_name = g_variant_dup_string (_tmp0_, NULL);
	g_variant_unref (_tmp0_);
	list_dbus_interface_set_active_entry (self, entry_name);
	_reply_message = g_dbus_message_new_method_reply (g_dbus_method_invocation_get_message (invocation));
	g_variant_builder_init (&_reply_builder, G_VARIANT_TYPE_TUPLE);
	_reply = g_variant_builder_end (&_reply_builder);
	g_dbus_message_set_body (_reply_message, _reply);
	_g_free0 (entry_name);
	g_dbus_connection_send_message (g_dbus_method_invocation_get_connection (invocation), _reply_message, G_DBUS_SEND_MESSAGE_FLAGS_NONE, NULL, NULL);
	g_object_unref (invocation);
	g_object_unref (_reply_message);
}


static void list_dbus_interface_dbus_interface_method_call (GDBusConnection* connection, const gchar* sender, const gchar* object_path, const gchar* interface_name, const gchar* method_name, GVariant* parameters, GDBusMethodInvocation* invocation, gpointer user_data) {
	gpointer* data;
	gpointer object;
	data = user_data;
	object = data[0];
	if (strcmp (method_name, "GetActiveEntry") == 0) {
		_dbus_list_dbus_interface_get_active_entry (object, parameters, invocation);
	} else if (strcmp (method_name, "SetActiveEntry") == 0) {
		_dbus_list_dbus_interface_set_active_entry (object, parameters, invocation);
	} else {
		g_object_unref (invocation);
	}
}


static GVariant* list_dbus_interface_dbus_interface_get_property (GDBusConnection* connection, const gchar* sender, const gchar* object_path, const gchar* interface_name, const gchar* property_name, GError** error, gpointer user_data) {
	gpointer* data;
	gpointer object;
	data = user_data;
	object = data[0];
	return NULL;
}


static gboolean list_dbus_interface_dbus_interface_set_property (GDBusConnection* connection, const gchar* sender, const gchar* object_path, const gchar* interface_name, const gchar* property_name, GVariant* value, GError** error, gpointer user_data) {
	gpointer* data;
	gpointer object;
	data = user_data;
	object = data[0];
	return FALSE;
}


static void _dbus_list_dbus_interface_entry_selected (GObject* _sender, const gchar* entry_name, gpointer* _data) {
	GDBusConnection * _connection;
	const gchar * _path;
	GVariant *_arguments;
	GVariantBuilder _arguments_builder;
	_connection = _data[1];
	_path = _data[2];
	g_variant_builder_init (&_arguments_builder, G_VARIANT_TYPE_TUPLE);
	g_variant_builder_add_value (&_arguments_builder, g_variant_new_string (entry_name));
	_arguments = g_variant_builder_end (&_arguments_builder);
	g_dbus_connection_emit_signal (_connection, NULL, _path, "com.canonical.UnityGreeter.List", "EntrySelected", _arguments, NULL);
}


guint list_dbus_interface_register_object (gpointer object, GDBusConnection* connection, const gchar* path, GError** error) {
	guint result;
	gpointer *data;
	data = g_new (gpointer, 3);
	data[0] = g_object_ref (object);
	data[1] = g_object_ref (connection);
	data[2] = g_strdup (path);
	result = g_dbus_connection_register_object (connection, path, (GDBusInterfaceInfo *) (&_list_dbus_interface_dbus_interface_info), &_list_dbus_interface_dbus_interface_vtable, data, _list_dbus_interface_unregister_object, error);
	if (!result) {
		return 0;
	}
	g_signal_connect (object, "entry-selected", (GCallback) _dbus_list_dbus_interface_entry_selected, data);
	return result;
}


static void _list_dbus_interface_unregister_object (gpointer user_data) {
	gpointer* data;
	data = user_data;
	g_signal_handlers_disconnect_by_func (data[0], _dbus_list_dbus_interface_entry_selected, data);
	g_object_unref (data[0]);
	g_object_unref (data[1]);
	g_free (data[2]);
	g_free (data);
}


GType greeter_list_mode_get_type (void) {
	static volatile gsize greeter_list_mode_type_id__volatile = 0;
	if (g_once_init_enter (&greeter_list_mode_type_id__volatile)) {
		static const GEnumValue values[] = {{GREETER_LIST_MODE_ENTRY, "GREETER_LIST_MODE_ENTRY", "entry"}, {GREETER_LIST_MODE_SCROLLING, "GREETER_LIST_MODE_SCROLLING", "scrolling"}, {0, NULL, NULL}};
		GType greeter_list_mode_type_id;
		greeter_list_mode_type_id = g_enum_register_static ("GreeterListMode", values);
		g_once_init_leave (&greeter_list_mode_type_id__volatile, greeter_list_mode_type_id);
	}
	return greeter_list_mode_type_id__volatile;
}


GType greeter_list_scroll_target_get_type (void) {
	static volatile gsize greeter_list_scroll_target_type_id__volatile = 0;
	if (g_once_init_enter (&greeter_list_scroll_target_type_id__volatile)) {
		static const GEnumValue values[] = {{GREETER_LIST_SCROLL_TARGET_START, "GREETER_LIST_SCROLL_TARGET_START", "start"}, {GREETER_LIST_SCROLL_TARGET_END, "GREETER_LIST_SCROLL_TARGET_END", "end"}, {GREETER_LIST_SCROLL_TARGET_UP, "GREETER_LIST_SCROLL_TARGET_UP", "up"}, {GREETER_LIST_SCROLL_TARGET_DOWN, "GREETER_LIST_SCROLL_TARGET_DOWN", "down"}, {0, NULL, NULL}};
		GType greeter_list_scroll_target_type_id;
		greeter_list_scroll_target_type_id = g_enum_register_static ("GreeterListScrollTarget", values);
		g_once_init_leave (&greeter_list_scroll_target_type_id__volatile, greeter_list_scroll_target_type_id);
	}
	return greeter_list_scroll_target_type_id__volatile;
}


static void _g_object_unref0_ (gpointer var) {
	(var == NULL) ? NULL : (var = (g_object_unref (var), NULL));
}


static void _g_list_free__g_object_unref0_ (GList* self) {
	g_list_foreach (self, (GFunc) _g_object_unref0_, NULL);
	g_list_free (self);
}


static gchar* greeter_list_real_get_selected_id (GreeterList* self) {
	gchar* result = NULL;
	PromptBox* _tmp0_ = NULL;
	PromptBox* _tmp1_ = NULL;
	const gchar* _tmp2_ = NULL;
	const gchar* _tmp3_ = NULL;
	gchar* _tmp4_ = NULL;
	_tmp0_ = self->priv->_selected_entry;
	if (_tmp0_ == NULL) {
		result = NULL;
		return result;
	}
	_tmp1_ = self->priv->_selected_entry;
	_tmp2_ = prompt_box_get_id (_tmp1_);
	_tmp3_ = _tmp2_;
	_tmp4_ = g_strdup (_tmp3_);
	result = _tmp4_;
	return result;
}


gchar* greeter_list_get_selected_id (GreeterList* self) {
	g_return_val_if_fail (self != NULL, NULL);
	return GREETER_LIST_GET_CLASS (self)->get_selected_id (self);
}


GreeterList* greeter_list_construct (GType object_type, Background* bg) {
	GreeterList * self = NULL;
	Background* _tmp0_ = NULL;
	g_return_val_if_fail (bg != NULL, NULL);
	_tmp0_ = bg;
	self = (GreeterList*) g_object_new (object_type, "background", _tmp0_, NULL);
	return self;
}


static void greeter_list_on_bus_acquired (GreeterList* self, GObject* obj, GAsyncResult* res) {
	GError * _inner_error_ = NULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (res != NULL);
	{
		GDBusConnection* conn = NULL;
		GAsyncResult* _tmp0_ = NULL;
		GDBusConnection* _tmp1_ = NULL;
		ListDBusInterface* _tmp2_ = NULL;
		GDBusConnection* _tmp3_ = NULL;
		ListDBusInterface* _tmp4_ = NULL;
		_tmp0_ = res;
		_tmp1_ = g_bus_get_finish (_tmp0_, &_inner_error_);
		conn = _tmp1_;
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == G_IO_ERROR) {
				goto __catch9_g_io_error;
			}
			g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return;
		}
		_tmp2_ = list_dbus_interface_new (self);
		_g_object_unref0 (self->priv->dbus_object);
		self->priv->dbus_object = _tmp2_;
		_tmp3_ = conn;
		_tmp4_ = self->priv->dbus_object;
		list_dbus_interface_register_object (_tmp4_, _tmp3_, "/list", &_inner_error_);
		if (_inner_error_ != NULL) {
			_g_object_unref0 (conn);
			if (_inner_error_->domain == G_IO_ERROR) {
				goto __catch9_g_io_error;
			}
			_g_object_unref0 (conn);
			g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return;
		}
		_g_object_unref0 (conn);
	}
	goto __finally9;
	__catch9_g_io_error:
	{
		GError* e = NULL;
		GError* _tmp5_ = NULL;
		const gchar* _tmp6_ = NULL;
		e = _inner_error_;
		_inner_error_ = NULL;
		_tmp5_ = e;
		_tmp6_ = _tmp5_->message;
		g_debug ("greeter-list.vala:208: Error registering user list dbus object: %s", _tmp6_);
		_g_error_free0 (e);
	}
	__finally9:
	if (_inner_error_ != NULL) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return;
	}
}


static void greeter_list_real_get_preferred_width (GtkWidget* base, gint* min, gint* nat) {
	GreeterList * self;
	gint _vala_min = 0;
	gint _vala_nat = 0;
	self = (GreeterList*) base;
	_vala_min = GREETER_LIST_BOX_WIDTH * grid_size;
	_vala_nat = GREETER_LIST_BOX_WIDTH * grid_size;
	if (min) {
		*min = _vala_min;
	}
	if (nat) {
		*nat = _vala_nat;
	}
}


static void greeter_list_real_get_preferred_height (GtkWidget* base, gint* min, gint* nat) {
	GreeterList * self;
	gint _vala_min = 0;
	gint _vala_nat = 0;
	gint _tmp0_ = 0;
	gint _tmp1_ = 0;
	self = (GreeterList*) base;
	GTK_WIDGET_CLASS (greeter_list_parent_class)->get_preferred_height ((GtkWidget*) G_TYPE_CHECK_INSTANCE_CAST (self, TYPE_FADABLE_BOX, FadableBox), &_tmp0_, &_tmp1_);
	_vala_min = _tmp0_;
	_vala_nat = _tmp1_;
	_vala_min = 0;
	if (min) {
		*min = _vala_min;
	}
	if (nat) {
		*nat = _vala_nat;
	}
}


void greeter_list_cancel_authentication (GreeterList* self) {
	UnityGreeter* _tmp0_ = NULL;
	PromptBox* _tmp1_ = NULL;
	const gchar* _tmp2_ = NULL;
	const gchar* _tmp3_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = unity_greeter_singleton;
	unity_greeter_cancel_authentication (_tmp0_);
	_tmp1_ = self->priv->_selected_entry;
	_tmp2_ = prompt_box_get_id (_tmp1_);
	_tmp3_ = _tmp2_;
	g_signal_emit_by_name (self, "entry-selected", _tmp3_);
}


void greeter_list_scroll (GreeterList* self, GreeterListScrollTarget target) {
	gboolean _tmp0_ = FALSE;
	gboolean _tmp1_ = FALSE;
	GreeterListScrollTarget _tmp2_ = 0;
	g_return_if_fail (self != NULL);
	_tmp0_ = gtk_widget_get_sensitive ((GtkWidget*) self);
	_tmp1_ = _tmp0_;
	if (!_tmp1_) {
		return;
	}
	_tmp2_ = target;
	switch (_tmp2_) {
		case GREETER_LIST_SCROLL_TARGET_START:
		{
			GList* _tmp3_ = NULL;
			gconstpointer _tmp4_ = NULL;
			_tmp3_ = self->entries;
			_tmp4_ = g_list_nth_data (_tmp3_, (guint) 0);
			greeter_list_select_entry (self, (PromptBox*) _tmp4_, -1.0, TRUE);
			break;
		}
		case GREETER_LIST_SCROLL_TARGET_END:
		{
			GList* _tmp5_ = NULL;
			GList* _tmp6_ = NULL;
			guint _tmp7_ = 0U;
			gconstpointer _tmp8_ = NULL;
			_tmp5_ = self->entries;
			_tmp6_ = self->entries;
			_tmp7_ = g_list_length (_tmp6_);
			_tmp8_ = g_list_nth_data (_tmp5_, _tmp7_ - 1);
			greeter_list_select_entry (self, (PromptBox*) _tmp8_, 1.0, TRUE);
			break;
		}
		case GREETER_LIST_SCROLL_TARGET_UP:
		{
			gint index = 0;
			GList* _tmp9_ = NULL;
			PromptBox* _tmp10_ = NULL;
			gint _tmp11_ = 0;
			gint _tmp12_ = 0;
			GList* _tmp13_ = NULL;
			gint _tmp14_ = 0;
			gconstpointer _tmp15_ = NULL;
			_tmp9_ = self->entries;
			_tmp10_ = self->priv->_selected_entry;
			_tmp11_ = g_list_index (_tmp9_, _tmp10_);
			index = _tmp11_ - 1;
			_tmp12_ = index;
			if (_tmp12_ < 0) {
				index = 0;
			}
			_tmp13_ = self->entries;
			_tmp14_ = index;
			_tmp15_ = g_list_nth_data (_tmp13_, (guint) _tmp14_);
			greeter_list_select_entry (self, (PromptBox*) _tmp15_, -1.0, TRUE);
			break;
		}
		case GREETER_LIST_SCROLL_TARGET_DOWN:
		{
			gint index = 0;
			GList* _tmp16_ = NULL;
			PromptBox* _tmp17_ = NULL;
			gint _tmp18_ = 0;
			gint _tmp19_ = 0;
			GList* _tmp20_ = NULL;
			guint _tmp21_ = 0U;
			GList* _tmp24_ = NULL;
			gint _tmp25_ = 0;
			gconstpointer _tmp26_ = NULL;
			_tmp16_ = self->entries;
			_tmp17_ = self->priv->_selected_entry;
			_tmp18_ = g_list_index (_tmp16_, _tmp17_);
			index = _tmp18_ + 1;
			_tmp19_ = index;
			_tmp20_ = self->entries;
			_tmp21_ = g_list_length (_tmp20_);
			if (_tmp19_ >= ((gint) _tmp21_)) {
				GList* _tmp22_ = NULL;
				guint _tmp23_ = 0U;
				_tmp22_ = self->entries;
				_tmp23_ = g_list_length (_tmp22_);
				index = ((gint) _tmp23_) - 1;
			}
			_tmp24_ = self->entries;
			_tmp25_ = index;
			_tmp26_ = g_list_nth_data (_tmp24_, (guint) _tmp25_);
			greeter_list_select_entry (self, (PromptBox*) _tmp26_, 1.0, TRUE);
			break;
		}
		default:
		break;
	}
}


void greeter_list_add_with_class (GreeterList* self, GtkWidget* widget) {
	GtkFixed* _tmp0_ = NULL;
	GtkWidget* _tmp1_ = NULL;
	GtkWidget* _tmp2_ = NULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (widget != NULL);
	_tmp0_ = self->priv->fixed;
	_tmp1_ = widget;
	gtk_container_add ((GtkContainer*) _tmp0_, _tmp1_);
	_tmp2_ = widget;
	unity_greeter_add_style_class (_tmp2_);
}


void greeter_list_redraw_greeter_box (GreeterList* self) {
	GtkAllocation allocation = {0};
	DashBox* _tmp0_ = NULL;
	GtkAllocation _tmp1_ = {0};
	GtkAllocation _tmp2_ = {0};
	gint _tmp3_ = 0;
	GtkAllocation _tmp4_ = {0};
	gint _tmp5_ = 0;
	GtkAllocation _tmp6_ = {0};
	gint _tmp7_ = 0;
	GtkAllocation _tmp8_ = {0};
	gint _tmp9_ = 0;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->greeter_box;
	gtk_widget_get_allocation ((GtkWidget*) _tmp0_, &_tmp1_);
	allocation = _tmp1_;
	_tmp2_ = allocation;
	_tmp3_ = _tmp2_.x;
	_tmp4_ = allocation;
	_tmp5_ = _tmp4_.y;
	_tmp6_ = allocation;
	_tmp7_ = _tmp6_.width;
	_tmp8_ = allocation;
	_tmp9_ = _tmp8_.height;
	gtk_widget_queue_draw_area ((GtkWidget*) self, _tmp3_, _tmp5_, _tmp7_, _tmp9_);
}


void greeter_list_show_message (GreeterList* self, const gchar* text, gboolean is_error) {
	gboolean _tmp0_ = FALSE;
	PromptBox* _tmp2_ = NULL;
	const gchar* _tmp3_ = NULL;
	gboolean _tmp4_ = FALSE;
	g_return_if_fail (self != NULL);
	g_return_if_fail (text != NULL);
	_tmp0_ = self->will_clear;
	if (_tmp0_) {
		PromptBox* _tmp1_ = NULL;
		_tmp1_ = self->priv->_selected_entry;
		prompt_box_clear (_tmp1_);
		self->will_clear = FALSE;
	}
	_tmp2_ = self->priv->_selected_entry;
	_tmp3_ = text;
	_tmp4_ = is_error;
	prompt_box_add_message (_tmp2_, _tmp3_, _tmp4_);
}


DashEntry* greeter_list_add_prompt (GreeterList* self, const gchar* text, gboolean secret) {
	DashEntry* result = NULL;
	gboolean _tmp0_ = FALSE;
	gchar* accessible_text = NULL;
	gboolean _tmp2_ = FALSE;
	PromptBox* _tmp3_ = NULL;
	gboolean _tmp7_ = FALSE;
	DashEntry* prompt = NULL;
	PromptBox* _tmp13_ = NULL;
	const gchar* _tmp14_ = NULL;
	const gchar* _tmp15_ = NULL;
	gboolean _tmp16_ = FALSE;
	DashEntry* _tmp17_ = NULL;
	GreeterListMode _tmp18_ = 0;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (text != NULL, NULL);
	_tmp0_ = self->will_clear;
	if (_tmp0_) {
		PromptBox* _tmp1_ = NULL;
		_tmp1_ = self->priv->_selected_entry;
		prompt_box_clear (_tmp1_);
		self->will_clear = FALSE;
	}
	accessible_text = NULL;
	_tmp3_ = self->priv->_selected_entry;
	if (_tmp3_ != NULL) {
		PromptBox* _tmp4_ = NULL;
		const gchar* _tmp5_ = NULL;
		const gchar* _tmp6_ = NULL;
		_tmp4_ = self->priv->_selected_entry;
		_tmp5_ = prompt_box_get_label (_tmp4_);
		_tmp6_ = _tmp5_;
		_tmp2_ = _tmp6_ != NULL;
	} else {
		_tmp2_ = FALSE;
	}
	_tmp7_ = _tmp2_;
	if (_tmp7_) {
		const gchar* _tmp8_ = NULL;
		PromptBox* _tmp9_ = NULL;
		const gchar* _tmp10_ = NULL;
		const gchar* _tmp11_ = NULL;
		gchar* _tmp12_ = NULL;
		_tmp8_ = _ ("Enter password for %s");
		_tmp9_ = self->priv->_selected_entry;
		_tmp10_ = prompt_box_get_label (_tmp9_);
		_tmp11_ = _tmp10_;
		_tmp12_ = g_strdup_printf (_tmp8_, _tmp11_);
		_g_free0 (accessible_text);
		accessible_text = _tmp12_;
	}
	_tmp13_ = self->priv->_selected_entry;
	_tmp14_ = text;
	_tmp15_ = accessible_text;
	_tmp16_ = secret;
	_tmp17_ = prompt_box_add_prompt (_tmp13_, _tmp14_, _tmp15_, _tmp16_);
	prompt = _tmp17_;
	_tmp18_ = self->mode;
	if (_tmp18_ != GREETER_LIST_MODE_SCROLLING) {
		PromptBox* _tmp19_ = NULL;
		_tmp19_ = self->priv->_selected_entry;
		prompt_box_show_prompts (_tmp19_);
	}
	greeter_list_focus_prompt (self);
	greeter_list_redraw_greeter_box (self);
	result = prompt;
	_g_free0 (accessible_text);
	return result;
}


GtkComboBox* greeter_list_add_combo (GreeterList* self, GPtrArray* texts, gboolean read_only) {
	GtkComboBox* result = NULL;
	gboolean _tmp0_ = FALSE;
	GtkComboBox* combo = NULL;
	PromptBox* _tmp2_ = NULL;
	GPtrArray* _tmp3_ = NULL;
	gboolean _tmp4_ = FALSE;
	GtkComboBox* _tmp5_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (texts != NULL, NULL);
	_tmp0_ = self->will_clear;
	if (_tmp0_) {
		PromptBox* _tmp1_ = NULL;
		_tmp1_ = self->priv->_selected_entry;
		prompt_box_clear (_tmp1_);
		self->will_clear = FALSE;
	}
	_tmp2_ = self->priv->_selected_entry;
	_tmp3_ = texts;
	_tmp4_ = read_only;
	_tmp5_ = prompt_box_add_combo (_tmp2_, _tmp3_, _tmp4_);
	combo = _tmp5_;
	greeter_list_focus_prompt (self);
	greeter_list_redraw_greeter_box (self);
	result = combo;
	return result;
}


static void greeter_list_real_grab_focus (GtkWidget* base) {
	GreeterList * self;
	self = (GreeterList*) base;
	greeter_list_focus_prompt (self);
}


static void greeter_list_real_focus_prompt (GreeterList* self) {
	PromptBox* _tmp0_ = NULL;
	PromptBox* _tmp1_ = NULL;
	_tmp0_ = self->priv->_selected_entry;
	gtk_widget_set_sensitive ((GtkWidget*) _tmp0_, TRUE);
	_tmp1_ = self->priv->_selected_entry;
	gtk_widget_grab_focus ((GtkWidget*) _tmp1_);
}


void greeter_list_focus_prompt (GreeterList* self) {
	g_return_if_fail (self != NULL);
	GREETER_LIST_GET_CLASS (self)->focus_prompt (self);
}


static void greeter_list_real_show_authenticated (GreeterList* self, gboolean successful) {
	g_critical ("Type `%s' does not implement abstract method `greeter_list_show_authenticated'", g_type_name (G_TYPE_FROM_INSTANCE (self)));
	return;
}


void greeter_list_show_authenticated (GreeterList* self, gboolean successful) {
	g_return_if_fail (self != NULL);
	GREETER_LIST_GET_CLASS (self)->show_authenticated (self, successful);
}


PromptBox* greeter_list_find_entry (GreeterList* self, const gchar* id) {
	PromptBox* result = NULL;
	GList* _tmp0_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (id != NULL, NULL);
	_tmp0_ = self->entries;
	{
		GList* entry_collection = NULL;
		GList* entry_it = NULL;
		entry_collection = _tmp0_;
		for (entry_it = entry_collection; entry_it != NULL; entry_it = entry_it->next) {
			PromptBox* _tmp1_ = NULL;
			PromptBox* entry = NULL;
			_tmp1_ = _g_object_ref0 ((PromptBox*) entry_it->data);
			entry = _tmp1_;
			{
				PromptBox* _tmp2_ = NULL;
				const gchar* _tmp3_ = NULL;
				const gchar* _tmp4_ = NULL;
				const gchar* _tmp5_ = NULL;
				_tmp2_ = entry;
				_tmp3_ = prompt_box_get_id (_tmp2_);
				_tmp4_ = _tmp3_;
				_tmp5_ = id;
				if (g_strcmp0 (_tmp4_, _tmp5_) == 0) {
					result = entry;
					return result;
				}
				_g_object_unref0 (entry);
			}
		}
	}
	result = NULL;
	return result;
}


gint greeter_list_compare_entry (PromptBox* a, PromptBox* b) {
	gint result = 0;
	gboolean _tmp0_ = FALSE;
	PromptBox* _tmp1_ = NULL;
	const gchar* _tmp2_ = NULL;
	const gchar* _tmp3_ = NULL;
	gboolean _tmp4_ = FALSE;
	gboolean _tmp9_ = FALSE;
	PromptBox* _tmp24_ = NULL;
	const gchar* _tmp25_ = NULL;
	const gchar* _tmp26_ = NULL;
	PromptBox* _tmp27_ = NULL;
	const gchar* _tmp28_ = NULL;
	const gchar* _tmp29_ = NULL;
	gint _tmp30_ = 0;
	g_return_val_if_fail (a != NULL, 0);
	g_return_val_if_fail (b != NULL, 0);
	_tmp1_ = a;
	_tmp2_ = prompt_box_get_id (_tmp1_);
	_tmp3_ = _tmp2_;
	_tmp4_ = g_str_has_prefix (_tmp3_, "*");
	if (_tmp4_) {
		_tmp0_ = TRUE;
	} else {
		PromptBox* _tmp5_ = NULL;
		const gchar* _tmp6_ = NULL;
		const gchar* _tmp7_ = NULL;
		gboolean _tmp8_ = FALSE;
		_tmp5_ = b;
		_tmp6_ = prompt_box_get_id (_tmp5_);
		_tmp7_ = _tmp6_;
		_tmp8_ = g_str_has_prefix (_tmp7_, "*");
		_tmp0_ = _tmp8_;
	}
	_tmp9_ = _tmp0_;
	if (_tmp9_) {
		PromptBox* _tmp10_ = NULL;
		const gchar* _tmp11_ = NULL;
		const gchar* _tmp12_ = NULL;
		gboolean _tmp13_ = FALSE;
		PromptBox* _tmp14_ = NULL;
		const gchar* _tmp15_ = NULL;
		const gchar* _tmp16_ = NULL;
		gboolean _tmp17_ = FALSE;
		PromptBox* _tmp18_ = NULL;
		const gchar* _tmp19_ = NULL;
		const gchar* _tmp20_ = NULL;
		PromptBox* _tmp21_ = NULL;
		const gchar* _tmp22_ = NULL;
		const gchar* _tmp23_ = NULL;
		_tmp10_ = a;
		_tmp11_ = prompt_box_get_id (_tmp10_);
		_tmp12_ = _tmp11_;
		_tmp13_ = g_str_has_prefix (_tmp12_, "*");
		if (!_tmp13_) {
			result = -1;
			return result;
		}
		_tmp14_ = b;
		_tmp15_ = prompt_box_get_id (_tmp14_);
		_tmp16_ = _tmp15_;
		_tmp17_ = g_str_has_prefix (_tmp16_, "*");
		if (!_tmp17_) {
			result = 1;
			return result;
		}
		_tmp18_ = a;
		_tmp19_ = prompt_box_get_id (_tmp18_);
		_tmp20_ = _tmp19_;
		if (g_strcmp0 (_tmp20_, "*other") == 0) {
			result = -1;
			return result;
		}
		_tmp21_ = a;
		_tmp22_ = prompt_box_get_id (_tmp21_);
		_tmp23_ = _tmp22_;
		if (g_strcmp0 (_tmp23_, "*guest") == 0) {
			result = 1;
			return result;
		}
	}
	_tmp24_ = a;
	_tmp25_ = prompt_box_get_label (_tmp24_);
	_tmp26_ = _tmp25_;
	_tmp27_ = b;
	_tmp28_ = prompt_box_get_label (_tmp27_);
	_tmp29_ = _tmp28_;
	_tmp30_ = g_ascii_strcasecmp (_tmp26_, _tmp29_);
	result = _tmp30_;
	return result;
}


gboolean greeter_list_have_entries (GreeterList* self) {
	gboolean result = FALSE;
	GList* _tmp0_ = NULL;
	g_return_val_if_fail (self != NULL, FALSE);
	_tmp0_ = self->entries;
	{
		GList* e_collection = NULL;
		GList* e_it = NULL;
		e_collection = _tmp0_;
		for (e_it = e_collection; e_it != NULL; e_it = e_it->next) {
			PromptBox* _tmp1_ = NULL;
			PromptBox* e = NULL;
			_tmp1_ = _g_object_ref0 ((PromptBox*) e_it->data);
			e = _tmp1_;
			{
				PromptBox* _tmp2_ = NULL;
				const gchar* _tmp3_ = NULL;
				const gchar* _tmp4_ = NULL;
				_tmp2_ = e;
				_tmp3_ = prompt_box_get_id (_tmp2_);
				_tmp4_ = _tmp3_;
				if (g_strcmp0 (_tmp4_, "*other") != 0) {
					result = TRUE;
					_g_object_unref0 (e);
					return result;
				}
				_g_object_unref0 (e);
			}
		}
	}
	result = FALSE;
	return result;
}


static gint _greeter_list_compare_entry_gcompare_func (gconstpointer a, gconstpointer b) {
	gint result;
	result = greeter_list_compare_entry (a, b);
	return result;
}


static void greeter_list_real_insert_entry (GreeterList* self, PromptBox* entry) {
	PromptBox* _tmp0_ = NULL;
	PromptBox* _tmp1_ = NULL;
	g_return_if_fail (entry != NULL);
	_tmp0_ = entry;
	_tmp1_ = _g_object_ref0 (_tmp0_);
	self->entries = g_list_insert_sorted (self->entries, _tmp1_, _greeter_list_compare_entry_gcompare_func);
}


void greeter_list_insert_entry (GreeterList* self, PromptBox* entry) {
	g_return_if_fail (self != NULL);
	GREETER_LIST_GET_CLASS (self)->insert_entry (self, entry);
}


static void greeter_list_real_add_manual_entry (GreeterList* self) {
	g_critical ("Type `%s' does not implement abstract method `greeter_list_add_manual_entry'", g_type_name (G_TYPE_FROM_INSTANCE (self)));
	return;
}


void greeter_list_add_manual_entry (GreeterList* self) {
	g_return_if_fail (self != NULL);
	GREETER_LIST_GET_CLASS (self)->add_manual_entry (self);
}


static void _greeter_list_entry_clicked_cb_prompt_box_name_clicked (PromptBox* _sender, gpointer self) {
	greeter_list_entry_clicked_cb (self, _sender);
}


void greeter_list_add_entry (GreeterList* self, PromptBox* entry) {
	PromptBox* _tmp0_ = NULL;
	PromptBox* _tmp1_ = NULL;
	PromptBox* _tmp2_ = NULL;
	PromptBox* _tmp3_ = NULL;
	PromptBox* _tmp4_ = NULL;
	PromptBox* _tmp5_ = NULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (entry != NULL);
	_tmp0_ = entry;
	g_object_set ((GtkWidget*) _tmp0_, "expand", TRUE, NULL);
	_tmp1_ = entry;
	gtk_widget_set_size_request ((GtkWidget*) _tmp1_, (grid_size * GREETER_LIST_BOX_WIDTH) - (GREETER_LIST_BORDER * 2), -1);
	_tmp2_ = entry;
	greeter_list_add_with_class (self, (GtkWidget*) _tmp2_);
	_tmp3_ = entry;
	greeter_list_insert_entry (self, _tmp3_);
	_tmp4_ = entry;
	g_signal_connect_object (_tmp4_, "name-clicked", (GCallback) _greeter_list_entry_clicked_cb_prompt_box_name_clicked, self, 0);
	_tmp5_ = self->priv->_selected_entry;
	if (_tmp5_ == NULL) {
		PromptBox* _tmp6_ = NULL;
		_tmp6_ = entry;
		greeter_list_select_entry (self, _tmp6_, 1.0, TRUE);
	} else {
		PromptBox* _tmp7_ = NULL;
		_tmp7_ = self->priv->_selected_entry;
		greeter_list_select_entry (self, _tmp7_, 1.0, TRUE);
	}
	greeter_list_move_names (self);
}


void greeter_list_set_active_entry (GreeterList* self, const gchar* name) {
	PromptBox* e = NULL;
	const gchar* _tmp0_ = NULL;
	PromptBox* _tmp1_ = NULL;
	PromptBox* _tmp2_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = name;
	_tmp1_ = greeter_list_find_entry (self, _tmp0_);
	e = _tmp1_;
	_tmp2_ = e;
	if (_tmp2_ != NULL) {
		gdouble direction = 0.0;
		gboolean _tmp3_ = FALSE;
		PromptBox* _tmp4_ = NULL;
		gboolean _tmp11_ = FALSE;
		PromptBox* _tmp12_ = NULL;
		gdouble _tmp13_ = 0.0;
		direction = 1.0;
		_tmp4_ = self->priv->_selected_entry;
		if (_tmp4_ != NULL) {
			GList* _tmp5_ = NULL;
			PromptBox* _tmp6_ = NULL;
			gint _tmp7_ = 0;
			GList* _tmp8_ = NULL;
			PromptBox* _tmp9_ = NULL;
			gint _tmp10_ = 0;
			_tmp5_ = self->entries;
			_tmp6_ = self->priv->_selected_entry;
			_tmp7_ = g_list_index (_tmp5_, _tmp6_);
			_tmp8_ = self->entries;
			_tmp9_ = e;
			_tmp10_ = g_list_index (_tmp8_, _tmp9_);
			_tmp3_ = _tmp7_ > _tmp10_;
		} else {
			_tmp3_ = FALSE;
		}
		_tmp11_ = _tmp3_;
		if (_tmp11_) {
			direction = -1.0;
		}
		_tmp12_ = e;
		_tmp13_ = direction;
		greeter_list_select_entry (self, _tmp12_, _tmp13_, TRUE);
	}
	_g_object_unref0 (e);
}


void greeter_list_set_active_first_entry_with_prefix (GreeterList* self, const gchar* prefix) {
	GList* _tmp0_ = NULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (prefix != NULL);
	_tmp0_ = self->entries;
	{
		GList* e_collection = NULL;
		GList* e_it = NULL;
		e_collection = _tmp0_;
		for (e_it = e_collection; e_it != NULL; e_it = e_it->next) {
			PromptBox* _tmp1_ = NULL;
			PromptBox* e = NULL;
			_tmp1_ = _g_object_ref0 ((PromptBox*) e_it->data);
			e = _tmp1_;
			{
				PromptBox* _tmp2_ = NULL;
				const gchar* _tmp3_ = NULL;
				const gchar* _tmp4_ = NULL;
				const gchar* _tmp5_ = NULL;
				gboolean _tmp6_ = FALSE;
				_tmp2_ = e;
				_tmp3_ = prompt_box_get_id (_tmp2_);
				_tmp4_ = _tmp3_;
				_tmp5_ = prefix;
				_tmp6_ = g_str_has_prefix (_tmp4_, _tmp5_);
				if (_tmp6_) {
					PromptBox* _tmp7_ = NULL;
					_tmp7_ = e;
					greeter_list_select_entry (self, _tmp7_, 1.0, TRUE);
					_g_object_unref0 (e);
					break;
				}
				_g_object_unref0 (e);
			}
		}
	}
}


void greeter_list_remove_entry (GreeterList* self, const gchar* name) {
	const gchar* _tmp0_ = NULL;
	PromptBox* _tmp1_ = NULL;
	PromptBox* _tmp2_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = name;
	_tmp1_ = greeter_list_find_entry (self, _tmp0_);
	_tmp2_ = _tmp1_;
	greeter_list_remove_entry_by_entry (self, _tmp2_);
	_g_object_unref0 (_tmp2_);
}


void greeter_list_remove_entries_with_prefix (GreeterList* self, const gchar* prefix) {
	gint i = 0;
	g_return_if_fail (self != NULL);
	g_return_if_fail (prefix != NULL);
	i = 0;
	while (TRUE) {
		gint _tmp0_ = 0;
		GList* _tmp1_ = NULL;
		guint _tmp2_ = 0U;
		PromptBox* e = NULL;
		GList* _tmp3_ = NULL;
		gint _tmp4_ = 0;
		gconstpointer _tmp5_ = NULL;
		PromptBox* _tmp6_ = NULL;
		PromptBox* _tmp7_ = NULL;
		const gchar* _tmp8_ = NULL;
		const gchar* _tmp9_ = NULL;
		const gchar* _tmp10_ = NULL;
		gboolean _tmp11_ = FALSE;
		_tmp0_ = i;
		_tmp1_ = self->entries;
		_tmp2_ = g_list_length (_tmp1_);
		if (!(((guint) _tmp0_) < _tmp2_)) {
			break;
		}
		_tmp3_ = self->entries;
		_tmp4_ = i;
		_tmp5_ = g_list_nth_data (_tmp3_, (guint) _tmp4_);
		_tmp6_ = _g_object_ref0 ((PromptBox*) _tmp5_);
		e = _tmp6_;
		_tmp7_ = e;
		_tmp8_ = prompt_box_get_id (_tmp7_);
		_tmp9_ = _tmp8_;
		_tmp10_ = prefix;
		_tmp11_ = g_str_has_prefix (_tmp9_, _tmp10_);
		if (_tmp11_) {
			PromptBox* _tmp12_ = NULL;
			_tmp12_ = e;
			greeter_list_remove_entry_by_entry (self, _tmp12_);
		} else {
			gint _tmp13_ = 0;
			_tmp13_ = i;
			i = _tmp13_ + 1;
		}
		_g_object_unref0 (e);
	}
}


void greeter_list_remove_entry_by_entry (GreeterList* self, PromptBox* entry) {
	PromptBox* _tmp0_ = NULL;
	gint index = 0;
	GList* _tmp1_ = NULL;
	PromptBox* _tmp2_ = NULL;
	gint _tmp3_ = 0;
	PromptBox* _tmp4_ = NULL;
	PromptBox* _tmp5_ = NULL;
	PromptBox* _tmp6_ = NULL;
	PromptBox* _tmp7_ = NULL;
	gboolean _tmp25_ = FALSE;
	gboolean _tmp26_ = FALSE;
	gboolean _tmp29_ = FALSE;
	g_return_if_fail (self != NULL);
	_tmp0_ = entry;
	if (_tmp0_ == NULL) {
		return;
	}
	_tmp1_ = self->entries;
	_tmp2_ = entry;
	_tmp3_ = g_list_index (_tmp1_, _tmp2_);
	index = _tmp3_;
	_tmp4_ = entry;
	gtk_widget_destroy ((GtkWidget*) _tmp4_);
	_tmp5_ = entry;
	self->entries = g_list_remove (self->entries, _tmp5_);
	_tmp6_ = entry;
	_tmp7_ = self->priv->_selected_entry;
	if (_tmp6_ == _tmp7_) {
		gboolean _tmp8_ = FALSE;
		gint _tmp9_ = 0;
		GList* _tmp10_ = NULL;
		guint _tmp11_ = 0U;
		gboolean _tmp13_ = FALSE;
		GList* _tmp19_ = NULL;
		gint _tmp20_ = 0;
		gconstpointer _tmp21_ = NULL;
		_tmp9_ = index;
		_tmp10_ = self->entries;
		_tmp11_ = g_list_length (_tmp10_);
		if (((guint) _tmp9_) >= _tmp11_) {
			gint _tmp12_ = 0;
			_tmp12_ = index;
			_tmp8_ = _tmp12_ > 0;
		} else {
			_tmp8_ = FALSE;
		}
		_tmp13_ = _tmp8_;
		if (_tmp13_) {
			gint _tmp14_ = 0;
			_tmp14_ = index;
			index = _tmp14_ - 1;
		} else {
			gint _tmp15_ = 0;
			GList* _tmp16_ = NULL;
			guint _tmp17_ = 0U;
			_tmp15_ = index;
			_tmp16_ = self->entries;
			_tmp17_ = g_list_length (_tmp16_);
			if (((guint) _tmp15_) < _tmp17_) {
				gint _tmp18_ = 0;
				_tmp18_ = index;
				index = _tmp18_ + 1;
			}
		}
		_tmp19_ = self->entries;
		_tmp20_ = index;
		_tmp21_ = g_list_nth_data (_tmp19_, (guint) _tmp20_);
		if (((PromptBox*) _tmp21_) != NULL) {
			GList* _tmp22_ = NULL;
			gint _tmp23_ = 0;
			gconstpointer _tmp24_ = NULL;
			_tmp22_ = self->entries;
			_tmp23_ = index;
			_tmp24_ = g_list_nth_data (_tmp22_, (guint) _tmp23_);
			greeter_list_select_entry (self, (PromptBox*) _tmp24_, -1.0, TRUE);
		}
	}
	_tmp26_ = greeter_list_have_entries (self);
	if (!_tmp26_) {
		UnityGreeter* _tmp27_ = NULL;
		gboolean _tmp28_ = FALSE;
		_tmp27_ = unity_greeter_singleton;
		_tmp28_ = unity_greeter_show_remote_login_hint (_tmp27_);
		_tmp25_ = !_tmp28_;
	} else {
		_tmp25_ = FALSE;
	}
	_tmp29_ = _tmp25_;
	if (_tmp29_) {
		greeter_list_add_manual_entry (self);
	}
	gtk_widget_queue_draw ((GtkWidget*) self);
}


gint greeter_list_get_greeter_box_height (GreeterList* self) {
	gint result = 0;
	gint height = 0;
	DashBox* _tmp0_ = NULL;
	gint _tmp1_ = 0;
	g_return_val_if_fail (self != NULL, 0);
	_tmp0_ = self->greeter_box;
	gtk_widget_get_preferred_height ((GtkWidget*) _tmp0_, NULL, &_tmp1_);
	height = _tmp1_;
	result = height;
	return result;
}


gint greeter_list_get_greeter_box_height_grids (GreeterList* self) {
	gint result = 0;
	gint height = 0;
	gint _tmp0_ = 0;
	g_return_val_if_fail (self != NULL, 0);
	_tmp0_ = greeter_list_get_greeter_box_height (self);
	height = _tmp0_;
	result = (height / grid_size) + 1;
	return result;
}


gint greeter_list_get_greeter_box_x (GreeterList* self) {
	gint result = 0;
	gint _tmp0_ = 0;
	gint _tmp1_ = 0;
	g_return_val_if_fail (self != NULL, 0);
	_tmp0_ = greeter_list_get_box_x (self);
	_tmp1_ = _tmp0_;
	result = _tmp1_ + GREETER_LIST_BORDER;
	return result;
}


gint greeter_list_get_greeter_box_y (GreeterList* self) {
	gint result = 0;
	gint _tmp0_ = 0;
	gint _tmp1_ = 0;
	g_return_val_if_fail (self != NULL, 0);
	_tmp0_ = greeter_list_get_box_y (self);
	_tmp1_ = _tmp0_;
	result = _tmp1_ + GREETER_LIST_BORDER;
	return result;
}


static gint greeter_list_real_get_position_y (GreeterList* self, gdouble position) {
	gint result = 0;
	gint box_height = 0;
	gint _tmp0_ = 0;
	gdouble offset = 0.0;
	gdouble _tmp1_ = 0.0;
	gint _tmp8_ = 0;
	gint _tmp9_ = 0;
	gdouble _tmp10_ = 0.0;
	gdouble _tmp11_ = 0.0;
	_tmp0_ = greeter_list_get_greeter_box_height_grids (self);
	box_height = _tmp0_ * grid_size;
	_tmp1_ = position;
	if (_tmp1_ < ((gdouble) 0)) {
		gdouble _tmp2_ = 0.0;
		_tmp2_ = position;
		offset = _tmp2_ * grid_size;
	} else {
		gdouble _tmp3_ = 0.0;
		_tmp3_ = position;
		if (_tmp3_ < ((gdouble) 1)) {
			gdouble _tmp4_ = 0.0;
			gint _tmp5_ = 0;
			_tmp4_ = position;
			_tmp5_ = box_height;
			offset = _tmp4_ * _tmp5_;
		} else {
			gdouble _tmp6_ = 0.0;
			gint _tmp7_ = 0;
			_tmp6_ = position;
			_tmp7_ = box_height;
			offset = ((_tmp6_ - 1) * grid_size) + _tmp7_;
		}
	}
	_tmp8_ = greeter_list_get_box_y (self);
	_tmp9_ = _tmp8_;
	_tmp10_ = offset;
	_tmp11_ = round (_tmp10_);
	result = _tmp9_ + ((gint) _tmp11_);
	return result;
}


gint greeter_list_get_position_y (GreeterList* self, gdouble position) {
	g_return_val_if_fail (self != NULL, 0);
	return GREETER_LIST_GET_CLASS (self)->get_position_y (self, position);
}


static void greeter_list_move_entry (GreeterList* self, PromptBox* entry, gdouble position) {
	gdouble alpha = 0.0;
	gdouble _tmp0_ = 0.0;
	PromptBox* _tmp5_ = NULL;
	gdouble _tmp6_ = 0.0;
	PromptBox* _tmp7_ = NULL;
	gdouble _tmp8_ = 0.0;
	GtkAllocation allocation = {0};
	GtkAllocation _tmp9_ = {0};
	GtkAllocation child_allocation = {0};
	PromptBox* _tmp10_ = NULL;
	GtkAllocation _tmp11_ = {0};
	gint _tmp12_ = 0;
	gint _tmp13_ = 0;
	GtkAllocation _tmp14_ = {0};
	gint _tmp15_ = 0;
	gint _tmp16_ = 0;
	GtkAllocation _tmp17_ = {0};
	gint _tmp18_ = 0;
	gdouble _tmp19_ = 0.0;
	gint _tmp20_ = 0;
	GtkFixed* _tmp21_ = NULL;
	PromptBox* _tmp22_ = NULL;
	GtkAllocation _tmp23_ = {0};
	gint _tmp24_ = 0;
	GtkAllocation _tmp25_ = {0};
	gint _tmp26_ = 0;
	PromptBox* _tmp27_ = NULL;
	GtkAllocation _tmp28_ = {0};
	g_return_if_fail (self != NULL);
	g_return_if_fail (entry != NULL);
	alpha = 1.0;
	_tmp0_ = position;
	if (_tmp0_ < ((gdouble) 0)) {
		gdouble _tmp1_ = 0.0;
		guint _tmp2_ = 0U;
		_tmp1_ = position;
		_tmp2_ = self->priv->n_above;
		alpha = 1.0 + (_tmp1_ / (_tmp2_ + 1));
	} else {
		gdouble _tmp3_ = 0.0;
		guint _tmp4_ = 0U;
		_tmp3_ = position;
		_tmp4_ = self->priv->n_below;
		alpha = 1.0 - (_tmp3_ / (_tmp4_ + 1));
	}
	_tmp5_ = entry;
	_tmp6_ = alpha;
	fadable_set_alpha ((Fadable*) _tmp5_, _tmp6_);
	_tmp7_ = entry;
	_tmp8_ = position;
	prompt_box_set_position (_tmp7_, _tmp8_);
	gtk_widget_get_allocation ((GtkWidget*) self, &_tmp9_);
	allocation = _tmp9_;
	memset (&child_allocation, 0, sizeof (GtkAllocation));
	child_allocation.width = (grid_size * GREETER_LIST_BOX_WIDTH) - (GREETER_LIST_BORDER * 2);
	_tmp10_ = entry;
	_tmp11_ = child_allocation;
	_tmp12_ = _tmp11_.width;
	gtk_widget_get_preferred_height_for_width ((GtkWidget*) _tmp10_, _tmp12_, NULL, &_tmp13_);
	child_allocation.height = _tmp13_;
	_tmp14_ = allocation;
	_tmp15_ = _tmp14_.x;
	_tmp16_ = greeter_list_get_greeter_box_x (self);
	child_allocation.x = _tmp15_ + _tmp16_;
	_tmp17_ = allocation;
	_tmp18_ = _tmp17_.y;
	_tmp19_ = position;
	_tmp20_ = greeter_list_get_position_y (self, _tmp19_);
	child_allocation.y = _tmp18_ + _tmp20_;
	_tmp21_ = self->priv->fixed;
	_tmp22_ = entry;
	_tmp23_ = child_allocation;
	_tmp24_ = _tmp23_.x;
	_tmp25_ = child_allocation;
	_tmp26_ = _tmp25_.y;
	gtk_fixed_move (_tmp21_, (GtkWidget*) _tmp22_, _tmp24_, _tmp26_);
	_tmp27_ = entry;
	_tmp28_ = child_allocation;
	gtk_widget_size_allocate ((GtkWidget*) _tmp27_, &_tmp28_);
}


static gboolean ___lambda59_ (GreeterList* self) {
	gboolean result = FALSE;
	greeter_list_move_names (self);
	result = FALSE;
	return result;
}


static gboolean ____lambda59__gsource_func (gpointer self) {
	gboolean result;
	result = ___lambda59_ (self);
	return result;
}


void greeter_list_greeter_box_size_allocate_cb (GreeterList* self, GtkAllocation* allocation) {
	gboolean _tmp0_ = FALSE;
	PromptBox* _tmp1_ = NULL;
	PromptBox* _tmp2_ = NULL;
	gboolean _tmp6_ = FALSE;
	GtkAllocation _tmp7_ = {0};
	gint _tmp8_ = 0;
	g_return_if_fail (self != NULL);
	g_return_if_fail (allocation != NULL);
	_tmp1_ = greeter_list_get_scrolling_entry (self);
	_tmp2_ = _tmp1_;
	if (_tmp2_ == NULL) {
		GtkAllocation _tmp3_ = {0};
		gint _tmp4_ = 0;
		gint _tmp5_ = 0;
		_tmp3_ = *allocation;
		_tmp4_ = _tmp3_.height;
		_tmp5_ = self->priv->cached_box_height;
		_tmp0_ = _tmp4_ != _tmp5_;
	} else {
		_tmp0_ = FALSE;
	}
	_tmp6_ = _tmp0_;
	if (_tmp6_) {
		g_idle_add_full (G_PRIORITY_DEFAULT_IDLE, ____lambda59__gsource_func, g_object_ref (self), g_object_unref);
	}
	_tmp7_ = *allocation;
	_tmp8_ = _tmp7_.height;
	self->priv->cached_box_height = _tmp8_;
}


void greeter_list_move_names (GreeterList* self) {
	gint index = 0;
	GList* _tmp0_ = NULL;
	g_return_if_fail (self != NULL);
	index = 0;
	_tmp0_ = self->entries;
	{
		GList* entry_collection = NULL;
		GList* entry_it = NULL;
		entry_collection = _tmp0_;
		for (entry_it = entry_collection; entry_it != NULL; entry_it = entry_it->next) {
			PromptBox* _tmp1_ = NULL;
			PromptBox* entry = NULL;
			_tmp1_ = _g_object_ref0 ((PromptBox*) entry_it->data);
			entry = _tmp1_;
			{
				gdouble position = 0.0;
				gint _tmp2_ = 0;
				gdouble _tmp3_ = 0.0;
				gboolean _tmp4_ = FALSE;
				gdouble _tmp5_ = 0.0;
				guint _tmp6_ = 0U;
				gboolean _tmp9_ = FALSE;
				gint _tmp26_ = 0;
				_tmp2_ = index;
				_tmp3_ = self->priv->scroll_location;
				position = _tmp2_ - _tmp3_;
				_tmp5_ = position;
				_tmp6_ = self->priv->n_above;
				if (_tmp5_ > ((gdouble) ((-1) * ((gint) (_tmp6_ + 1))))) {
					gdouble _tmp7_ = 0.0;
					guint _tmp8_ = 0U;
					_tmp7_ = position;
					_tmp8_ = self->priv->n_below;
					_tmp4_ = _tmp7_ < ((gdouble) (_tmp8_ + 1));
				} else {
					_tmp4_ = FALSE;
				}
				_tmp9_ = _tmp4_;
				if (_tmp9_) {
					PromptBox* _tmp10_ = NULL;
					gdouble _tmp11_ = 0.0;
					gboolean _tmp12_ = FALSE;
					gboolean _tmp13_ = FALSE;
					gdouble _tmp14_ = 0.0;
					gboolean _tmp18_ = FALSE;
					gboolean is_hidden = FALSE;
					gboolean _tmp22_ = FALSE;
					gboolean _tmp23_ = FALSE;
					_tmp10_ = entry;
					_tmp11_ = position;
					greeter_list_move_entry (self, _tmp10_, _tmp11_);
					_tmp14_ = position;
					if (_tmp14_ == ((gdouble) 0)) {
						DashBox* _tmp15_ = NULL;
						gboolean _tmp16_ = FALSE;
						gboolean _tmp17_ = FALSE;
						_tmp15_ = self->greeter_box;
						_tmp16_ = dash_box_get_has_base (_tmp15_);
						_tmp17_ = _tmp16_;
						_tmp13_ = _tmp17_;
					} else {
						_tmp13_ = FALSE;
					}
					_tmp18_ = _tmp13_;
					if (_tmp18_) {
						DashBox* _tmp19_ = NULL;
						gdouble _tmp20_ = 0.0;
						gdouble _tmp21_ = 0.0;
						_tmp19_ = self->greeter_box;
						_tmp20_ = dash_box_get_base_alpha (_tmp19_);
						_tmp21_ = _tmp20_;
						_tmp12_ = _tmp21_ == 0.0;
					} else {
						_tmp12_ = FALSE;
					}
					_tmp22_ = _tmp12_;
					is_hidden = _tmp22_;
					_tmp23_ = is_hidden;
					if (!_tmp23_) {
						PromptBox* _tmp24_ = NULL;
						_tmp24_ = entry;
						gtk_widget_show ((GtkWidget*) _tmp24_);
					}
				} else {
					PromptBox* _tmp25_ = NULL;
					_tmp25_ = entry;
					gtk_widget_hide ((GtkWidget*) _tmp25_);
				}
				_tmp26_ = index;
				index = _tmp26_ + 1;
				_g_object_unref0 (entry);
			}
		}
	}
	gtk_widget_queue_draw ((GtkWidget*) self);
}


static void greeter_list_animate_scrolling (GreeterList* self, gdouble progress) {
	guint h = 0U;
	GList* _tmp0_ = NULL;
	guint _tmp1_ = 0U;
	gdouble distance = 0.0;
	gdouble _tmp2_ = 0.0;
	gdouble _tmp3_ = 0.0;
	gdouble _tmp4_ = 0.0;
	gdouble _tmp5_ = 0.0;
	gdouble _tmp9_ = 0.0;
	gdouble _tmp10_ = 0.0;
	gdouble _tmp11_ = 0.0;
	gdouble _tmp12_ = 0.0;
	gdouble _tmp13_ = 0.0;
	guint _tmp14_ = 0U;
	gdouble _tmp17_ = 0.0;
	gboolean _tmp20_ = FALSE;
	gdouble _tmp21_ = 0.0;
	gboolean _tmp25_ = FALSE;
	gdouble _tmp26_ = 0.0;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->entries;
	_tmp1_ = g_list_length (_tmp0_);
	h = _tmp1_;
	_tmp2_ = self->priv->scroll_target_location;
	_tmp3_ = self->priv->scroll_start_location;
	distance = _tmp2_ - _tmp3_;
	_tmp4_ = self->priv->scroll_direction;
	_tmp5_ = distance;
	if ((_tmp4_ * _tmp5_) < ((gdouble) 0)) {
		gdouble _tmp6_ = 0.0;
		gdouble _tmp7_ = 0.0;
		guint _tmp8_ = 0U;
		_tmp6_ = distance;
		_tmp7_ = self->priv->scroll_direction;
		_tmp8_ = h;
		distance = _tmp6_ + (_tmp7_ * _tmp8_);
	}
	_tmp9_ = distance;
	_tmp10_ = progress;
	distance = _tmp9_ * _tmp10_;
	_tmp11_ = self->priv->scroll_start_location;
	_tmp12_ = distance;
	self->priv->scroll_location = _tmp11_ + _tmp12_;
	_tmp13_ = self->priv->scroll_location;
	_tmp14_ = h;
	if (_tmp13_ > ((gdouble) _tmp14_)) {
		gdouble _tmp15_ = 0.0;
		guint _tmp16_ = 0U;
		_tmp15_ = self->priv->scroll_location;
		_tmp16_ = h;
		self->priv->scroll_location = _tmp15_ - _tmp16_;
	}
	_tmp17_ = self->priv->scroll_location;
	if (_tmp17_ < ((gdouble) 0)) {
		gdouble _tmp18_ = 0.0;
		guint _tmp19_ = 0U;
		_tmp18_ = self->priv->scroll_location;
		_tmp19_ = h;
		self->priv->scroll_location = _tmp18_ + _tmp19_;
	}
	greeter_list_move_names (self);
	_tmp21_ = progress;
	if (_tmp21_ >= 0.975) {
		DashBox* _tmp22_ = NULL;
		gboolean _tmp23_ = FALSE;
		gboolean _tmp24_ = FALSE;
		_tmp22_ = self->greeter_box;
		_tmp23_ = dash_box_get_has_base (_tmp22_);
		_tmp24_ = _tmp23_;
		_tmp20_ = !_tmp24_;
	} else {
		_tmp20_ = FALSE;
	}
	_tmp25_ = _tmp20_;
	if (_tmp25_) {
		greeter_list_setup_prompt_box (self, TRUE);
		g_signal_emit_by_name (self, "entry-displayed-start");
	}
	_tmp26_ = progress;
	if (_tmp26_ >= 1.0) {
		greeter_list_finished_scrolling (self);
	}
}


static void greeter_list_finished_scrolling (GreeterList* self) {
	PromptBox* _tmp0_ = NULL;
	g_return_if_fail (self != NULL);
	greeter_list_set_scrolling_entry (self, NULL);
	_tmp0_ = self->priv->_selected_entry;
	prompt_box_show_prompts (_tmp0_);
	greeter_list_focus_prompt (self);
	g_signal_emit_by_name (self, "entry-displayed-done");
	self->mode = GREETER_LIST_MODE_ENTRY;
}


void greeter_list_select_entry (GreeterList* self, PromptBox* entry, gdouble direction, gboolean do_scroll) {
	gboolean _tmp0_ = FALSE;
	gdouble _tmp2_ = 0.0;
	GList* _tmp3_ = NULL;
	PromptBox* _tmp4_ = NULL;
	gint _tmp5_ = 0;
	PromptBox* _tmp27_ = NULL;
	PromptBox* _tmp28_ = NULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (entry != NULL);
	_tmp0_ = gtk_widget_get_realized ((GtkWidget*) self);
	if (!_tmp0_) {
		PromptBox* _tmp1_ = NULL;
		_tmp1_ = entry;
		greeter_list_set_selected_entry (self, _tmp1_);
		return;
	}
	_tmp2_ = self->priv->scroll_target_location;
	_tmp3_ = self->entries;
	_tmp4_ = entry;
	_tmp5_ = g_list_index (_tmp3_, _tmp4_);
	if (_tmp2_ != ((gdouble) _tmp5_)) {
		gint new_target = 0;
		GList* _tmp6_ = NULL;
		PromptBox* _tmp7_ = NULL;
		gint _tmp8_ = 0;
		gdouble new_direction = 0.0;
		gdouble _tmp9_ = 0.0;
		gdouble new_start = 0.0;
		gdouble _tmp10_ = 0.0;
		gboolean _tmp11_ = FALSE;
		gdouble _tmp12_ = 0.0;
		gint _tmp13_ = 0;
		gboolean _tmp15_ = FALSE;
		PromptBox* _tmp23_ = NULL;
		gint _tmp24_ = 0;
		gdouble _tmp25_ = 0.0;
		gdouble _tmp26_ = 0.0;
		_tmp6_ = self->entries;
		_tmp7_ = entry;
		_tmp8_ = g_list_index (_tmp6_, _tmp7_);
		new_target = _tmp8_;
		_tmp9_ = direction;
		new_direction = _tmp9_;
		_tmp10_ = self->priv->scroll_location;
		new_start = _tmp10_;
		_tmp12_ = self->priv->scroll_location;
		_tmp13_ = new_target;
		if (_tmp12_ != ((gdouble) _tmp13_)) {
			gboolean _tmp14_ = FALSE;
			_tmp14_ = do_scroll;
			_tmp11_ = _tmp14_;
		} else {
			_tmp11_ = FALSE;
		}
		_tmp15_ = _tmp11_;
		if (_tmp15_) {
			gdouble new_distance = 0.0;
			gdouble _tmp16_ = 0.0;
			gint _tmp17_ = 0;
			gdouble _tmp18_ = 0.0;
			AnimateTimer* _tmp19_ = NULL;
			gdouble _tmp20_ = 0.0;
			gdouble _tmp21_ = 0.0;
			gint _tmp22_ = 0;
			_tmp16_ = new_direction;
			_tmp17_ = new_target;
			_tmp18_ = new_start;
			new_distance = _tmp16_ * (_tmp17_ - _tmp18_);
			_tmp19_ = self->priv->scroll_timer;
			_tmp20_ = new_distance;
			_tmp21_ = fabs (_tmp20_);
			_tmp22_ = MIN ((gint) (100 * _tmp21_), 500);
			animate_timer_reset (_tmp19_, 250 + _tmp22_);
			self->mode = GREETER_LIST_MODE_SCROLLING;
		}
		_tmp23_ = self->priv->_selected_entry;
		greeter_list_set_scrolling_entry (self, _tmp23_);
		_tmp24_ = new_target;
		self->priv->scroll_target_location = (gdouble) _tmp24_;
		_tmp25_ = new_direction;
		self->priv->scroll_direction = _tmp25_;
		_tmp26_ = new_start;
		self->priv->scroll_start_location = _tmp26_;
	}
	_tmp27_ = self->priv->_selected_entry;
	_tmp28_ = entry;
	if (_tmp27_ != _tmp28_) {
		DashBox* _tmp29_ = NULL;
		PromptBox* _tmp30_ = NULL;
		PromptBox* _tmp32_ = NULL;
		PromptBox* _tmp33_ = NULL;
		const gchar* _tmp34_ = NULL;
		const gchar* _tmp35_ = NULL;
		GreeterListMode _tmp36_ = 0;
		_tmp29_ = self->greeter_box;
		dash_box_set_base (_tmp29_, NULL);
		_tmp30_ = self->priv->_selected_entry;
		if (_tmp30_ != NULL) {
			PromptBox* _tmp31_ = NULL;
			_tmp31_ = self->priv->_selected_entry;
			prompt_box_clear (_tmp31_);
		}
		_tmp32_ = entry;
		greeter_list_set_selected_entry (self, _tmp32_);
		_tmp33_ = self->priv->_selected_entry;
		_tmp34_ = prompt_box_get_id (_tmp33_);
		_tmp35_ = _tmp34_;
		g_signal_emit_by_name (self, "entry-selected", _tmp35_);
		_tmp36_ = self->mode;
		if (_tmp36_ == GREETER_LIST_MODE_ENTRY) {
			AnimateTimer* _tmp37_ = NULL;
			greeter_list_setup_prompt_box (self, TRUE);
			_tmp37_ = self->priv->scroll_timer;
			animate_timer_reset (_tmp37_, 0);
		}
	}
}


static void greeter_list_real_setup_prompt_box (GreeterList* self, gboolean fade) {
	DashBox* _tmp0_ = NULL;
	PromptBox* _tmp1_ = NULL;
	PromptBox* _tmp2_ = NULL;
	gboolean _tmp3_ = FALSE;
	_tmp0_ = self->greeter_box;
	_tmp1_ = self->priv->_selected_entry;
	dash_box_set_base (_tmp0_, (GtkWidget*) _tmp1_);
	_tmp2_ = self->priv->_selected_entry;
	prompt_box_add_static_prompts (_tmp2_);
	_tmp3_ = fade;
	if (_tmp3_) {
		PromptBox* _tmp4_ = NULL;
		_tmp4_ = self->priv->_selected_entry;
		prompt_box_fade_in_prompts (_tmp4_);
	} else {
		PromptBox* _tmp5_ = NULL;
		_tmp5_ = self->priv->_selected_entry;
		prompt_box_show_prompts (_tmp5_);
	}
}


void greeter_list_setup_prompt_box (GreeterList* self, gboolean fade) {
	g_return_if_fail (self != NULL);
	GREETER_LIST_GET_CLASS (self)->setup_prompt_box (self, fade);
}


static void greeter_list_real_realize (GtkWidget* base) {
	GreeterList * self;
	PromptBox* saved_entry = NULL;
	PromptBox* _tmp0_ = NULL;
	PromptBox* _tmp1_ = NULL;
	gboolean _tmp2_ = FALSE;
	self = (GreeterList*) base;
	GTK_WIDGET_CLASS (greeter_list_parent_class)->realize ((GtkWidget*) G_TYPE_CHECK_INSTANCE_CAST (self, TYPE_FADABLE_BOX, FadableBox));
	_tmp0_ = self->priv->_selected_entry;
	_tmp1_ = _g_object_ref0 (_tmp0_);
	saved_entry = _tmp1_;
	greeter_list_set_selected_entry (self, NULL);
	_tmp2_ = self->priv->_start_scrolling;
	greeter_list_select_entry (self, saved_entry, (gdouble) 1, _tmp2_);
	greeter_list_move_names (self);
	_g_object_unref0 (saved_entry);
}


static void greeter_list_allocate_greeter_box (GreeterList* self) {
	GtkAllocation allocation = {0};
	GtkAllocation _tmp0_ = {0};
	GtkAllocation child_allocation = {0};
	DashBox* _tmp1_ = NULL;
	gint _tmp2_ = 0;
	DashBox* _tmp3_ = NULL;
	gint _tmp4_ = 0;
	GtkAllocation _tmp5_ = {0};
	gint _tmp6_ = 0;
	gint _tmp7_ = 0;
	GtkAllocation _tmp8_ = {0};
	gint _tmp9_ = 0;
	gint _tmp10_ = 0;
	GtkFixed* _tmp11_ = NULL;
	DashBox* _tmp12_ = NULL;
	GtkAllocation _tmp13_ = {0};
	gint _tmp14_ = 0;
	GtkAllocation _tmp15_ = {0};
	gint _tmp16_ = 0;
	DashBox* _tmp17_ = NULL;
	GtkAllocation _tmp18_ = {0};
	GList* _tmp19_ = NULL;
	g_return_if_fail (self != NULL);
	gtk_widget_get_allocation ((GtkWidget*) self, &_tmp0_);
	allocation = _tmp0_;
	memset (&child_allocation, 0, sizeof (GtkAllocation));
	_tmp1_ = self->greeter_box;
	gtk_widget_get_preferred_width ((GtkWidget*) _tmp1_, NULL, &_tmp2_);
	child_allocation.width = _tmp2_;
	_tmp3_ = self->greeter_box;
	gtk_widget_get_preferred_height ((GtkWidget*) _tmp3_, NULL, &_tmp4_);
	child_allocation.height = _tmp4_;
	_tmp5_ = allocation;
	_tmp6_ = _tmp5_.x;
	_tmp7_ = greeter_list_get_greeter_box_x (self);
	child_allocation.x = _tmp6_ + _tmp7_;
	_tmp8_ = allocation;
	_tmp9_ = _tmp8_.y;
	_tmp10_ = greeter_list_get_greeter_box_y (self);
	child_allocation.y = _tmp9_ + _tmp10_;
	_tmp11_ = self->priv->fixed;
	_tmp12_ = self->greeter_box;
	_tmp13_ = child_allocation;
	_tmp14_ = _tmp13_.x;
	_tmp15_ = child_allocation;
	_tmp16_ = _tmp15_.y;
	gtk_fixed_move (_tmp11_, (GtkWidget*) _tmp12_, _tmp14_, _tmp16_);
	_tmp17_ = self->greeter_box;
	_tmp18_ = child_allocation;
	gtk_widget_size_allocate ((GtkWidget*) _tmp17_, &_tmp18_);
	_tmp19_ = self->entries;
	{
		GList* entry_collection = NULL;
		GList* entry_it = NULL;
		entry_collection = _tmp19_;
		for (entry_it = entry_collection; entry_it != NULL; entry_it = entry_it->next) {
			PromptBox* _tmp20_ = NULL;
			PromptBox* entry = NULL;
			_tmp20_ = _g_object_ref0 ((PromptBox*) entry_it->data);
			entry = _tmp20_;
			{
				PromptBox* _tmp21_ = NULL;
				DashBox* _tmp22_ = NULL;
				_tmp21_ = entry;
				_tmp22_ = self->greeter_box;
				prompt_box_set_zone (_tmp21_, (GtkWidget*) _tmp22_);
				_g_object_unref0 (entry);
			}
		}
	}
}


static void greeter_list_real_size_allocate (GtkWidget* base, GtkAllocation* allocation) {
	GreeterList * self;
	GtkAllocation _tmp0_ = {0};
	gboolean _tmp1_ = FALSE;
	self = (GreeterList*) base;
	g_return_if_fail (allocation != NULL);
	_tmp0_ = *allocation;
	GTK_WIDGET_CLASS (greeter_list_parent_class)->size_allocate ((GtkWidget*) G_TYPE_CHECK_INSTANCE_CAST (self, TYPE_FADABLE_BOX, FadableBox), &_tmp0_);
	_tmp1_ = gtk_widget_get_realized ((GtkWidget*) self);
	if (!_tmp1_) {
		return;
	}
	greeter_list_allocate_greeter_box (self);
	greeter_list_move_names (self);
}


static gboolean greeter_list_real_draw (GtkWidget* base, cairo_t* c) {
	GreeterList * self;
	gboolean result = FALSE;
	cairo_t* _tmp0_ = NULL;
	cairo_t* _tmp1_ = NULL;
	GtkFixed* _tmp2_ = NULL;
	DashBox* _tmp3_ = NULL;
	cairo_t* _tmp4_ = NULL;
	cairo_t* _tmp5_ = NULL;
	DashBox* _tmp6_ = NULL;
	gdouble _tmp7_ = 0.0;
	gdouble _tmp8_ = 0.0;
	cairo_t* _tmp32_ = NULL;
	cairo_t* _tmp33_ = NULL;
	FadeTracker* _tmp34_ = NULL;
	FadeTracker* _tmp35_ = NULL;
	gdouble _tmp36_ = 0.0;
	gdouble _tmp37_ = 0.0;
	self = (GreeterList*) base;
	g_return_val_if_fail (c != NULL, FALSE);
	_tmp0_ = c;
	cairo_push_group (_tmp0_);
	_tmp1_ = c;
	cairo_save (_tmp1_);
	_tmp2_ = self->priv->fixed;
	_tmp3_ = self->greeter_box;
	_tmp4_ = c;
	gtk_container_propagate_draw ((GtkContainer*) _tmp2_, (GtkWidget*) _tmp3_, _tmp4_);
	_tmp5_ = c;
	cairo_restore (_tmp5_);
	_tmp6_ = self->greeter_box;
	_tmp7_ = dash_box_get_base_alpha (_tmp6_);
	_tmp8_ = _tmp7_;
	if (_tmp8_ != 0.0) {
		cairo_t* _tmp9_ = NULL;
		cairo_t* _tmp10_ = NULL;
		cairo_t* _tmp11_ = NULL;
		gint _tmp12_ = 0;
		gint _tmp13_ = 0;
		guint _tmp14_ = 0U;
		guint _tmp15_ = 0U;
		guint _tmp16_ = 0U;
		gint _tmp17_ = 0;
		cairo_t* _tmp18_ = NULL;
		GtkFixed* _tmp19_ = NULL;
		GList* _tmp20_ = NULL;
		cairo_t* _tmp26_ = NULL;
		cairo_t* _tmp27_ = NULL;
		DashBox* _tmp28_ = NULL;
		gdouble _tmp29_ = 0.0;
		gdouble _tmp30_ = 0.0;
		cairo_t* _tmp31_ = NULL;
		_tmp9_ = c;
		cairo_save (_tmp9_);
		_tmp10_ = c;
		cairo_push_group (_tmp10_);
		_tmp11_ = c;
		_tmp12_ = greeter_list_get_greeter_box_x (self);
		_tmp13_ = greeter_list_get_greeter_box_y (self);
		_tmp14_ = self->priv->n_above;
		_tmp15_ = self->priv->n_above;
		_tmp16_ = self->priv->n_below;
		_tmp17_ = greeter_list_get_greeter_box_height_grids (self);
		cairo_rectangle (_tmp11_, (gdouble) _tmp12_, (gdouble) (_tmp13_ - (_tmp14_ * grid_size)), (gdouble) ((grid_size * GREETER_LIST_BOX_WIDTH) - (GREETER_LIST_BORDER * 2)), (gdouble) (grid_size * ((_tmp15_ + _tmp16_) + _tmp17_)));
		_tmp18_ = c;
		cairo_clip (_tmp18_);
		_tmp19_ = self->priv->fixed;
		_tmp20_ = gtk_container_get_children ((GtkContainer*) _tmp19_);
		{
			GList* child_collection = NULL;
			GList* child_it = NULL;
			child_collection = _tmp20_;
			for (child_it = child_collection; child_it != NULL; child_it = child_it->next) {
				GtkWidget* child = NULL;
				child = (GtkWidget*) child_it->data;
				{
					GtkWidget* _tmp21_ = NULL;
					DashBox* _tmp22_ = NULL;
					_tmp21_ = child;
					_tmp22_ = self->greeter_box;
					if (_tmp21_ != G_TYPE_CHECK_INSTANCE_CAST (_tmp22_, GTK_TYPE_WIDGET, GtkWidget)) {
						GtkFixed* _tmp23_ = NULL;
						GtkWidget* _tmp24_ = NULL;
						cairo_t* _tmp25_ = NULL;
						_tmp23_ = self->priv->fixed;
						_tmp24_ = child;
						_tmp25_ = c;
						gtk_container_propagate_draw ((GtkContainer*) _tmp23_, _tmp24_, _tmp25_);
					}
				}
			}
			_g_list_free0 (child_collection);
		}
		_tmp26_ = c;
		cairo_pop_group_to_source (_tmp26_);
		_tmp27_ = c;
		_tmp28_ = self->greeter_box;
		_tmp29_ = dash_box_get_base_alpha (_tmp28_);
		_tmp30_ = _tmp29_;
		cairo_paint_with_alpha (_tmp27_, _tmp30_);
		_tmp31_ = c;
		cairo_restore (_tmp31_);
	}
	_tmp32_ = c;
	cairo_pop_group_to_source (_tmp32_);
	_tmp33_ = c;
	_tmp34_ = fadable_get_fade_tracker ((Fadable*) self);
	_tmp35_ = _tmp34_;
	_tmp36_ = fade_tracker_get_alpha (_tmp35_);
	_tmp37_ = _tmp36_;
	cairo_paint_with_alpha (_tmp33_, _tmp37_);
	result = FALSE;
	return result;
}


static void greeter_list_entry_clicked_cb (GreeterList* self, PromptBox* entry) {
	GreeterListMode _tmp0_ = 0;
	gint index = 0;
	GList* _tmp1_ = NULL;
	PromptBox* _tmp2_ = NULL;
	gint _tmp3_ = 0;
	gdouble position = 0.0;
	gint _tmp4_ = 0;
	gdouble _tmp5_ = 0.0;
	gdouble _tmp6_ = 0.0;
	g_return_if_fail (self != NULL);
	g_return_if_fail (entry != NULL);
	_tmp0_ = self->mode;
	if (_tmp0_ != GREETER_LIST_MODE_ENTRY) {
		return;
	}
	_tmp1_ = self->entries;
	_tmp2_ = entry;
	_tmp3_ = g_list_index (_tmp1_, _tmp2_);
	index = _tmp3_;
	_tmp4_ = index;
	_tmp5_ = self->priv->scroll_location;
	position = _tmp4_ - _tmp5_;
	_tmp6_ = position;
	if (_tmp6_ < 0.0) {
		PromptBox* _tmp7_ = NULL;
		_tmp7_ = entry;
		greeter_list_select_entry (self, _tmp7_, -1.0, TRUE);
	} else {
		gdouble _tmp8_ = 0.0;
		_tmp8_ = position;
		if (_tmp8_ >= 1.0) {
			PromptBox* _tmp9_ = NULL;
			_tmp9_ = entry;
			greeter_list_select_entry (self, _tmp9_, 1.0, TRUE);
		}
	}
}


static void _greeter_list_show_message_cb_unity_greeter_show_message (UnityGreeter* _sender, const gchar* text, LightDMMessageType type, gpointer self) {
	greeter_list_show_message_cb (self, text, type);
}


static void _greeter_list_show_prompt_cb_unity_greeter_show_prompt (UnityGreeter* _sender, const gchar* text, LightDMPromptType type, gpointer self) {
	greeter_list_show_prompt_cb (self, text, type);
}


static void _greeter_list_authentication_complete_cb_unity_greeter_authentication_complete (UnityGreeter* _sender, gpointer self) {
	greeter_list_authentication_complete_cb (self);
}


void greeter_list_connect_to_lightdm (GreeterList* self) {
	UnityGreeter* _tmp0_ = NULL;
	UnityGreeter* _tmp1_ = NULL;
	UnityGreeter* _tmp2_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = unity_greeter_singleton;
	g_signal_connect_object (_tmp0_, "show-message", (GCallback) _greeter_list_show_message_cb_unity_greeter_show_message, self, 0);
	_tmp1_ = unity_greeter_singleton;
	g_signal_connect_object (_tmp1_, "show-prompt", (GCallback) _greeter_list_show_prompt_cb_unity_greeter_show_prompt, self, 0);
	_tmp2_ = unity_greeter_singleton;
	g_signal_connect_object (_tmp2_, "authentication-complete", (GCallback) _greeter_list_authentication_complete_cb_unity_greeter_authentication_complete, self, 0);
}


void greeter_list_show_message_cb (GreeterList* self, const gchar* text, LightDMMessageType type) {
	const gchar* _tmp0_ = NULL;
	LightDMMessageType _tmp1_ = 0;
	g_return_if_fail (self != NULL);
	g_return_if_fail (text != NULL);
	self->unacknowledged_messages = TRUE;
	_tmp0_ = text;
	_tmp1_ = type;
	greeter_list_show_message (self, _tmp0_, _tmp1_ == LIGHTDM_MESSAGE_TYPE_ERROR);
}


static void greeter_list_real_show_prompt_cb (GreeterList* self, const gchar* text, LightDMPromptType type) {
	gboolean _tmp0_ = FALSE;
	gchar* _tmp1_ = NULL;
	gchar* _tmp2_ = NULL;
	gboolean _tmp3_ = FALSE;
	gboolean _tmp6_ = FALSE;
	const gchar* _tmp13_ = NULL;
	const gchar* _tmp15_ = NULL;
	const gchar* _tmp17_ = NULL;
	LightDMPromptType _tmp18_ = 0;
	DashEntry* _tmp19_ = NULL;
	DashEntry* _tmp20_ = NULL;
	g_return_if_fail (text != NULL);
	_tmp1_ = greeter_list_get_selected_id (self);
	_tmp2_ = _tmp1_;
	_tmp3_ = g_strcmp0 (_tmp2_, "*other") == 0;
	_g_free0 (_tmp2_);
	if (_tmp3_) {
		const gchar* _tmp4_ = NULL;
		const gchar* _tmp5_ = NULL;
		_tmp4_ = greeter_list_get_manual_name (self);
		_tmp5_ = _tmp4_;
		_tmp0_ = _tmp5_ == NULL;
	} else {
		_tmp0_ = FALSE;
	}
	_tmp6_ = _tmp0_;
	if (_tmp6_) {
		UnityGreeter* _tmp7_ = NULL;
		gboolean _tmp8_ = FALSE;
		_tmp7_ = unity_greeter_singleton;
		_tmp8_ = _tmp7_->test_mode;
		if (_tmp8_) {
			const gchar* _tmp9_ = NULL;
			_tmp9_ = self->test_username;
			greeter_list_set_manual_name (self, _tmp9_);
		} else {
			UnityGreeter* _tmp10_ = NULL;
			gchar* _tmp11_ = NULL;
			gchar* _tmp12_ = NULL;
			_tmp10_ = unity_greeter_singleton;
			_tmp11_ = unity_greeter_authentication_user (_tmp10_);
			_tmp12_ = _tmp11_;
			greeter_list_set_manual_name (self, _tmp12_);
			_g_free0 (_tmp12_);
		}
	}
	self->prompted = TRUE;
	_tmp13_ = text;
	if (g_strcmp0 (_tmp13_, "Password: ") == 0) {
		const gchar* _tmp14_ = NULL;
		_tmp14_ = _ ("Password:");
		text = _tmp14_;
	}
	_tmp15_ = text;
	if (g_strcmp0 (_tmp15_, "login:") == 0) {
		const gchar* _tmp16_ = NULL;
		_tmp16_ = _ ("Username:");
		text = _tmp16_;
	}
	_tmp17_ = text;
	_tmp18_ = type;
	_tmp19_ = greeter_list_add_prompt (self, _tmp17_, _tmp18_ == LIGHTDM_PROMPT_TYPE_SECRET);
	_tmp20_ = _tmp19_;
	_g_object_unref0 (_tmp20_);
}


void greeter_list_show_prompt_cb (GreeterList* self, const gchar* text, LightDMPromptType type) {
	g_return_if_fail (self != NULL);
	GREETER_LIST_GET_CLASS (self)->show_prompt_cb (self, text, type);
}


static void _greeter_list_background_loaded_cb_g_object_notify (GObject* _sender, GParamSpec* pspec, gpointer self) {
	greeter_list_background_loaded_cb (self, pspec);
}


static void greeter_list_real_authentication_complete_cb (GreeterList* self) {
	const gchar* _tmp0_ = NULL;
	PromptBox* _tmp1_ = NULL;
	const gchar* _tmp2_ = NULL;
	const gchar* _tmp3_ = NULL;
	gboolean is_authenticated = FALSE;
	UnityGreeter* _tmp4_ = NULL;
	gboolean _tmp5_ = FALSE;
	gboolean _tmp9_ = FALSE;
	_tmp0_ = self->greeter_authenticating_user;
	_tmp1_ = self->priv->_selected_entry;
	_tmp2_ = prompt_box_get_id (_tmp1_);
	_tmp3_ = _tmp2_;
	if (g_strcmp0 (_tmp0_, _tmp3_) != 0) {
		return;
	}
	_tmp4_ = unity_greeter_singleton;
	_tmp5_ = _tmp4_->test_mode;
	if (_tmp5_) {
		gboolean _tmp6_ = FALSE;
		_tmp6_ = self->test_is_authenticated;
		is_authenticated = _tmp6_;
	} else {
		UnityGreeter* _tmp7_ = NULL;
		gboolean _tmp8_ = FALSE;
		_tmp7_ = unity_greeter_singleton;
		_tmp8_ = unity_greeter_is_authenticated (_tmp7_);
		is_authenticated = _tmp8_;
	}
	_tmp9_ = is_authenticated;
	if (_tmp9_) {
		gboolean _tmp10_ = FALSE;
		gboolean _tmp11_ = FALSE;
		gboolean _tmp13_ = FALSE;
		_tmp11_ = self->prompted;
		if (_tmp11_) {
			gboolean _tmp12_ = FALSE;
			_tmp12_ = self->unacknowledged_messages;
			_tmp10_ = !_tmp12_;
		} else {
			_tmp10_ = FALSE;
		}
		_tmp13_ = _tmp10_;
		if (_tmp13_) {
			UnityGreeter* _tmp14_ = NULL;
			gboolean _tmp15_ = FALSE;
			greeter_list_login_complete (self);
			_tmp14_ = unity_greeter_singleton;
			_tmp15_ = _tmp14_->test_mode;
			if (_tmp15_) {
				greeter_list_start_session (self);
			} else {
				Background* _tmp16_ = NULL;
				gdouble _tmp17_ = 0.0;
				gdouble _tmp18_ = 0.0;
				_tmp16_ = self->priv->_background;
				_tmp17_ = background_get_alpha (_tmp16_);
				_tmp18_ = _tmp17_;
				if (_tmp18_ == 1.0) {
					greeter_list_start_session (self);
				} else {
					Background* _tmp19_ = NULL;
					_tmp19_ = self->priv->_background;
					g_signal_connect_object ((GObject*) _tmp19_, "notify::alpha", (GCallback) _greeter_list_background_loaded_cb_g_object_notify, self, 0);
				}
			}
		} else {
			self->prompted = TRUE;
			greeter_list_show_authenticated (self, TRUE);
		}
	} else {
		gboolean _tmp20_ = FALSE;
		_tmp20_ = self->prompted;
		if (_tmp20_) {
			gboolean _tmp21_ = FALSE;
			PromptBox* _tmp23_ = NULL;
			_tmp21_ = self->will_clear;
			if (_tmp21_) {
				const gchar* _tmp22_ = NULL;
				_tmp22_ = _ ("Invalid password, please try again");
				greeter_list_show_message (self, _tmp22_, TRUE);
			}
			_tmp23_ = self->priv->_selected_entry;
			prompt_box_reset_spinners (_tmp23_);
			greeter_list_start_authentication (self);
		} else {
			PromptBox* _tmp24_ = NULL;
			gboolean _tmp25_ = FALSE;
			gboolean _tmp26_ = FALSE;
			_tmp24_ = self->priv->_selected_entry;
			_tmp25_ = prompt_box_get_has_errors (_tmp24_);
			_tmp26_ = _tmp25_;
			if (!_tmp26_) {
				const gchar* _tmp27_ = NULL;
				_tmp27_ = _ ("Failed to authenticate");
				greeter_list_show_message (self, _tmp27_, TRUE);
			}
			greeter_list_show_authenticated (self, FALSE);
		}
	}
}


void greeter_list_authentication_complete_cb (GreeterList* self) {
	g_return_if_fail (self != NULL);
	GREETER_LIST_GET_CLASS (self)->authentication_complete_cb (self);
}


static void greeter_list_real_start_authentication (GreeterList* self) {
	gchar* _tmp0_ = NULL;
	UnityGreeter* _tmp1_ = NULL;
	gboolean _tmp2_ = FALSE;
	self->prompted = FALSE;
	self->unacknowledged_messages = FALSE;
	greeter_list_set_manual_name (self, NULL);
	self->will_clear = FALSE;
	_tmp0_ = greeter_list_get_selected_id (self);
	_g_free0 (self->greeter_authenticating_user);
	self->greeter_authenticating_user = _tmp0_;
	_tmp1_ = unity_greeter_singleton;
	_tmp2_ = _tmp1_->test_mode;
	if (_tmp2_) {
		greeter_list_test_start_authentication (self);
	} else {
		gchar* _tmp3_ = NULL;
		gchar* _tmp4_ = NULL;
		gboolean _tmp5_ = FALSE;
		_tmp3_ = greeter_list_get_selected_id (self);
		_tmp4_ = _tmp3_;
		_tmp5_ = g_strcmp0 (_tmp4_, "*other") == 0;
		_g_free0 (_tmp4_);
		if (_tmp5_) {
			UnityGreeter* _tmp6_ = NULL;
			_tmp6_ = unity_greeter_singleton;
			unity_greeter_authenticate (_tmp6_, NULL);
		} else {
			gchar* _tmp7_ = NULL;
			gchar* _tmp8_ = NULL;
			gboolean _tmp9_ = FALSE;
			_tmp7_ = greeter_list_get_selected_id (self);
			_tmp8_ = _tmp7_;
			_tmp9_ = g_strcmp0 (_tmp8_, "*guest") == 0;
			_g_free0 (_tmp8_);
			if (_tmp9_) {
				UnityGreeter* _tmp10_ = NULL;
				_tmp10_ = unity_greeter_singleton;
				unity_greeter_authenticate_as_guest (_tmp10_);
			} else {
				UnityGreeter* _tmp11_ = NULL;
				gchar* _tmp12_ = NULL;
				gchar* _tmp13_ = NULL;
				_tmp11_ = unity_greeter_singleton;
				_tmp12_ = greeter_list_get_selected_id (self);
				_tmp13_ = _tmp12_;
				unity_greeter_authenticate (_tmp11_, _tmp13_);
				_g_free0 (_tmp13_);
			}
		}
	}
}


void greeter_list_start_authentication (GreeterList* self) {
	g_return_if_fail (self != NULL);
	GREETER_LIST_GET_CLASS (self)->start_authentication (self);
}


static void greeter_list_background_loaded_cb (GreeterList* self, GParamSpec* pspec) {
	Background* _tmp0_ = NULL;
	gdouble _tmp1_ = 0.0;
	gdouble _tmp2_ = 0.0;
	g_return_if_fail (self != NULL);
	g_return_if_fail (pspec != NULL);
	_tmp0_ = self->priv->_background;
	_tmp1_ = background_get_alpha (_tmp0_);
	_tmp2_ = _tmp1_;
	if (_tmp2_ == 1.0) {
		Background* _tmp3_ = NULL;
		guint _tmp4_ = 0U;
		GQuark _tmp5_ = 0U;
		_tmp3_ = self->priv->_background;
		g_signal_parse_name ("notify::alpha", G_TYPE_OBJECT, &_tmp4_, &_tmp5_, TRUE);
		g_signal_handlers_disconnect_matched ((GObject*) _tmp3_, G_SIGNAL_MATCH_ID | G_SIGNAL_MATCH_DETAIL | G_SIGNAL_MATCH_FUNC | G_SIGNAL_MATCH_DATA, _tmp4_, _tmp5_, NULL, (GCallback) _greeter_list_background_loaded_cb_g_object_notify, self);
		greeter_list_start_session (self);
	}
}


static void greeter_list_start_session (GreeterList* self) {
	UnityGreeter* _tmp0_ = NULL;
	gchar* _tmp1_ = NULL;
	gchar* _tmp2_ = NULL;
	Background* _tmp3_ = NULL;
	gboolean _tmp4_ = FALSE;
	gboolean _tmp5_ = FALSE;
	Background* _tmp7_ = NULL;
	Background* _tmp8_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = unity_greeter_singleton;
	_tmp1_ = greeter_list_get_lightdm_session (self);
	_tmp2_ = _tmp1_;
	_tmp3_ = self->priv->_background;
	_tmp4_ = unity_greeter_start_session (_tmp0_, _tmp2_, _tmp3_);
	_tmp5_ = !_tmp4_;
	_g_free0 (_tmp2_);
	if (_tmp5_) {
		const gchar* _tmp6_ = NULL;
		_tmp6_ = _ ("Failed to start session");
		greeter_list_show_message (self, _tmp6_, TRUE);
		greeter_list_start_authentication (self);
		return;
	}
	_tmp7_ = self->priv->_background;
	background_set_draw_grid (_tmp7_, FALSE);
	_tmp8_ = self->priv->_background;
	gtk_widget_queue_draw ((GtkWidget*) _tmp8_);
}


void greeter_list_login_complete (GreeterList* self) {
	PromptBox* _tmp0_ = NULL;
	PromptBox* _tmp1_ = NULL;
	const gchar* _tmp2_ = NULL;
	g_return_if_fail (self != NULL);
	gtk_widget_set_sensitive ((GtkWidget*) self, FALSE);
	_tmp0_ = self->priv->_selected_entry;
	prompt_box_clear (_tmp0_);
	_tmp1_ = self->priv->_selected_entry;
	_tmp2_ = _ ("Logging in…");
	prompt_box_add_message (_tmp1_, _tmp2_, FALSE);
	greeter_list_redraw_greeter_box (self);
}


static gchar* greeter_list_real_get_lightdm_session (GreeterList* self) {
	gchar* result = NULL;
	gchar* _tmp0_ = NULL;
	_tmp0_ = g_strdup ("ubuntu");
	result = _tmp0_;
	return result;
}


gchar* greeter_list_get_lightdm_session (GreeterList* self) {
	g_return_val_if_fail (self != NULL, NULL);
	return GREETER_LIST_GET_CLASS (self)->get_lightdm_session (self);
}


static void greeter_list_real_test_start_authentication (GreeterList* self) {
}


void greeter_list_test_start_authentication (GreeterList* self) {
	g_return_if_fail (self != NULL);
	GREETER_LIST_GET_CLASS (self)->test_start_authentication (self);
}


Background* greeter_list_get_background (GreeterList* self) {
	Background* result;
	Background* _tmp0_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->_background;
	result = _tmp0_;
	return result;
}


static void greeter_list_set_background (GreeterList* self, Background* value) {
	Background* _tmp0_ = NULL;
	Background* _tmp1_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	_tmp1_ = _g_object_ref0 (_tmp0_);
	_g_object_unref0 (self->priv->_background);
	self->priv->_background = _tmp1_;
	g_object_notify ((GObject *) self, "background");
}


PromptBox* greeter_list_get_selected_entry (GreeterList* self) {
	PromptBox* result;
	PromptBox* _tmp0_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->_selected_entry;
	result = _tmp0_;
	return result;
}


static void greeter_list_set_selected_entry (GreeterList* self, PromptBox* value) {
	PromptBox* _tmp0_ = NULL;
	PromptBox* _tmp1_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	_tmp1_ = _g_object_ref0 (_tmp0_);
	_g_object_unref0 (self->priv->_selected_entry);
	self->priv->_selected_entry = _tmp1_;
	g_object_notify ((GObject *) self, "selected-entry");
}


gboolean greeter_list_get_start_scrolling (GreeterList* self) {
	gboolean result;
	gboolean _tmp0_ = FALSE;
	g_return_val_if_fail (self != NULL, FALSE);
	_tmp0_ = self->priv->_start_scrolling;
	result = _tmp0_;
	return result;
}


void greeter_list_set_start_scrolling (GreeterList* self, gboolean value) {
	gboolean _tmp0_ = FALSE;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	self->priv->_start_scrolling = _tmp0_;
	g_object_notify ((GObject *) self, "start-scrolling");
}


gboolean greeter_list_get_always_show_manual (GreeterList* self) {
	gboolean result;
	gboolean _tmp0_ = FALSE;
	g_return_val_if_fail (self != NULL, FALSE);
	_tmp0_ = self->_always_show_manual;
	result = _tmp0_;
	return result;
}


void greeter_list_set_always_show_manual (GreeterList* self, gboolean value) {
	gboolean _tmp0_ = FALSE;
	gboolean _tmp1_ = FALSE;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	self->_always_show_manual = _tmp0_;
	_tmp1_ = value;
	if (_tmp1_) {
		greeter_list_add_manual_entry (self);
	} else {
		gboolean _tmp2_ = FALSE;
		_tmp2_ = greeter_list_have_entries (self);
		if (_tmp2_) {
			greeter_list_remove_entry (self, "*other");
		}
	}
	g_object_notify ((GObject *) self, "always-show-manual");
}


static gint greeter_list_get_box_x (GreeterList* self) {
	gint result;
	g_return_val_if_fail (self != NULL, 0);
	result = 0;
	return result;
}


static gint greeter_list_get_box_y (GreeterList* self) {
	gint result;
	gint row = 0;
	gint _tmp0_ = 0;
	gint _tmp1_ = 0;
	gint _tmp2_ = 0;
	gint _tmp3_ = 0;
	g_return_val_if_fail (self != NULL, 0);
	_tmp0_ = gtk_widget_get_allocated_height ((GtkWidget*) self);
	row = (MAIN_WINDOW_BUTTONBOX_HEIGHT + _tmp0_) / grid_size;
	_tmp1_ = row;
	row = _tmp1_ - GREETER_LIST_DEFAULT_BOX_HEIGHT;
	_tmp2_ = row;
	row = _tmp2_ / 2;
	_tmp3_ = row;
	result = (_tmp3_ * grid_size) - MAIN_WINDOW_BUTTONBOX_HEIGHT;
	return result;
}


const gchar* greeter_list_get_manual_name (GreeterList* self) {
	const gchar* result;
	const gchar* _tmp0_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->_manual_name;
	result = _tmp0_;
	return result;
}


void greeter_list_set_manual_name (GreeterList* self, const gchar* value) {
	const gchar* _tmp0_ = NULL;
	gchar* _tmp1_ = NULL;
	PromptBox* _tmp2_ = NULL;
	PromptBox* _tmp3_ = NULL;
	gboolean _tmp4_ = FALSE;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	_tmp1_ = g_strdup (_tmp0_);
	_g_free0 (self->priv->_manual_name);
	self->priv->_manual_name = _tmp1_;
	_tmp2_ = greeter_list_find_entry (self, "*other");
	_tmp3_ = _tmp2_;
	_tmp4_ = _tmp3_ != NULL;
	_g_object_unref0 (_tmp3_);
	if (_tmp4_) {
		greeter_list_add_manual_entry (self);
	}
	g_object_notify ((GObject *) self, "manual-name");
}


static PromptBox* greeter_list_get_scrolling_entry (GreeterList* self) {
	PromptBox* result;
	PromptBox* _tmp0_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->_scrolling_entry;
	result = _tmp0_;
	return result;
}


static void greeter_list_set_scrolling_entry (GreeterList* self, PromptBox* value) {
	PromptBox* _tmp0_ = NULL;
	PromptBox* _tmp2_ = NULL;
	PromptBox* _tmp3_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->priv->_scrolling_entry;
	if (_tmp0_ != NULL) {
		PromptBox* _tmp1_ = NULL;
		_tmp1_ = self->priv->_scrolling_entry;
		prompt_box_set_options_image (_tmp1_, NULL);
	}
	_tmp2_ = value;
	_tmp3_ = _g_object_ref0 (_tmp2_);
	_g_object_unref0 (self->priv->_scrolling_entry);
	self->priv->_scrolling_entry = _tmp3_;
}


static void _greeter_list___lambda60_ (GreeterList* self) {
	gtk_widget_queue_draw ((GtkWidget*) self);
}


static void __greeter_list___lambda60__g_object_notify (GObject* _sender, GParamSpec* pspec, gpointer self) {
	_greeter_list___lambda60_ (self);
}


static void _greeter_list_greeter_box_size_allocate_cb_gtk_widget_size_allocate (GtkWidget* _sender, GtkAllocation* allocation, gpointer self) {
	greeter_list_greeter_box_size_allocate_cb (self, allocation);
}


static gdouble _animate_timer_ease_out_quint_animate_timer_easing_func (gdouble x, gpointer self) {
	gdouble result;
	result = animate_timer_ease_out_quint (x);
	return result;
}


static void _greeter_list_animate_scrolling_animate_timer_animate (AnimateTimer* _sender, gdouble progress, gpointer self) {
	greeter_list_animate_scrolling (self, progress);
}


static void _greeter_list_on_bus_acquired_gasync_ready_callback (GObject* source_object, GAsyncResult* res, gpointer self) {
	greeter_list_on_bus_acquired (self, source_object, res);
	g_object_unref (self);
}


static GObject * greeter_list_constructor (GType type, guint n_construct_properties, GObjectConstructParam * construct_properties) {
	GObject * obj;
	GObjectClass * parent_class;
	GreeterList * self;
	GtkFixed* _tmp0_ = NULL;
	GtkFixed* _tmp1_ = NULL;
	GtkFixed* _tmp2_ = NULL;
	Background* _tmp3_ = NULL;
	DashBox* _tmp4_ = NULL;
	DashBox* _tmp5_ = NULL;
	DashBox* _tmp6_ = NULL;
	DashBox* _tmp7_ = NULL;
	DashBox* _tmp8_ = NULL;
	AnimateTimer* _tmp9_ = NULL;
	AnimateTimer* _tmp10_ = NULL;
	GError * _inner_error_ = NULL;
	parent_class = G_OBJECT_CLASS (greeter_list_parent_class);
	obj = parent_class->constructor (type, n_construct_properties, construct_properties);
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, TYPE_GREETER_LIST, GreeterList);
	g_object_set ((GtkWidget*) self, "can-focus", FALSE, NULL);
	gtk_event_box_set_visible_window ((GtkEventBox*) self, FALSE);
	_tmp0_ = (GtkFixed*) gtk_fixed_new ();
	g_object_ref_sink (_tmp0_);
	_g_object_unref0 (self->priv->fixed);
	self->priv->fixed = _tmp0_;
	_tmp1_ = self->priv->fixed;
	gtk_widget_show ((GtkWidget*) _tmp1_);
	_tmp2_ = self->priv->fixed;
	gtk_container_add ((GtkContainer*) self, (GtkWidget*) _tmp2_);
	_tmp3_ = self->priv->_background;
	_tmp4_ = dash_box_new (_tmp3_);
	g_object_ref_sink (_tmp4_);
	_g_object_unref0 (self->greeter_box);
	self->greeter_box = _tmp4_;
	_tmp5_ = self->greeter_box;
	g_signal_connect_object ((GObject*) _tmp5_, "notify::base-alpha", (GCallback) __greeter_list___lambda60__g_object_notify, self, 0);
	_tmp6_ = self->greeter_box;
	gtk_widget_show ((GtkWidget*) _tmp6_);
	_tmp7_ = self->greeter_box;
	g_signal_connect_object ((GtkWidget*) _tmp7_, "size-allocate", (GCallback) _greeter_list_greeter_box_size_allocate_cb_gtk_widget_size_allocate, self, 0);
	_tmp8_ = self->greeter_box;
	greeter_list_add_with_class (self, (GtkWidget*) _tmp8_);
	_tmp9_ = animate_timer_new (_animate_timer_ease_out_quint_animate_timer_easing_func, NULL, ANIMATE_TIMER_FAST);
	_g_object_unref0 (self->priv->scroll_timer);
	self->priv->scroll_timer = _tmp9_;
	_tmp10_ = self->priv->scroll_timer;
	g_signal_connect_object (_tmp10_, "animate", (GCallback) _greeter_list_animate_scrolling_animate_timer_animate, self, 0);
	{
		g_bus_get (G_BUS_TYPE_SESSION, NULL, _greeter_list_on_bus_acquired_gasync_ready_callback, g_object_ref (self));
	}
	goto __finally10;
	__catch10_g_io_error:
	{
		GError* e = NULL;
		GError* _tmp11_ = NULL;
		const gchar* _tmp12_ = NULL;
		e = _inner_error_;
		_inner_error_ = NULL;
		_tmp11_ = e;
		_tmp12_ = _tmp11_->message;
		g_debug ("greeter-list.vala:194: Error getting session bus: %s", _tmp12_);
		_g_error_free0 (e);
	}
	__finally10:
	if (_inner_error_ != NULL) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
	}
	return obj;
}


static void greeter_list_class_init (GreeterListClass * klass) {
	greeter_list_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (GreeterListPrivate));
	GREETER_LIST_CLASS (klass)->get_selected_id = greeter_list_real_get_selected_id;
	GTK_WIDGET_CLASS (klass)->get_preferred_width = greeter_list_real_get_preferred_width;
	GTK_WIDGET_CLASS (klass)->get_preferred_height = greeter_list_real_get_preferred_height;
	GTK_WIDGET_CLASS (klass)->grab_focus = greeter_list_real_grab_focus;
	GREETER_LIST_CLASS (klass)->focus_prompt = greeter_list_real_focus_prompt;
	GREETER_LIST_CLASS (klass)->show_authenticated = greeter_list_real_show_authenticated;
	GREETER_LIST_CLASS (klass)->insert_entry = greeter_list_real_insert_entry;
	GREETER_LIST_CLASS (klass)->add_manual_entry = greeter_list_real_add_manual_entry;
	GREETER_LIST_CLASS (klass)->get_position_y = greeter_list_real_get_position_y;
	GREETER_LIST_CLASS (klass)->setup_prompt_box = greeter_list_real_setup_prompt_box;
	GTK_WIDGET_CLASS (klass)->realize = greeter_list_real_realize;
	GTK_WIDGET_CLASS (klass)->size_allocate = greeter_list_real_size_allocate;
	GTK_WIDGET_CLASS (klass)->draw = greeter_list_real_draw;
	GREETER_LIST_CLASS (klass)->show_prompt_cb = greeter_list_real_show_prompt_cb;
	GREETER_LIST_CLASS (klass)->authentication_complete_cb = greeter_list_real_authentication_complete_cb;
	GREETER_LIST_CLASS (klass)->start_authentication = greeter_list_real_start_authentication;
	GREETER_LIST_CLASS (klass)->get_lightdm_session = greeter_list_real_get_lightdm_session;
	GREETER_LIST_CLASS (klass)->test_start_authentication = greeter_list_real_test_start_authentication;
	G_OBJECT_CLASS (klass)->get_property = _vala_greeter_list_get_property;
	G_OBJECT_CLASS (klass)->set_property = _vala_greeter_list_set_property;
	G_OBJECT_CLASS (klass)->constructor = greeter_list_constructor;
	G_OBJECT_CLASS (klass)->finalize = greeter_list_finalize;
	g_object_class_install_property (G_OBJECT_CLASS (klass), GREETER_LIST_BACKGROUND, g_param_spec_object ("background", "background", "background", TYPE_BACKGROUND, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE | G_PARAM_CONSTRUCT_ONLY));
	g_object_class_install_property (G_OBJECT_CLASS (klass), GREETER_LIST_SELECTED_ENTRY, g_param_spec_object ("selected-entry", "selected-entry", "selected-entry", TYPE_PROMPT_BOX, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), GREETER_LIST_START_SCROLLING, g_param_spec_boolean ("start-scrolling", "start-scrolling", "start-scrolling", TRUE, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), GREETER_LIST_ALWAYS_SHOW_MANUAL, g_param_spec_boolean ("always-show-manual", "always-show-manual", "always-show-manual", FALSE, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), GREETER_LIST_MANUAL_NAME, g_param_spec_string ("manual-name", "manual-name", "manual-name", NULL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_signal_new ("entry_selected", TYPE_GREETER_LIST, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_marshal_VOID__STRING, G_TYPE_NONE, 1, G_TYPE_STRING);
	g_signal_new ("entry_displayed_start", TYPE_GREETER_LIST, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_marshal_VOID__VOID, G_TYPE_NONE, 0);
	g_signal_new ("entry_displayed_done", TYPE_GREETER_LIST, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_marshal_VOID__VOID, G_TYPE_NONE, 0);
}


static void greeter_list_instance_init (GreeterList * self) {
	self->priv = GREETER_LIST_GET_PRIVATE (self);
	self->priv->_selected_entry = NULL;
	self->priv->_start_scrolling = TRUE;
	self->_always_show_manual = FALSE;
	self->entries = NULL;
	self->priv->cached_box_height = -1;
	self->mode = GREETER_LIST_MODE_ENTRY;
	self->priv->n_above = (guint) 4;
	self->priv->n_below = (guint) 4;
	self->priv->_manual_name = NULL;
	self->priv->_scrolling_entry = NULL;
	self->will_clear = FALSE;
	self->prompted = FALSE;
	self->unacknowledged_messages = FALSE;
	self->test_username = NULL;
	self->test_is_authenticated = FALSE;
}


static void greeter_list_finalize (GObject* obj) {
	GreeterList * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, TYPE_GREETER_LIST, GreeterList);
	_g_object_unref0 (self->priv->_background);
	_g_object_unref0 (self->priv->_selected_entry);
	_g_free0 (self->greeter_authenticating_user);
	__g_list_free__g_object_unref0_0 (self->entries);
	_g_object_unref0 (self->priv->dbus_object);
	_g_object_unref0 (self->priv->scroll_timer);
	_g_object_unref0 (self->priv->fixed);
	_g_object_unref0 (self->greeter_box);
	_g_free0 (self->priv->_manual_name);
	_g_object_unref0 (self->priv->_scrolling_entry);
	_g_free0 (self->test_username);
	G_OBJECT_CLASS (greeter_list_parent_class)->finalize (obj);
}


GType greeter_list_get_type (void) {
	static volatile gsize greeter_list_type_id__volatile = 0;
	if (g_once_init_enter (&greeter_list_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (GreeterListClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) greeter_list_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (GreeterList), 0, (GInstanceInitFunc) greeter_list_instance_init, NULL };
		GType greeter_list_type_id;
		greeter_list_type_id = g_type_register_static (TYPE_FADABLE_BOX, "GreeterList", &g_define_type_info, G_TYPE_FLAG_ABSTRACT);
		g_once_init_leave (&greeter_list_type_id__volatile, greeter_list_type_id);
	}
	return greeter_list_type_id__volatile;
}


static void _vala_greeter_list_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec) {
	GreeterList * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (object, TYPE_GREETER_LIST, GreeterList);
	switch (property_id) {
		case GREETER_LIST_BACKGROUND:
		g_value_set_object (value, greeter_list_get_background (self));
		break;
		case GREETER_LIST_SELECTED_ENTRY:
		g_value_set_object (value, greeter_list_get_selected_entry (self));
		break;
		case GREETER_LIST_START_SCROLLING:
		g_value_set_boolean (value, greeter_list_get_start_scrolling (self));
		break;
		case GREETER_LIST_ALWAYS_SHOW_MANUAL:
		g_value_set_boolean (value, greeter_list_get_always_show_manual (self));
		break;
		case GREETER_LIST_MANUAL_NAME:
		g_value_set_string (value, greeter_list_get_manual_name (self));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


static void _vala_greeter_list_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec) {
	GreeterList * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (object, TYPE_GREETER_LIST, GreeterList);
	switch (property_id) {
		case GREETER_LIST_BACKGROUND:
		greeter_list_set_background (self, g_value_get_object (value));
		break;
		case GREETER_LIST_SELECTED_ENTRY:
		greeter_list_set_selected_entry (self, g_value_get_object (value));
		break;
		case GREETER_LIST_START_SCROLLING:
		greeter_list_set_start_scrolling (self, g_value_get_boolean (value));
		break;
		case GREETER_LIST_ALWAYS_SHOW_MANUAL:
		greeter_list_set_always_show_manual (self, g_value_get_boolean (value));
		break;
		case GREETER_LIST_MANUAL_NAME:
		greeter_list_set_manual_name (self, g_value_get_string (value));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}



