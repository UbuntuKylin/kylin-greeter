/* user-list.c generated by valac 0.22.1, the Vala compiler
 * generated from user-list.vala, do not modify */

/* -*- Mode: Vala; indent-tabs-mode: nil; tab-width: 4 -*-
 *
 * Copyright (C) 2011,2012 Canonical Ltd
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 3 as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Authors: Robert Ancell <robert.ancell@canonical.com>
 *          Michael Terry <michael.terry@canonical.com>
 */

#include <glib.h>
#include <glib-object.h>
#include <stdlib.h>
#include <string.h>
#include <gtk/gtk.h>
#include <cairo.h>
#include <float.h>
#include <math.h>
#include <lightdm.h>
#include <gdk-pixbuf/gdk-pixbuf.h>
#include <gio/gio.h>
#include <glib/gi18n-lib.h>
#include <gdk/gdk.h>
#include "config.h"


#define TYPE_REMOTE_SERVER_FIELD (remote_server_field_get_type ())
typedef struct _RemoteServerField RemoteServerField;
#define _g_free0(var) (var = (g_free (var), NULL))

#define TYPE_FADABLE (fadable_get_type ())
#define FADABLE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_FADABLE, Fadable))
#define IS_FADABLE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_FADABLE))
#define FADABLE_GET_INTERFACE(obj) (G_TYPE_INSTANCE_GET_INTERFACE ((obj), TYPE_FADABLE, FadableIface))

typedef struct _Fadable Fadable;
typedef struct _FadableIface FadableIface;

#define TYPE_FADE_TRACKER (fade_tracker_get_type ())
#define FADE_TRACKER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_FADE_TRACKER, FadeTracker))
#define FADE_TRACKER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_FADE_TRACKER, FadeTrackerClass))
#define IS_FADE_TRACKER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_FADE_TRACKER))
#define IS_FADE_TRACKER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_FADE_TRACKER))
#define FADE_TRACKER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_FADE_TRACKER, FadeTrackerClass))

typedef struct _FadeTracker FadeTracker;
typedef struct _FadeTrackerClass FadeTrackerClass;

#define TYPE_FADABLE_BOX (fadable_box_get_type ())
#define FADABLE_BOX(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_FADABLE_BOX, FadableBox))
#define FADABLE_BOX_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_FADABLE_BOX, FadableBoxClass))
#define IS_FADABLE_BOX(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_FADABLE_BOX))
#define IS_FADABLE_BOX_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_FADABLE_BOX))
#define FADABLE_BOX_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_FADABLE_BOX, FadableBoxClass))

typedef struct _FadableBox FadableBox;
typedef struct _FadableBoxClass FadableBoxClass;
typedef struct _FadableBoxPrivate FadableBoxPrivate;

#define TYPE_GREETER_LIST (greeter_list_get_type ())
#define GREETER_LIST(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_GREETER_LIST, GreeterList))
#define GREETER_LIST_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_GREETER_LIST, GreeterListClass))
#define IS_GREETER_LIST(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_GREETER_LIST))
#define IS_GREETER_LIST_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_GREETER_LIST))
#define GREETER_LIST_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_GREETER_LIST, GreeterListClass))

typedef struct _GreeterList GreeterList;
typedef struct _GreeterListClass GreeterListClass;
typedef struct _GreeterListPrivate GreeterListPrivate;

#define TYPE_PROMPT_BOX (prompt_box_get_type ())
#define PROMPT_BOX(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_PROMPT_BOX, PromptBox))
#define PROMPT_BOX_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_PROMPT_BOX, PromptBoxClass))
#define IS_PROMPT_BOX(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_PROMPT_BOX))
#define IS_PROMPT_BOX_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_PROMPT_BOX))
#define PROMPT_BOX_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_PROMPT_BOX, PromptBoxClass))

typedef struct _PromptBox PromptBox;
typedef struct _PromptBoxClass PromptBoxClass;

#define TYPE_DASH_BOX (dash_box_get_type ())
#define DASH_BOX(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_DASH_BOX, DashBox))
#define DASH_BOX_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_DASH_BOX, DashBoxClass))
#define IS_DASH_BOX(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_DASH_BOX))
#define IS_DASH_BOX_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_DASH_BOX))
#define DASH_BOX_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_DASH_BOX, DashBoxClass))

typedef struct _DashBox DashBox;
typedef struct _DashBoxClass DashBoxClass;

#define GREETER_LIST_TYPE_MODE (greeter_list_mode_get_type ())

#define TYPE_USER_LIST (user_list_get_type ())
#define USER_LIST(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_USER_LIST, UserList))
#define USER_LIST_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_USER_LIST, UserListClass))
#define IS_USER_LIST(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_USER_LIST))
#define IS_USER_LIST_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_USER_LIST))
#define USER_LIST_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_USER_LIST, UserListClass))

typedef struct _UserList UserList;
typedef struct _UserListClass UserListClass;
typedef struct _UserListPrivate UserListPrivate;

#define TYPE_REMOTE_LOGIN_SERVICE (remote_login_service_get_type ())
#define REMOTE_LOGIN_SERVICE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_REMOTE_LOGIN_SERVICE, RemoteLoginService))
#define IS_REMOTE_LOGIN_SERVICE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_REMOTE_LOGIN_SERVICE))
#define REMOTE_LOGIN_SERVICE_GET_INTERFACE(obj) (G_TYPE_INSTANCE_GET_INTERFACE ((obj), TYPE_REMOTE_LOGIN_SERVICE, RemoteLoginServiceIface))

typedef struct _RemoteLoginService RemoteLoginService;
typedef struct _RemoteLoginServiceIface RemoteLoginServiceIface;

#define TYPE_REMOTE_LOGIN_SERVICE_PROXY (remote_login_service_proxy_get_type ())

#define TYPE_REMOTE_SERVER (remote_server_get_type ())

#define TYPE_REMOTE_SERVER_APPLICATION (remote_server_application_get_type ())
typedef struct _RemoteServerApplication RemoteServerApplication;
typedef struct _RemoteServer RemoteServer;

#define TYPE_EMAIL_AUTOCOMPLETER (email_autocompleter_get_type ())
#define EMAIL_AUTOCOMPLETER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_EMAIL_AUTOCOMPLETER, EmailAutocompleter))
#define EMAIL_AUTOCOMPLETER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_EMAIL_AUTOCOMPLETER, EmailAutocompleterClass))
#define IS_EMAIL_AUTOCOMPLETER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_EMAIL_AUTOCOMPLETER))
#define IS_EMAIL_AUTOCOMPLETER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_EMAIL_AUTOCOMPLETER))
#define EMAIL_AUTOCOMPLETER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_EMAIL_AUTOCOMPLETER, EmailAutocompleterClass))

typedef struct _EmailAutocompleter EmailAutocompleter;
typedef struct _EmailAutocompleterClass EmailAutocompleterClass;
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
#define __g_list_free__remote_server_free0_0(var) ((var == NULL) ? NULL : (var = (_g_list_free__remote_server_free0_ (var), NULL)))
#define _g_hash_table_unref0(var) ((var == NULL) ? NULL : (var = (g_hash_table_unref (var), NULL)))
#define _email_autocompleter_unref0(var) ((var == NULL) ? NULL : (var = (email_autocompleter_unref (var), NULL)))
#define __g_list_free__g_free0_0(var) ((var == NULL) ? NULL : (var = (_g_list_free__g_free0_ (var), NULL)))

#define USER_LIST_TYPE_TEST_ENTRY (user_list_test_entry_get_type ())
typedef struct _UserListTestEntry UserListTestEntry;

#define TYPE_BACKGROUND (background_get_type ())
#define BACKGROUND(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_BACKGROUND, Background))
#define BACKGROUND_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_BACKGROUND, BackgroundClass))
#define IS_BACKGROUND(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_BACKGROUND))
#define IS_BACKGROUND_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_BACKGROUND))
#define BACKGROUND_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_BACKGROUND, BackgroundClass))

typedef struct _Background Background;
typedef struct _BackgroundClass BackgroundClass;
#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))
typedef struct _UserListQueryDirectoryServersData UserListQueryDirectoryServersData;
#define _remote_server_free0(var) ((var == NULL) ? NULL : (var = (remote_server_free (var), NULL)))

#define TYPE_UNITY_GREETER (unity_greeter_get_type ())
#define UNITY_GREETER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_UNITY_GREETER, UnityGreeter))
#define UNITY_GREETER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_UNITY_GREETER, UnityGreeterClass))
#define IS_UNITY_GREETER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_UNITY_GREETER))
#define IS_UNITY_GREETER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_UNITY_GREETER))
#define UNITY_GREETER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_UNITY_GREETER, UnityGreeterClass))

typedef struct _UnityGreeter UnityGreeter;
typedef struct _UnityGreeterClass UnityGreeterClass;

#define TYPE_DASH_ENTRY (dash_entry_get_type ())
#define DASH_ENTRY(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_DASH_ENTRY, DashEntry))
#define DASH_ENTRY_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_DASH_ENTRY, DashEntryClass))
#define IS_DASH_ENTRY(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_DASH_ENTRY))
#define IS_DASH_ENTRY_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_DASH_ENTRY))
#define DASH_ENTRY_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_DASH_ENTRY, DashEntryClass))

typedef struct _DashEntry DashEntry;
typedef struct _DashEntryClass DashEntryClass;
#define _g_match_info_unref0(var) ((var == NULL) ? NULL : (var = (g_match_info_unref (var), NULL)))
#define _g_regex_unref0(var) ((var == NULL) ? NULL : (var = (g_regex_unref (var), NULL)))
typedef struct _UnityGreeterPrivate UnityGreeterPrivate;
typedef struct _UserListRemoteDirectoryRespondCbData UserListRemoteDirectoryRespondCbData;
typedef struct _Block7Data Block7Data;

#define TYPE_USER_PROMPT_BOX (user_prompt_box_get_type ())
#define USER_PROMPT_BOX(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_USER_PROMPT_BOX, UserPromptBox))
#define USER_PROMPT_BOX_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_USER_PROMPT_BOX, UserPromptBoxClass))
#define IS_USER_PROMPT_BOX(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_USER_PROMPT_BOX))
#define IS_USER_PROMPT_BOX_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_USER_PROMPT_BOX))
#define USER_PROMPT_BOX_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_USER_PROMPT_BOX, UserPromptBoxClass))

typedef struct _UserPromptBox UserPromptBox;
typedef struct _UserPromptBoxClass UserPromptBoxClass;
typedef struct _PromptBoxPrivate PromptBoxPrivate;

#define TYPE_FADING_LABEL (fading_label_get_type ())
#define FADING_LABEL(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_FADING_LABEL, FadingLabel))
#define FADING_LABEL_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_FADING_LABEL, FadingLabelClass))
#define IS_FADING_LABEL(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_FADING_LABEL))
#define IS_FADING_LABEL_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_FADING_LABEL))
#define FADING_LABEL_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_FADING_LABEL, FadingLabelClass))

typedef struct _FadingLabel FadingLabel;
typedef struct _FadingLabelClass FadingLabelClass;

#define TYPE_FLAT_BUTTON (flat_button_get_type ())
#define FLAT_BUTTON(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_FLAT_BUTTON, FlatButton))
#define FLAT_BUTTON_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_FLAT_BUTTON, FlatButtonClass))
#define IS_FLAT_BUTTON(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_FLAT_BUTTON))
#define IS_FLAT_BUTTON_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_FLAT_BUTTON))
#define FLAT_BUTTON_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_FLAT_BUTTON, FlatButtonClass))

typedef struct _FlatButton FlatButton;
typedef struct _FlatButtonClass FlatButtonClass;
typedef struct _UserPromptBoxPrivate UserPromptBoxPrivate;
typedef struct _Block8Data Block8Data;
#define _g_ptr_array_unref0(var) ((var == NULL) ? NULL : (var = (g_ptr_array_unref (var), NULL)))
#define _remote_server_field_free0(var) ((var == NULL) ? NULL : (var = (remote_server_field_free (var), NULL)))
#define __g_list_free__remote_server_field_free0_0(var) ((var == NULL) ? NULL : (var = (_g_list_free__remote_server_field_free0_ (var), NULL)))
typedef struct _UserListCreateRemoteFieldsForCurrentItemData UserListCreateRemoteFieldsForCurrentItemData;

#define TYPE_SESSION_LIST (session_list_get_type ())
#define SESSION_LIST(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_SESSION_LIST, SessionList))
#define SESSION_LIST_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_SESSION_LIST, SessionListClass))
#define IS_SESSION_LIST(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_SESSION_LIST))
#define IS_SESSION_LIST_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_SESSION_LIST))
#define SESSION_LIST_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_SESSION_LIST, SessionListClass))

typedef struct _SessionList SessionList;
typedef struct _SessionListClass SessionListClass;
#define _g_dir_close0(var) ((var == NULL) ? NULL : (var = (g_dir_close (var), NULL)))
#define _g_variant_unref0(var) ((var == NULL) ? NULL : (var = (g_variant_unref (var), NULL)))

struct _RemoteServerField {
	gchar* type;
	gboolean required;
	GVariant* default_value;
	GHashTable* properties;
};

struct _FadableIface {
	GTypeInterface parent_iface;
	FadeTracker* (*get_fade_tracker) (Fadable* self);
	void (*set_fade_tracker) (Fadable* self, FadeTracker* value);
};

struct _FadableBox {
	GtkEventBox parent_instance;
	FadableBoxPrivate * priv;
};

struct _FadableBoxClass {
	GtkEventBoxClass parent_class;
	void (*draw_full_alpha) (FadableBox* self, cairo_t* c);
};

typedef enum  {
	GREETER_LIST_MODE_ENTRY,
	GREETER_LIST_MODE_SCROLLING
} GreeterListMode;

struct _GreeterList {
	FadableBox parent_instance;
	GreeterListPrivate * priv;
	gchar* greeter_authenticating_user;
	gboolean _always_show_manual;
	GList* entries;
	DashBox* greeter_box;
	GreeterListMode mode;
	gboolean will_clear;
	gboolean prompted;
	gboolean unacknowledged_messages;
	gchar* test_username;
	gboolean test_is_authenticated;
};

struct _GreeterListClass {
	FadableBoxClass parent_class;
	gchar* (*get_selected_id) (GreeterList* self);
	void (*focus_prompt) (GreeterList* self);
	void (*show_authenticated) (GreeterList* self, gboolean successful);
	void (*insert_entry) (GreeterList* self, PromptBox* entry);
	void (*add_manual_entry) (GreeterList* self);
	gint (*get_position_y) (GreeterList* self, gdouble position);
	void (*setup_prompt_box) (GreeterList* self, gboolean fade);
	void (*show_prompt_cb) (GreeterList* self, const gchar* text, LightDMPromptType type);
	void (*authentication_complete_cb) (GreeterList* self);
	void (*start_authentication) (GreeterList* self);
	gchar* (*get_lightdm_session) (GreeterList* self);
	void (*test_start_authentication) (GreeterList* self);
};

struct _UserList {
	GreeterList parent_instance;
	UserListPrivate * priv;
};

struct _UserListClass {
	GreeterListClass parent_class;
};

struct _RemoteServerApplication {
	gchar* application_id;
	gint pin_position;
};

struct _RemoteServer {
	gchar* type;
	gchar* name;
	gchar* url;
	gboolean last_used_server;
	RemoteServerField* fields;
	gint fields_length1;
	RemoteServerApplication* applications;
	gint applications_length1;
};

struct _RemoteLoginServiceIface {
	GTypeInterface parent_iface;
	void (*get_servers) (RemoteLoginService* self, GAsyncReadyCallback _callback_, gpointer _user_data_);
	void (*get_servers_finish) (RemoteLoginService* self, GAsyncResult* _res_, RemoteServer** serverList, int* serverList_length1, GError** error);
	void (*get_servers_for_login) (RemoteLoginService* self, const gchar* url, const gchar* emailAddress, const gchar* password, gboolean allowCache, GAsyncReadyCallback _callback_, gpointer _user_data_);
	void (*get_servers_for_login_finish) (RemoteLoginService* self, GAsyncResult* _res_, gboolean* loginSuccess, gchar** dataType, RemoteServer** serverList, int* serverList_length1, GError** error);
	void (*get_cached_domains_for_server) (RemoteLoginService* self, const gchar* url, GAsyncReadyCallback _callback_, gpointer _user_data_);
	void (*get_cached_domains_for_server_finish) (RemoteLoginService* self, GAsyncResult* _res_, gchar*** domains, int* domains_length1, GError** error);
	void (*set_last_used_server) (RemoteLoginService* self, const gchar* uccsUrl, const gchar* serverUrl, GAsyncReadyCallback _callback_, gpointer _user_data_);
	void (*set_last_used_server_finish) (RemoteLoginService* self, GAsyncResult* _res_, GError** error);
};

struct _UserListPrivate {
	gboolean _offer_guest;
	GdkPixbuf* message_pixbuf;
	guint change_background_timeout;
	guint remote_login_service_watch;
	RemoteLoginService* remote_login_service;
	GList* remote_directory_server_list;
	GList* remote_login_server_list;
	GHashTable* current_remote_fields;
	gchar* currently_browsing_server_url;
	gchar* currently_browsing_server_email;
	EmailAutocompleter* remote_server_email_field_autocompleter;
	gchar* authenticate_user;
	gboolean show_hidden_users_;
	gchar* _default_session;
	gchar* _session;
	GList* test_backgrounds;
	gint n_test_entries;
	gboolean test_prompted_sso;
	gchar* test_two_prompts_first;
	gboolean test_request_new_password;
	gchar* test_new_password;
};

struct _UserListTestEntry {
	gchar* username;
	gchar* real_name;
	gchar* background;
	gboolean is_active;
	gboolean has_messages;
	gchar* session;
};

struct _UserListQueryDirectoryServersData {
	int _state_;
	GObject* _source_object_;
	GAsyncResult* _res_;
	GSimpleAsyncResult* _async_result;
	UserList* self;
	RemoteServer* server_list;
	gint server_list_length1;
	gint _server_list_size_;
	RemoteLoginService* _tmp0_;
	RemoteServer* _tmp1_;
	gint _tmp2_;
	GError* e;
	GError* _tmp3_;
	const gchar* _tmp4_;
	GError * _inner_error_;
};

struct _UnityGreeter {
	GTypeInstance parent_instance;
	volatile int ref_count;
	UnityGreeterPrivate * priv;
	gboolean test_mode;
	gboolean orca_needs_kick;
};

struct _UnityGreeterClass {
	GTypeClass parent_class;
	void (*finalize) (UnityGreeter *self);
};

struct _UserListRemoteDirectoryRespondCbData {
	int _state_;
	GObject* _source_object_;
	GAsyncResult* _res_;
	GSimpleAsyncResult* _async_result;
	UserList* self;
	gchar* _tmp0_;
	gchar* _tmp1_;
	DashEntry* password_field;
	GHashTable* _tmp2_;
	gconstpointer _tmp3_;
	GtkWidget* _tmp4_;
	DashEntry* _tmp5_;
	GtkEntry* email_field;
	GHashTable* _tmp6_;
	gconstpointer _tmp7_;
	GtkWidget* _tmp8_;
	GtkEntry* _tmp9_;
	DashEntry* _tmp10_;
	GtkEntry* _tmp11_;
	RemoteServer* server_list;
	RemoteServer* _tmp12_;
	gint server_list_length1;
	gint _server_list_size_;
	gchar* email;
	GtkEntry* _tmp13_;
	const gchar* _tmp14_;
	const gchar* _tmp15_;
	gchar* _tmp16_;
	gboolean email_valid;
	GRegex* re;
	GRegex* _tmp17_;
	GMatchInfo* info;
	GRegex* _tmp18_;
	const gchar* _tmp19_;
	GMatchInfo* _tmp20_;
	gboolean _tmp21_;
	gboolean _tmp22_;
	gboolean _tmp23_;
	gboolean _tmp24_;
	GMatchInfo* _tmp25_;
	gint _tmp26_;
	gboolean _tmp27_;
	GMatchInfo* _tmp28_;
	gchar* _tmp29_;
	gchar* _tmp30_;
	const gchar* _tmp31_;
	gboolean _tmp32_;
	GError* e;
	GError* _tmp33_;
	const gchar* _tmp34_;
	PromptBox* _tmp35_;
	PromptBox* _tmp36_;
	gboolean _tmp37_;
	const gchar* _tmp38_;
	GList* _tmp39_;
	gboolean login_success;
	gchar* url;
	PromptBox* _tmp40_;
	PromptBox* _tmp41_;
	const gchar* _tmp42_;
	const gchar* _tmp43_;
	gchar* _tmp44_;
	UnityGreeter* _tmp45_;
	gboolean _tmp46_;
	DashEntry* _tmp47_;
	const gchar* _tmp48_;
	const gchar* _tmp49_;
	RemoteServer* _tmp50_;
	gint _tmp51_;
	DashEntry* _tmp52_;
	const gchar* _tmp53_;
	const gchar* _tmp54_;
	RemoteServer* _tmp55_;
	gint _tmp56_;
	DashEntry* _tmp57_;
	const gchar* _tmp58_;
	const gchar* _tmp59_;
	RemoteServer* _tmp60_;
	gint _tmp61_;
	DashEntry* _tmp62_;
	const gchar* _tmp63_;
	const gchar* _tmp64_;
	RemoteServer* _tmp65_;
	gint _tmp66_;
	DashEntry* _tmp67_;
	const gchar* _tmp68_;
	const gchar* _tmp69_;
	RemoteServer* _tmp70_;
	gint _tmp71_;
	gchar* data_type;
	gboolean allowcache;
	gboolean _tmp72_;
	gboolean _tmp73_;
	PromptBox* _tmp74_;
	PromptBox* _tmp75_;
	gboolean _tmp76_;
	gboolean _tmp77_;
	const gchar* _tmp78_;
	const gchar* _tmp79_;
	gboolean _tmp80_;
	const gchar* _tmp81_;
	const gchar* _tmp82_;
	gboolean _tmp83_;
	RemoteLoginService* _tmp84_;
	const gchar* _tmp85_;
	const gchar* _tmp86_;
	DashEntry* _tmp87_;
	const gchar* _tmp88_;
	const gchar* _tmp89_;
	gboolean _tmp90_;
	gboolean _tmp91_;
	gchar* _tmp92_;
	RemoteServer* _tmp93_;
	gint _tmp94_;
	const gchar* _tmp95_;
	gchar* _tmp96_;
	const gchar* _tmp97_;
	gchar* _tmp98_;
	GError* _vala1_e;
	GError* _tmp99_;
	const gchar* _tmp100_;
	gboolean _tmp101_;
	DashEntry* _tmp102_;
	RemoteServer* _tmp103_;
	gint _tmp103__length1;
	gchar* last_used_server_list_name;
	gchar* _tmp104_;
	RemoteServer* _tmp105_;
	gint _tmp105__length1;
	RemoteServer* remote_server_collection;
	gint remote_server_collection_length1;
	gint _remote_server_collection_size_;
	gint remote_server_it;
	RemoteServer _tmp106_;
	RemoteServer remote_server;
	PromptBox* _vala2_e;
	RemoteServer _tmp107_;
	PromptBox* _tmp108_;
	RemoteServer _tmp109_;
	gboolean _tmp110_;
	PromptBox* _tmp111_;
	const gchar* _tmp112_;
	const gchar* _tmp113_;
	gchar* _tmp114_;
	const gchar* _tmp115_;
	const gchar* _tmp116_;
	const gchar* _tmp117_;
	GList* _tmp118_;
	GError * _inner_error_;
};

struct _Block7Data {
	int _ref_count_;
	UserList * self;
	GtkMessageDialog* dialog;
};

struct _PromptBox {
	FadableBox parent_instance;
	PromptBoxPrivate * priv;
	GtkGrid* box_grid;
	GtkGrid* name_grid;
	FadingLabel* name_label;
	FlatButton* option_button;
	GtkWidget* small_box_widget;
	FadingLabel* small_name_label;
	gint start_row;
	gint last_row;
};

struct _PromptBoxClass {
	FadableBoxClass parent_class;
	GtkGrid* (*create_name_grid) (PromptBox* self);
	GtkGrid* (*create_small_name_grid) (PromptBox* self);
	void (*set_start_row) (PromptBox* self);
	void (*reset_last_row) (PromptBox* self);
	void (*add_static_prompts) (PromptBox* self);
};

struct _UserPromptBox {
	PromptBox parent_instance;
	UserPromptBoxPrivate * priv;
	gchar* background;
	gchar* session;
	gboolean is_active;
};

struct _UserPromptBoxClass {
	PromptBoxClass parent_class;
};

struct _Block8Data {
	int _ref_count_;
	GPtrArray * self;
	GCompareFunc compare_func;
};

struct _UserListCreateRemoteFieldsForCurrentItemData {
	int _state_;
	GObject* _source_object_;
	GAsyncResult* _res_;
	GSimpleAsyncResult* _async_result;
	UserList* self;
	GList* server_list;
	GHashFunc _tmp0_;
	GEqualFunc _tmp1_;
	GHashTable* _tmp2_;
	gchar* url;
	PromptBox* _tmp3_;
	PromptBox* _tmp4_;
	const gchar* _tmp5_;
	const gchar* _tmp6_;
	gchar* _tmp7_;
	gchar* username;
	PromptBox* _tmp8_;
	PromptBox* _tmp9_;
	const gchar* _tmp10_;
	const gchar* _tmp11_;
	gchar* _tmp12_;
	GList* _tmp13_;
	GList* remote_server_collection;
	GList* remote_server_it;
	RemoteServer* _tmp14_;
	RemoteServer* remote_server;
	gchar* remote_username;
	RemoteServer* _tmp15_;
	RemoteServer _tmp16_;
	gchar* _tmp17_;
	gboolean _tmp18_;
	RemoteServer* _tmp19_;
	const gchar* _tmp20_;
	const gchar* _tmp21_;
	gboolean _tmp22_;
	const gchar* _tmp23_;
	const gchar* _tmp24_;
	const gchar* _tmp25_;
	gboolean _tmp26_;
	gboolean _tmp27_;
	PromptBox* _tmp28_;
	PromptBox* _tmp29_;
	const gchar* _tmp30_;
	const gchar* _tmp31_;
	gboolean _tmp32_;
	RemoteServer* _tmp33_;
	const gchar* _tmp34_;
	gboolean _tmp35_;
	const gchar* _tmp36_;
	GList* fields;
	RemoteServer* _tmp37_;
	RemoteServerField* _tmp38_;
	gint _tmp38__length1;
	RemoteServerField* field_collection;
	gint field_collection_length1;
	gint _field_collection_size_;
	gint field_it;
	RemoteServerField _tmp39_;
	RemoteServerField field;
	RemoteServerField _tmp40_;
	RemoteServerField _tmp41_;
	RemoteServerField* _tmp42_;
	GList* _tmp43_;
	GList* _vala1_field_collection;
	GList* _vala1_field_it;
	RemoteServerField* _tmp44_;
	RemoteServerField* _vala1_field;
	GtkWidget* widget;
	gchar* default_value;
	gchar* _tmp45_;
	gboolean _tmp46_;
	RemoteServerField* _tmp47_;
	GVariant* _tmp48_;
	RemoteServerField* _tmp49_;
	GVariant* _tmp50_;
	const GVariantType* _tmp51_;
	gboolean _tmp52_;
	gboolean _tmp53_;
	RemoteServerField* _tmp54_;
	GVariant* _tmp55_;
	const gchar* _tmp56_;
	gchar* _tmp57_;
	RemoteServerField* _tmp58_;
	const gchar* _tmp59_;
	DashEntry* entry;
	const gchar* _tmp60_;
	DashEntry* _tmp61_;
	DashEntry* _tmp62_;
	const gchar* _tmp63_;
	DashEntry* _tmp64_;
	GtkWidget* _tmp65_;
	RemoteServerField* _tmp66_;
	const gchar* _tmp67_;
	DashEntry* _vala1_entry;
	const gchar* _tmp68_;
	DashEntry* _tmp69_;
	DashEntry* _tmp70_;
	const gchar* _tmp71_;
	DashEntry* _tmp72_;
	GtkWidget* _tmp73_;
	RemoteServerField* _tmp74_;
	const gchar* _tmp75_;
	gchar** domainsArray;
	gchar** _tmp76_;
	gint domainsArray_length1;
	gint _domainsArray_size_;
	gboolean _tmp77_;
	gboolean _tmp78_;
	RemoteServerField* _tmp79_;
	GHashTable* _tmp80_;
	RemoteServerField* _tmp81_;
	GHashTable* _tmp82_;
	gboolean _tmp83_;
	gboolean _tmp84_;
	RemoteServerField* _tmp85_;
	GHashTable* _tmp86_;
	gconstpointer _tmp87_;
	const GVariantType* _tmp88_;
	gboolean _tmp89_;
	gboolean _tmp90_;
	RemoteServerField* _tmp91_;
	GHashTable* _tmp92_;
	gconstpointer _tmp93_;
	size_t _tmp94_;
	gchar** _tmp95_;
	GPtrArray* domains;
	GPtrArray* _tmp96_;
	gint i;
	gboolean _tmp97_;
	gboolean _tmp98_;
	gint _tmp99_;
	gint _tmp100_;
	gchar** _tmp101_;
	gint _tmp101__length1;
	GPtrArray* _tmp102_;
	gchar** _tmp103_;
	gint _tmp103__length1;
	gint _tmp104_;
	const gchar* _tmp105_;
	gchar* _tmp106_;
	gboolean _tmp107_;
	gboolean _tmp108_;
	gboolean _tmp109_;
	RemoteServerField* _tmp110_;
	GHashTable* _tmp111_;
	RemoteServerField* _tmp112_;
	GHashTable* _tmp113_;
	gboolean _tmp114_;
	gboolean _tmp115_;
	RemoteServerField* _tmp116_;
	GHashTable* _tmp117_;
	gconstpointer _tmp118_;
	const GVariantType* _tmp119_;
	gboolean _tmp120_;
	gboolean _tmp121_;
	RemoteServerField* _tmp122_;
	GHashTable* _tmp123_;
	gconstpointer _tmp124_;
	gboolean _tmp125_;
	gboolean read_only;
	gboolean _tmp126_;
	gboolean _tmp127_;
	GPtrArray* _tmp128_;
	gint _tmp129_;
	gint _tmp130_;
	gboolean _tmp131_;
	GPtrArray* _tmp132_;
	gint _tmp133_;
	gint _tmp134_;
	gboolean _tmp135_;
	GPtrArray* _tmp136_;
	gconstpointer _tmp137_;
	const gchar* _tmp138_;
	const gchar* _tmp139_;
	gint _tmp140_;
	gint _tmp141_;
	gboolean _tmp142_;
	gboolean _tmp143_;
	gboolean _tmp144_;
	DashEntry* prompt;
	const gchar* _tmp145_;
	DashEntry* _tmp146_;
	const gchar* _tmp147_;
	GPtrArray* _tmp148_;
	gint _tmp149_;
	gint _tmp150_;
	GPtrArray* _tmp151_;
	gconstpointer _tmp152_;
	const gchar* _tmp153_;
	DashEntry* _tmp154_;
	const gchar* _tmp155_;
	DashEntry* _tmp156_;
	gboolean _tmp157_;
	DashEntry* _tmp158_;
	GtkWidget* _tmp159_;
	const gchar* _tmp160_;
	gint _tmp161_;
	gint _tmp162_;
	gboolean found;
	gint _vala1_i;
	gboolean _tmp163_;
	gboolean _tmp164_;
	gint _tmp165_;
	gboolean _tmp166_;
	gboolean _tmp167_;
	gint _tmp168_;
	GPtrArray* _tmp169_;
	gint _tmp170_;
	gint _tmp171_;
	gboolean _tmp172_;
	const gchar* _tmp173_;
	GPtrArray* _tmp174_;
	gint _tmp175_;
	gconstpointer _tmp176_;
	gboolean _tmp177_;
	GPtrArray* _tmp178_;
	const gchar* _tmp179_;
	gchar* _tmp180_;
	GPtrArray* _tmp181_;
	GCompareFunc _tmp182_;
	GtkComboBox* combo;
	GPtrArray* _tmp183_;
	gboolean _tmp184_;
	GtkComboBox* _tmp185_;
	const gchar* _tmp186_;
	gint _tmp187_;
	gint _tmp188_;
	gboolean _tmp189_;
	gint _vala2_i;
	gboolean _tmp190_;
	gboolean _tmp191_;
	gint _tmp192_;
	gint _tmp193_;
	GPtrArray* _tmp194_;
	gint _tmp195_;
	gint _tmp196_;
	const gchar* _tmp197_;
	GPtrArray* _tmp198_;
	gint _tmp199_;
	gconstpointer _tmp200_;
	GtkComboBox* _tmp201_;
	gint _tmp202_;
	GtkEntry* _vala2_entry;
	GtkComboBox* _tmp203_;
	GtkWidget* _tmp204_;
	GtkEntry* _tmp205_;
	GtkEntry* _tmp206_;
	const gchar* _tmp207_;
	GtkComboBox* _tmp208_;
	GtkWidget* _tmp209_;
	RemoteServerField* _tmp210_;
	const gchar* _tmp211_;
	gchar** email_domains;
	gint email_domains_length1;
	gint _email_domains_size_;
	UnityGreeter* _tmp212_;
	gboolean _tmp213_;
	gchar* _tmp214_;
	gchar* _tmp215_;
	gchar* _tmp216_;
	gchar* _tmp217_;
	gchar** _tmp218_;
	RemoteLoginService* _tmp219_;
	const gchar* _tmp220_;
	gchar** _tmp221_;
	gint _tmp222_;
	GError* e;
	gint _tmp223_;
	GError* _tmp224_;
	const gchar* _tmp225_;
	DashEntry* _vala3_entry;
	const gchar* _tmp226_;
	DashEntry* _tmp227_;
	DashEntry* _tmp228_;
	const gchar* _tmp229_;
	DashEntry* _tmp230_;
	GtkWidget* _tmp231_;
	gchar** _tmp232_;
	gint _tmp232__length1;
	DashEntry* _tmp233_;
	gchar** _tmp234_;
	gint _tmp234__length1;
	EmailAutocompleter* _tmp235_;
	RemoteServerField* _tmp236_;
	const gchar* _tmp237_;
	GHashTable* _tmp238_;
	RemoteServerField* _tmp239_;
	const gchar* _tmp240_;
	gchar* _tmp241_;
	GtkWidget* _tmp242_;
	GtkWidget* _tmp243_;
	GError * _inner_error_;
};


static gpointer user_list_parent_class = NULL;
extern UnityGreeter* unity_greeter_singleton;

GType remote_server_field_get_type (void) G_GNUC_CONST;
RemoteServerField* remote_server_field_dup (const RemoteServerField* self);
void remote_server_field_free (RemoteServerField* self);
void remote_server_field_copy (const RemoteServerField* self, RemoteServerField* dest);
void remote_server_field_destroy (RemoteServerField* self);
gint remote_server_field_sort_function (RemoteServerField* item1, RemoteServerField* item2);
GType fade_tracker_get_type (void) G_GNUC_CONST;
GType fadable_get_type (void) G_GNUC_CONST;
GType fadable_box_get_type (void) G_GNUC_CONST;
GType greeter_list_get_type (void) G_GNUC_CONST;
GType prompt_box_get_type (void) G_GNUC_CONST;
GType dash_box_get_type (void) G_GNUC_CONST;
GType greeter_list_mode_get_type (void) G_GNUC_CONST;
GType user_list_get_type (void) G_GNUC_CONST;
GType remote_login_service_proxy_get_type (void) G_GNUC_CONST;
guint remote_login_service_register_object (void* object, GDBusConnection* connection, const gchar* path, GError** error);
GType remote_server_get_type (void) G_GNUC_CONST;
GType remote_server_application_get_type (void) G_GNUC_CONST;
RemoteServerApplication* remote_server_application_dup (const RemoteServerApplication* self);
void remote_server_application_free (RemoteServerApplication* self);
void remote_server_application_copy (const RemoteServerApplication* self, RemoteServerApplication* dest);
void remote_server_application_destroy (RemoteServerApplication* self);
RemoteServer* remote_server_dup (const RemoteServer* self);
void remote_server_free (RemoteServer* self);
void remote_server_copy (const RemoteServer* self, RemoteServer* dest);
void remote_server_destroy (RemoteServer* self);
GType remote_login_service_get_type (void) G_GNUC_CONST;
gpointer email_autocompleter_ref (gpointer instance);
void email_autocompleter_unref (gpointer instance);
GParamSpec* param_spec_email_autocompleter (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void value_set_email_autocompleter (GValue* value, gpointer v_object);
void value_take_email_autocompleter (GValue* value, gpointer v_object);
gpointer value_get_email_autocompleter (const GValue* value);
GType email_autocompleter_get_type (void) G_GNUC_CONST;
#define USER_LIST_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), TYPE_USER_LIST, UserListPrivate))
enum  {
	USER_LIST_DUMMY_PROPERTY,
	USER_LIST_OFFER_GUEST,
	USER_LIST_SHOW_HIDDEN_USERS,
	USER_LIST_DEFAULT_SESSION,
	USER_LIST_SESSION
};
static void _remote_server_free0_ (gpointer var);
static void _g_list_free__remote_server_free0_ (GList* self);
static void _g_free0_ (gpointer var);
static void _g_list_free__g_free0_ (GList* self);
static GType user_list_test_entry_get_type (void) G_GNUC_CONST G_GNUC_UNUSED;
static UserListTestEntry* user_list_test_entry_dup (const UserListTestEntry* self);
static void user_list_test_entry_free (UserListTestEntry* self);
static void user_list_test_entry_copy (const UserListTestEntry* self, UserListTestEntry* dest);
static void user_list_test_entry_destroy (UserListTestEntry* self);
GType background_get_type (void) G_GNUC_CONST;
UserList* user_list_new (Background* bg);
UserList* user_list_construct (GType object_type, Background* bg);
static void user_list_remove_remote_servers (UserList* self);
void greeter_list_remove_entries_with_prefix (GreeterList* self, const gchar* prefix);
static void user_list_remove_remote_login_servers (UserList* self);
gboolean greeter_list_get_always_show_manual (GreeterList* self);
void greeter_list_add_manual_entry (GreeterList* self);
static void user_list_query_directory_servers_data_free (gpointer _data);
static void user_list_query_directory_servers (UserList* self, GAsyncReadyCallback _callback_, gpointer _user_data_);
static void user_list_query_directory_servers_finish (UserList* self, GAsyncResult* _res_);
static gboolean user_list_query_directory_servers_co (UserListQueryDirectoryServersData* _data_);
void remote_login_service_get_servers (RemoteLoginService* self, GAsyncReadyCallback _callback_, gpointer _user_data_);
void remote_login_service_get_servers_finish (RemoteLoginService* self, GAsyncResult* _res_, RemoteServer** serverList, int* serverList_length1, GError** error);
static void user_list_query_directory_servers_ready (GObject* source_object, GAsyncResult* _res_, gpointer _user_data_);
static void _vala_RemoteServer_array_free (RemoteServer* array, gint array_length);
static void user_list_set_remote_directory_servers (UserList* self, RemoteServer* server_list, int server_list_length1);
static gchar* user_list_user_list_name_for_remote_directory_server (UserList* self, RemoteServer* remote_server);
static gchar* user_list_username_from_remote_server_fields (UserList* self, RemoteServer* remote_server);
static gchar* user_list_user_list_name_for_remote_login_server (UserList* self, RemoteServer* remote_server);
static gchar* user_list_url_from_remote_loding_server_list_name (UserList* self, const gchar* remote_server_list_name);
static gchar* user_list_username_from_remote_loding_server_list_name (UserList* self, const gchar* remote_server_list_name);
PromptBox* greeter_list_find_entry (GreeterList* self, const gchar* id);
PromptBox* prompt_box_new (const gchar* id);
PromptBox* prompt_box_construct (GType object_type, const gchar* id);
void prompt_box_set_label (PromptBox* self, const gchar* value);
static void user_list_remote_directory_respond_cb (UserList* self, GAsyncReadyCallback _callback_, gpointer _user_data_);
static void user_list_remote_directory_respond_cb_finish (UserList* self, GAsyncResult* _res_);
static void _user_list_remote_directory_respond_cb_prompt_box_respond (PromptBox* _sender, gchar** response, int response_length1, gpointer self);
static void user_list_show_remote_account_dialog (UserList* self);
static void _user_list_show_remote_account_dialog_prompt_box_show_options (PromptBox* _sender, gpointer self);
void greeter_list_add_entry (GreeterList* self, PromptBox* entry);
void greeter_list_remove_entry (GreeterList* self, const gchar* name);
static PromptBox* user_list_create_prompt_for_login_server (UserList* self, RemoteServer* remote_server);
static void user_list_remote_login_respond_cb (UserList* self);
static void _user_list_remote_login_respond_cb_prompt_box_respond (PromptBox* _sender, gchar** response, int response_length1, gpointer self);
static void user_list_remote_login_servers_updated (UserList* self, const gchar* url, const gchar* email_address, const gchar* data_type, RemoteServer* server_list, int server_list_length1);
static void user_list_remote_login_changed (UserList* self, const gchar* url, const gchar* email_address);
void greeter_list_set_active_entry (GreeterList* self, const gchar* name);
static void user_list_on_remote_login_service_appeared (UserList* self, GDBusConnection* conn, const gchar* name);
static void __lambda44_ (UserList* self, GObject* obj, GAsyncResult* res);
static void _user_list_set_remote_directory_servers_remote_login_service_servers_updated (RemoteLoginService* _sender, RemoteServer* serverList, int serverList_length1, gpointer self);
static void _user_list_remote_login_servers_updated_remote_login_service_login_servers_updated (RemoteLoginService* _sender, const gchar* url, const gchar* emailAddress, const gchar* dataType, RemoteServer* serverList, int serverList_length1, gpointer self);
static void _user_list_remote_login_changed_remote_login_service_login_changed (RemoteLoginService* _sender, const gchar* url, const gchar* emailAddress, gpointer self);
static void ___lambda44__gasync_ready_callback (GObject* source_object, GAsyncResult* res, gpointer self);
static void user_list_on_remote_login_service_vanished (UserList* self, GDBusConnection* conn, const gchar* name);
gpointer unity_greeter_ref (gpointer instance);
void unity_greeter_unref (gpointer instance);
GParamSpec* param_spec_unity_greeter (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void value_set_unity_greeter (GValue* value, gpointer v_object);
void value_take_unity_greeter (GValue* value, gpointer v_object);
gpointer value_get_unity_greeter (const GValue* value);
GType unity_greeter_get_type (void) G_GNUC_CONST;
gboolean unity_greeter_hide_users_hint (UnityGreeter* self);
static void user_list_remote_directory_respond_cb_data_free (gpointer _data);
static gboolean user_list_remote_directory_respond_cb_co (UserListRemoteDirectoryRespondCbData* _data_);
GType dash_entry_get_type (void) G_GNUC_CONST;
PromptBox* greeter_list_get_selected_entry (GreeterList* self);
void prompt_box_reset_messages (PromptBox* self);
void greeter_list_show_message (GreeterList* self, const gchar* text, gboolean is_error);
static void user_list_create_remote_fields_for_current_item (UserList* self, GList* server_list, GAsyncReadyCallback _callback_, gpointer _user_data_);
static void user_list_create_remote_fields_for_current_item_finish (UserList* self, GAsyncResult* _res_);
const gchar* prompt_box_get_id (PromptBox* self);
static void user_list_test_fill_remote_login_servers (UserList* self, RemoteServer** server_list, int* server_list_length1);
static gboolean _______lambda39_ (UserList* self);
static void user_list_test_call_set_remote_directory_servers (UserList* self);
static gboolean ________lambda39__gsource_func (gpointer self);
static gboolean ________lambda40_ (UserList* self);
static void user_list_test_call_remote_login_servers_updated (UserList* self);
static gboolean _________lambda40__gsource_func (gpointer self);
static gboolean _________lambda42_ (UserList* self);
static gboolean __________lambda42__gsource_func (gpointer self);
static void user_list_test_fill_remote_login_servers_duplicate_entries (UserList* self, RemoteServer** server_list, int* server_list_length1);
gboolean prompt_box_get_has_errors (PromptBox* self);
void remote_login_service_get_servers_for_login (RemoteLoginService* self, const gchar* url, const gchar* emailAddress, const gchar* password, gboolean allowCache, GAsyncReadyCallback _callback_, gpointer _user_data_);
void remote_login_service_get_servers_for_login_finish (RemoteLoginService* self, GAsyncResult* _res_, gboolean* loginSuccess, gchar** dataType, RemoteServer** serverList, int* serverList_length1, GError** error);
static void user_list_remote_directory_respond_cb_ready (GObject* source_object, GAsyncResult* _res_, gpointer _user_data_);
void dash_entry_set_did_respond (DashEntry* self, gboolean value);
void greeter_list_set_active_first_entry_with_prefix (GreeterList* self, const gchar* prefix);
static gboolean ____lambda41_ (UserList* self);
void greeter_list_authentication_complete_cb (GreeterList* self);
static gboolean _____lambda41__gsource_func (gpointer self);
void unity_greeter_authenticate_remote (UnityGreeter* self, const gchar* session, const gchar* userid);
gchar* greeter_list_get_lightdm_session (GreeterList* self);
void remote_login_service_set_last_used_server (RemoteLoginService* self, const gchar* uccsUrl, const gchar* serverUrl, GAsyncReadyCallback _callback_, gpointer _user_data_);
void remote_login_service_set_last_used_server_finish (RemoteLoginService* self, GAsyncResult* _res_, GError** error);
static Block7Data* block7_data_ref (Block7Data* _data7_);
static void block7_data_unref (void * _userdata_);
gboolean user_list_get_offer_guest (UserList* self);
static void __lambda43_ (Block7Data* _data7_, gint id);
static gboolean user_list_is_supported_remote_session (UserList* self, const gchar* session_internal_name);
static void ___lambda43__gtk_dialog_response (GtkDialog* _sender, gint response_id, gpointer self);
static gboolean user_list_change_background_timeout_cb (UserList* self);
gboolean ug_settings_get_boolean (const gchar* key);
#define UG_SETTINGS_KEY_DRAW_USER_BACKGROUNDS "draw-user-backgrounds"
GType user_prompt_box_get_type (void) G_GNUC_CONST;
GType fading_label_get_type (void) G_GNUC_CONST;
GType flat_button_get_type (void) G_GNUC_CONST;
Background* greeter_list_get_background (GreeterList* self);
void background_set_current_background (Background* self, const gchar* value);
static void user_list_change_background (UserList* self);
const gchar* background_get_current_background (Background* self);
static gboolean _user_list_change_background_timeout_cb_gsource_func (gpointer self);
gint user_list_user_list_compare_entry (PromptBox* a, PromptBox* b);
gint greeter_list_compare_entry (PromptBox* a, PromptBox* b);
static void user_list_real_insert_entry (GreeterList* base, PromptBox* entry);
static gint _user_list_user_list_compare_entry_gcompare_func (gconstpointer a, gconstpointer b);
static void user_list_real_setup_prompt_box (GreeterList* base, gboolean fade);
void greeter_list_setup_prompt_box (GreeterList* self, gboolean fade);
void prompt_box_set_is_active (PromptBox* self, gboolean active);
static void user_list_entry_selected_cb (UserList* self, const gchar* username);
void unity_greeter_set_state (UnityGreeter* self, const gchar* key, const gchar* value);
void user_list_set_session (UserList* self, const gchar* value);
void prompt_box_clear (PromptBox* self);
void greeter_list_start_authentication (GreeterList* self);
static void user_list_real_start_authentication (GreeterList* base);
static void user_list_create_remote_fields_for_current_item_data_free (gpointer _data);
static gboolean user_list_create_remote_fields_for_current_item_co (UserListCreateRemoteFieldsForCurrentItemData* _data_);
static void _g_object_unref0_ (gpointer var);
static gint _remote_server_field_sort_function_gcompare_func (gconstpointer a, gconstpointer b);
DashEntry* greeter_list_add_prompt (GreeterList* self, const gchar* text, gboolean secret);
static Block8Data* block8_data_ref (Block8Data* _data8_);
static void block8_data_unref (void * _userdata_);
static gint ___lambda0__gcompare_data_func (gconstpointer a, gconstpointer b, gpointer self);
GtkComboBox* greeter_list_add_combo (GreeterList* self, GPtrArray* texts, gboolean read_only);
void remote_login_service_get_cached_domains_for_server (RemoteLoginService* self, const gchar* url, GAsyncReadyCallback _callback_, gpointer _user_data_);
void remote_login_service_get_cached_domains_for_server_finish (RemoteLoginService* self, GAsyncResult* _res_, gchar*** domains, int* domains_length1, GError** error);
static void user_list_create_remote_fields_for_current_item_ready (GObject* source_object, GAsyncResult* _res_, gpointer _user_data_);
static void _remote_server_field_free0_ (gpointer var);
static void _g_list_free__remote_server_field_free0_ (GList* self);
EmailAutocompleter* email_autocompleter_new (GtkEntry* e, gchar** email_domains, int email_domains_length1);
EmailAutocompleter* email_autocompleter_construct (GType object_type, GtkEntry* e, gchar** email_domains, int email_domains_length1);
static void user_list_real_focus_prompt (GreeterList* base);
void greeter_list_focus_prompt (GreeterList* self);
static void user_list_real_show_authenticated (GreeterList* base, gboolean successful);
void prompt_box_add_button (PromptBox* self, const gchar* text, const gchar* accessible_text);
const gchar* prompt_box_get_label (PromptBox* self);
void prompt_box_show_prompts (PromptBox* self);
void greeter_list_redraw_greeter_box (GreeterList* self);
void user_list_add_user (UserList* self, const gchar* name, const gchar* label, const gchar* background, gboolean is_active, gboolean has_messages, const gchar* session);
UserPromptBox* user_prompt_box_new (const gchar* name);
UserPromptBox* user_prompt_box_construct (GType object_type, const gchar* name);
void user_list_prompt_box_respond_cb (UserList* self, gchar** responses, int responses_length1);
static void _user_list_prompt_box_respond_cb_prompt_box_respond (PromptBox* _sender, gchar** response, int response_length1, gpointer self);
static void user_list_prompt_box_login_cb (UserList* self);
static void _user_list_prompt_box_login_cb_prompt_box_login (PromptBox* _sender, gpointer self);
static void user_list_prompt_box_show_options_cb (UserList* self);
static void _user_list_prompt_box_show_options_cb_prompt_box_show_options (PromptBox* _sender, gpointer self);
void prompt_box_set_show_message_icon (PromptBox* self, gboolean show);
gboolean greeter_list_have_entries (GreeterList* self);
static void user_list_real_add_manual_entry (GreeterList* base);
const gchar* greeter_list_get_manual_name (GreeterList* self);
static void user_list_test_respond (UserList* self, const gchar* text);
void unity_greeter_respond (UnityGreeter* self, const gchar* response);
gboolean unity_greeter_is_authenticated (UnityGreeter* self);
GType session_list_get_type (void) G_GNUC_CONST;
const gchar* user_list_get_session (UserList* self);
const gchar* user_list_get_default_session (UserList* self);
SessionList* session_list_new (Background* bg, const gchar* session, const gchar* default_session);
SessionList* session_list_construct (GType object_type, Background* bg, const gchar* session, const gchar* default_session);
static void user_list_session_clicked_cb (UserList* self, const gchar* session);
static void _user_list_session_clicked_cb_session_list_session_clicked (SessionList* _sender, const gchar* session, gpointer self);
void unity_greeter_push_list (UnityGreeter* self, GreeterList* widget);
void unity_greeter_pop_list (UnityGreeter* self);
static gboolean user_list_should_show_session_badge (UserList* self);
gchar* greeter_list_get_selected_id (GreeterList* self);
static GdkPixbuf* user_list_get_badge (UserList* self);
GdkPixbuf* session_list_get_badge (const gchar* session);
static gchar* user_list_real_get_lightdm_session (GreeterList* base);
static void user_list_fill_list (UserList* self);
static void user_list_test_fill_list (UserList* self);
gchar* unity_greeter_default_session_hint (UnityGreeter* self);
void user_list_set_default_session (UserList* self, const gchar* value);
gboolean unity_greeter_show_manual_login_hint (UnityGreeter* self);
void greeter_list_set_always_show_manual (GreeterList* self, gboolean value);
static void user_list_user_added_cb (UserList* self, LightDMUser* user);
static void _user_list_user_added_cb_lightdm_user_list_user_added (LightDMUserList* _sender, LightDMUser* user, gpointer self);
static void _user_list_user_added_cb_lightdm_user_list_user_changed (LightDMUserList* _sender, LightDMUser* user, gpointer self);
static void user_list_user_removed_cb (UserList* self, LightDMUser* user);
static void _user_list_user_removed_cb_lightdm_user_list_user_removed (LightDMUserList* _sender, LightDMUser* user, gpointer self);
gboolean unity_greeter_has_guest_account_hint (UnityGreeter* self);
void user_list_set_offer_guest (UserList* self, gboolean value);
gchar* unity_greeter_get_state (UnityGreeter* self, const gchar* key);
gchar* unity_greeter_select_user_hint (UnityGreeter* self);
gboolean user_list_get_show_hidden_users (UserList* self);
gchar** ug_settings_get_strv (const gchar* key, int* result_length1);
#define UG_SETTINGS_KEY_HIDDEN_USERS "hidden-users"
static void user_list_real_show_prompt_cb (GreeterList* base, const gchar* text, LightDMPromptType type);
void greeter_list_show_prompt_cb (GreeterList* self, const gchar* text, LightDMPromptType type);
static gboolean user_list_add_test_entry (UserList* self);
static gboolean user_list_test_key_press_cb (UserList* self, GdkEventKey* event);
static gboolean _user_list_test_key_press_cb_gtk_widget_key_press_event (GtkWidget* _sender, GdkEventKey* event, gpointer self);
gboolean unity_greeter_show_remote_login_hint (UnityGreeter* self);
static gboolean ___lambda45_ (UserList* self);
static void _vala_RemoteServerField_array_free (RemoteServerField* array, gint array_length);
static void _vala_array_add2 (RemoteServer** array, int* length, int* size, const RemoteServer* value);
static gboolean ____lambda45__gsource_func (gpointer self);
static void _vala_array_add3 (RemoteServer** array, int* length, int* size, const RemoteServer* value);
static void _g_variant_unref0_ (gpointer var);
static GVariant* _variant_new1 (gchar** value, gint value_length1);
static GVariant* _variant_new2 (gchar** value, gint value_length1);
static GVariant* _variant_new3 (gboolean value);
static gboolean user_list_remove_test_entry (UserList* self);
void greeter_list_show_message_cb (GreeterList* self, const gchar* text, LightDMMessageType type);
static void user_list_real_test_start_authentication (GreeterList* base);
void user_list_set_show_hidden_users (UserList* self, gboolean value);
void prompt_box_set_options_image (PromptBox* self, GdkPixbuf* image);
static GObject * user_list_constructor (GType type, guint n_construct_properties, GObjectConstructParam * construct_properties);
static void _user_list___lambda46_ (UserList* self);
static void __user_list___lambda46__greeter_list_entry_displayed_start (GreeterList* _sender, gpointer self);
static void _user_list___lambda47_ (UserList* self);
static void __user_list___lambda47__greeter_list_entry_displayed_done (GreeterList* _sender, gpointer self);
static void _user_list_entry_selected_cb_greeter_list_entry_selected (GreeterList* _sender, const gchar* name, gpointer self);
void greeter_list_connect_to_lightdm (GreeterList* self);
static void _user_list_on_remote_login_service_appeared_gbus_name_appeared_callback (GDBusConnection* connection, const gchar* name, const gchar* name_owner, gpointer self);
static void _user_list_on_remote_login_service_vanished_gbus_name_vanished_callback (GDBusConnection* connection, const gchar* name, gpointer self);
static void user_list_finalize (GObject* obj);
static void _vala_user_list_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec);
static void _vala_user_list_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec);
static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func);
static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func);
static gint _vala_array_length (gpointer array);

static const UserListTestEntry USER_LIST_test_entries[26] = {{"has-password", "Has Password", "*"}, {"different-prompt", "Different Prompt", "*"}, {"no-password", "No Password", "*"}, {"change-password", "Change Password", "*"}, {"auth-error", "Auth Error", "*"}, {"two-factor", "Two Factor", "*"}, {"two-prompts", "Two Prompts", "*"}, {"info-prompt", "Info Prompt", "*"}, {"long-info-prompt", "Long Info Prompt", "*"}, {"wide-info-prompt", "Wide Info Prompt", "*"}, {"multi-info-prompt", "Multi Info Prompt", "*"}, {"very-very-long-name", "Long name (far far too long to fit)", "*"}, {"long-name-and-messages", "Long name and messages (too long to fit)", "*", FALSE, TRUE}, {"active", "Active Account", "*", TRUE}, {"has-messages", "Has Messages", "*", FALSE, TRUE}, {"gnome", "GNOME", "*", FALSE, FALSE, "gnome"}, {"locked", "Locked Account", "*"}, {"color-background", "Color Background", "#dd4814"}, {"white-background", "White Background", "#ffffff"}, {"black-background", "Black Background", "#000000"}, {"no-background", "No Background", NULL}, {"unicode", "", "*"}, {"no-response", "No Response", "*"}, {"no-badge", "No Badge", "*"}, {"messages-after-login", "Messages After Login", "*"}, {""}};

gint remote_server_field_sort_function (RemoteServerField* item1, RemoteServerField* item2) {
	gint result = 0;
	gchar** sorted_fields = NULL;
	gchar* _tmp0_ = NULL;
	gchar* _tmp1_ = NULL;
	gchar* _tmp2_ = NULL;
	gchar* _tmp3_ = NULL;
	gchar** _tmp4_ = NULL;
	gint sorted_fields_length1 = 0;
	gint _sorted_fields_size_ = 0;
	gchar** _tmp5_ = NULL;
	gint _tmp5__length1 = 0;
	gint _tmp13_ = 0;
	RemoteServerField* _tmp14_ = NULL;
	const gchar* _tmp15_ = NULL;
	RemoteServerField* _tmp16_ = NULL;
	const gchar* _tmp17_ = NULL;
	gint _tmp18_ = 0;
	_tmp0_ = g_strdup ("domain");
	_tmp1_ = g_strdup ("username");
	_tmp2_ = g_strdup ("email");
	_tmp3_ = g_strdup ("password");
	_tmp4_ = g_new0 (gchar*, 4 + 1);
	_tmp4_[0] = _tmp0_;
	_tmp4_[1] = _tmp1_;
	_tmp4_[2] = _tmp2_;
	_tmp4_[3] = _tmp3_;
	sorted_fields = _tmp4_;
	sorted_fields_length1 = 4;
	_sorted_fields_size_ = sorted_fields_length1;
	_tmp5_ = sorted_fields;
	_tmp5__length1 = sorted_fields_length1;
	{
		gchar** field_collection = NULL;
		gint field_collection_length1 = 0;
		gint _field_collection_size_ = 0;
		gint field_it = 0;
		field_collection = _tmp5_;
		field_collection_length1 = _tmp5__length1;
		for (field_it = 0; field_it < _tmp5__length1; field_it = field_it + 1) {
			gchar* _tmp6_ = NULL;
			gchar* field = NULL;
			_tmp6_ = g_strdup (field_collection[field_it]);
			field = _tmp6_;
			{
				RemoteServerField* _tmp7_ = NULL;
				const gchar* _tmp8_ = NULL;
				const gchar* _tmp9_ = NULL;
				RemoteServerField* _tmp10_ = NULL;
				const gchar* _tmp11_ = NULL;
				const gchar* _tmp12_ = NULL;
				_tmp7_ = item1;
				_tmp8_ = (*_tmp7_).type;
				_tmp9_ = field;
				if (g_strcmp0 (_tmp8_, _tmp9_) == 0) {
					result = -1;
					_g_free0 (field);
					sorted_fields = (_vala_array_free (sorted_fields, sorted_fields_length1, (GDestroyNotify) g_free), NULL);
					return result;
				}
				_tmp10_ = item2;
				_tmp11_ = (*_tmp10_).type;
				_tmp12_ = field;
				if (g_strcmp0 (_tmp11_, _tmp12_) == 0) {
					result = 1;
					_g_free0 (field);
					sorted_fields = (_vala_array_free (sorted_fields, sorted_fields_length1, (GDestroyNotify) g_free), NULL);
					return result;
				}
				_g_free0 (field);
			}
		}
	}
	_tmp14_ = item1;
	_tmp15_ = (*_tmp14_).type;
	_tmp16_ = item2;
	_tmp17_ = (*_tmp16_).type;
	if (g_strcmp0 (_tmp15_, _tmp17_) < 0) {
		_tmp13_ = -1;
	} else {
		_tmp13_ = 0;
	}
	_tmp18_ = _tmp13_;
	result = _tmp18_;
	sorted_fields = (_vala_array_free (sorted_fields, sorted_fields_length1, (GDestroyNotify) g_free), NULL);
	return result;
}


static void _remote_server_free0_ (gpointer var) {
	(var == NULL) ? NULL : (var = (remote_server_free (var), NULL));
}


static void _g_list_free__remote_server_free0_ (GList* self) {
	g_list_foreach (self, (GFunc) _remote_server_free0_, NULL);
	g_list_free (self);
}


static void _g_free0_ (gpointer var) {
	var = (g_free (var), NULL);
}


static void _g_list_free__g_free0_ (GList* self) {
	g_list_foreach (self, (GFunc) _g_free0_, NULL);
	g_list_free (self);
}


UserList* user_list_construct (GType object_type, Background* bg) {
	UserList * self = NULL;
	Background* _tmp0_ = NULL;
	g_return_val_if_fail (bg != NULL, NULL);
	_tmp0_ = bg;
	self = (UserList*) g_object_new (object_type, "background", _tmp0_, NULL);
	return self;
}


UserList* user_list_new (Background* bg) {
	return user_list_construct (TYPE_USER_LIST, bg);
}


static void user_list_remove_remote_servers (UserList* self) {
	g_return_if_fail (self != NULL);
	__g_list_free__remote_server_free0_0 (self->priv->remote_directory_server_list);
	self->priv->remote_directory_server_list = NULL;
	__g_list_free__remote_server_free0_0 (self->priv->remote_login_server_list);
	self->priv->remote_login_server_list = NULL;
	greeter_list_remove_entries_with_prefix ((GreeterList*) self, "*remote");
}


static void user_list_remove_remote_login_servers (UserList* self) {
	gboolean _tmp0_ = FALSE;
	gboolean _tmp1_ = FALSE;
	g_return_if_fail (self != NULL);
	__g_list_free__remote_server_free0_0 (self->priv->remote_login_server_list);
	self->priv->remote_login_server_list = NULL;
	greeter_list_remove_entries_with_prefix ((GreeterList*) self, "*remote_login");
	_tmp0_ = greeter_list_get_always_show_manual ((GreeterList*) self);
	_tmp1_ = _tmp0_;
	if (!_tmp1_) {
		greeter_list_add_manual_entry ((GreeterList*) self);
	}
}


static void user_list_query_directory_servers_data_free (gpointer _data) {
	UserListQueryDirectoryServersData* _data_;
	_data_ = _data;
	_g_object_unref0 (_data_->self);
	g_slice_free (UserListQueryDirectoryServersData, _data_);
}


static gpointer _g_object_ref0 (gpointer self) {
	return self ? g_object_ref (self) : NULL;
}


static void user_list_query_directory_servers (UserList* self, GAsyncReadyCallback _callback_, gpointer _user_data_) {
	UserListQueryDirectoryServersData* _data_;
	UserList* _tmp0_ = NULL;
	_data_ = g_slice_new0 (UserListQueryDirectoryServersData);
	_data_->_async_result = g_simple_async_result_new (G_OBJECT (self), _callback_, _user_data_, user_list_query_directory_servers);
	g_simple_async_result_set_op_res_gpointer (_data_->_async_result, _data_, user_list_query_directory_servers_data_free);
	_tmp0_ = _g_object_ref0 (self);
	_data_->self = _tmp0_;
	user_list_query_directory_servers_co (_data_);
}


static void user_list_query_directory_servers_finish (UserList* self, GAsyncResult* _res_) {
	UserListQueryDirectoryServersData* _data_;
	_data_ = g_simple_async_result_get_op_res_gpointer (G_SIMPLE_ASYNC_RESULT (_res_));
}


static void user_list_query_directory_servers_ready (GObject* source_object, GAsyncResult* _res_, gpointer _user_data_) {
	UserListQueryDirectoryServersData* _data_;
	_data_ = _user_data_;
	_data_->_source_object_ = source_object;
	_data_->_res_ = _res_;
	user_list_query_directory_servers_co (_data_);
}


static void _vala_RemoteServer_array_free (RemoteServer* array, gint array_length) {
	if (array != NULL) {
		int i;
		for (i = 0; i < array_length; i = i + 1) {
			remote_server_destroy (&array[i]);
		}
	}
	g_free (array);
}


static gboolean user_list_query_directory_servers_co (UserListQueryDirectoryServersData* _data_) {
	switch (_data_->_state_) {
		case 0:
		goto _state_0;
		case 1:
		goto _state_1;
		default:
		g_assert_not_reached ();
	}
	_state_0:
	{
		_data_->server_list_length1 = 0;
		_data_->_server_list_size_ = 0;
		_data_->_tmp0_ = NULL;
		_data_->_tmp0_ = _data_->self->priv->remote_login_service;
		_data_->_tmp1_ = NULL;
		_data_->_tmp2_ = 0;
		_data_->_state_ = 1;
		remote_login_service_get_servers (_data_->_tmp0_, user_list_query_directory_servers_ready, _data_);
		return FALSE;
		_state_1:
		remote_login_service_get_servers_finish (_data_->_tmp0_, _data_->_res_, &_data_->_tmp1_, &_data_->_tmp2_, &_data_->_inner_error_);
		_data_->server_list = (_vala_RemoteServer_array_free (_data_->server_list, _data_->server_list_length1), NULL);
		_data_->server_list = _data_->_tmp1_;
		_data_->server_list_length1 = _data_->_tmp2_;
		_data_->_server_list_size_ = _data_->server_list_length1;
		if (_data_->_inner_error_ != NULL) {
			_data_->server_list = (_vala_RemoteServer_array_free (_data_->server_list, _data_->server_list_length1), NULL);
			if (_data_->_inner_error_->domain == G_IO_ERROR) {
				goto __catch38_g_io_error;
			}
			_data_->server_list = (_vala_RemoteServer_array_free (_data_->server_list, _data_->server_list_length1), NULL);
			g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _data_->_inner_error_->message, g_quark_to_string (_data_->_inner_error_->domain), _data_->_inner_error_->code);
			g_clear_error (&_data_->_inner_error_);
			return FALSE;
		}
		user_list_set_remote_directory_servers (_data_->self, _data_->server_list, _data_->server_list_length1);
		_data_->server_list = (_vala_RemoteServer_array_free (_data_->server_list, _data_->server_list_length1), NULL);
	}
	goto __finally38;
	__catch38_g_io_error:
	{
		_data_->e = _data_->_inner_error_;
		_data_->_inner_error_ = NULL;
		_data_->_tmp3_ = NULL;
		_data_->_tmp3_ = _data_->e;
		_data_->_tmp4_ = NULL;
		_data_->_tmp4_ = _data_->_tmp3_->message;
		g_debug ("user-list.vala:208: Calling GetServers on com.canonical.RemoteLogin db" \
"us service failed. Error: %s", _data_->_tmp4_);
		user_list_remove_remote_servers (_data_->self);
		_g_error_free0 (_data_->e);
	}
	__finally38:
	if (_data_->_inner_error_ != NULL) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _data_->_inner_error_->message, g_quark_to_string (_data_->_inner_error_->domain), _data_->_inner_error_->code);
		g_clear_error (&_data_->_inner_error_);
		return FALSE;
	}
	if (_data_->_state_ == 0) {
		g_simple_async_result_complete_in_idle (_data_->_async_result);
	} else {
		g_simple_async_result_complete (_data_->_async_result);
	}
	g_object_unref (_data_->_async_result);
	return FALSE;
}


static gchar* user_list_user_list_name_for_remote_directory_server (UserList* self, RemoteServer* remote_server) {
	gchar* result = NULL;
	RemoteServer _tmp0_ = {0};
	const gchar* _tmp1_ = NULL;
	gchar* _tmp2_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (remote_server != NULL, NULL);
	_tmp0_ = *remote_server;
	_tmp1_ = _tmp0_.url;
	_tmp2_ = g_strconcat ("*remote_directory*", _tmp1_, NULL);
	result = _tmp2_;
	return result;
}


static gchar* user_list_username_from_remote_server_fields (UserList* self, RemoteServer* remote_server) {
	gchar* result = NULL;
	gchar* username = NULL;
	gchar* _tmp0_ = NULL;
	RemoteServer _tmp1_ = {0};
	RemoteServerField* _tmp2_ = NULL;
	gint _tmp2__length1 = 0;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (remote_server != NULL, NULL);
	_tmp0_ = g_strdup ("");
	username = _tmp0_;
	_tmp1_ = *remote_server;
	_tmp2_ = _tmp1_.fields;
	_tmp2__length1 = _tmp1_.fields_length1;
	{
		RemoteServerField* f_collection = NULL;
		gint f_collection_length1 = 0;
		gint _f_collection_size_ = 0;
		gint f_it = 0;
		f_collection = _tmp2_;
		f_collection_length1 = _tmp2__length1;
		for (f_it = 0; f_it < _tmp2__length1; f_it = f_it + 1) {
			RemoteServerField _tmp3_ = {0};
			RemoteServerField f = {0};
			remote_server_field_copy (&f_collection[f_it], &_tmp3_);
			f = _tmp3_;
			{
				gboolean _tmp4_ = FALSE;
				RemoteServerField _tmp5_ = {0};
				const gchar* _tmp6_ = NULL;
				gboolean _tmp9_ = FALSE;
				_tmp5_ = f;
				_tmp6_ = _tmp5_.type;
				if (g_strcmp0 (_tmp6_, "username") == 0) {
					RemoteServerField _tmp7_ = {0};
					GVariant* _tmp8_ = NULL;
					_tmp7_ = f;
					_tmp8_ = _tmp7_.default_value;
					_tmp4_ = _tmp8_ != NULL;
				} else {
					_tmp4_ = FALSE;
				}
				_tmp9_ = _tmp4_;
				if (_tmp9_) {
					RemoteServerField _tmp10_ = {0};
					GVariant* _tmp11_ = NULL;
					const gchar* _tmp12_ = NULL;
					gchar* _tmp13_ = NULL;
					_tmp10_ = f;
					_tmp11_ = _tmp10_.default_value;
					_tmp12_ = g_variant_get_string (_tmp11_, NULL);
					_tmp13_ = g_strdup (_tmp12_);
					_g_free0 (username);
					username = _tmp13_;
					remote_server_field_destroy (&f);
					break;
				}
				remote_server_field_destroy (&f);
			}
		}
	}
	result = username;
	return result;
}


static gchar* user_list_user_list_name_for_remote_login_server (UserList* self, RemoteServer* remote_server) {
	gchar* result = NULL;
	gchar* username = NULL;
	RemoteServer _tmp0_ = {0};
	gchar* _tmp1_ = NULL;
	RemoteServer _tmp2_ = {0};
	const gchar* _tmp3_ = NULL;
	gchar* _tmp4_ = NULL;
	gchar* _tmp5_ = NULL;
	gchar* _tmp6_ = NULL;
	gchar* _tmp7_ = NULL;
	gchar* _tmp8_ = NULL;
	gchar* _tmp9_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (remote_server != NULL, NULL);
	_tmp0_ = *remote_server;
	_tmp1_ = user_list_username_from_remote_server_fields (self, &_tmp0_);
	username = _tmp1_;
	_tmp2_ = *remote_server;
	_tmp3_ = _tmp2_.url;
	_tmp4_ = g_strconcat ("*remote_login*", _tmp3_, NULL);
	_tmp5_ = _tmp4_;
	_tmp6_ = g_strconcat (_tmp5_, "*", NULL);
	_tmp7_ = _tmp6_;
	_tmp8_ = g_strconcat (_tmp7_, username, NULL);
	_tmp9_ = _tmp8_;
	_g_free0 (_tmp7_);
	_g_free0 (_tmp5_);
	result = _tmp9_;
	_g_free0 (username);
	return result;
}


static gchar* user_list_url_from_remote_loding_server_list_name (UserList* self, const gchar* remote_server_list_name) {
	gchar* result = NULL;
	const gchar* _tmp0_ = NULL;
	gchar** _tmp1_ = NULL;
	gchar** _tmp2_ = NULL;
	gchar** _tmp3_ = NULL;
	gint _tmp3__length1 = 0;
	const gchar* _tmp4_ = NULL;
	gchar* _tmp5_ = NULL;
	gchar* _tmp6_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (remote_server_list_name != NULL, NULL);
	_tmp0_ = remote_server_list_name;
	_tmp2_ = _tmp1_ = g_strsplit (_tmp0_, "*", 0);
	_tmp3_ = _tmp2_;
	_tmp3__length1 = _vala_array_length (_tmp1_);
	_tmp4_ = _tmp3_[2];
	_tmp5_ = g_strdup (_tmp4_);
	_tmp6_ = _tmp5_;
	_tmp3_ = (_vala_array_free (_tmp3_, _tmp3__length1, (GDestroyNotify) g_free), NULL);
	result = _tmp6_;
	return result;
}


static gchar* user_list_username_from_remote_loding_server_list_name (UserList* self, const gchar* remote_server_list_name) {
	gchar* result = NULL;
	const gchar* _tmp0_ = NULL;
	gchar** _tmp1_ = NULL;
	gchar** _tmp2_ = NULL;
	gchar** _tmp3_ = NULL;
	gint _tmp3__length1 = 0;
	const gchar* _tmp4_ = NULL;
	gchar* _tmp5_ = NULL;
	gchar* _tmp6_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (remote_server_list_name != NULL, NULL);
	_tmp0_ = remote_server_list_name;
	_tmp2_ = _tmp1_ = g_strsplit (_tmp0_, "*", 0);
	_tmp3_ = _tmp2_;
	_tmp3__length1 = _vala_array_length (_tmp1_);
	_tmp4_ = _tmp3_[3];
	_tmp5_ = g_strdup (_tmp4_);
	_tmp6_ = _tmp5_;
	_tmp3_ = (_vala_array_free (_tmp3_, _tmp3__length1, (GDestroyNotify) g_free), NULL);
	result = _tmp6_;
	return result;
}


static void _user_list_remote_directory_respond_cb_prompt_box_respond (PromptBox* _sender, gchar** response, int response_length1, gpointer self) {
	user_list_remote_directory_respond_cb (self, NULL, NULL);
}


static void _user_list_show_remote_account_dialog_prompt_box_show_options (PromptBox* _sender, gpointer self) {
	user_list_show_remote_account_dialog (self);
}


static gpointer _remote_server_dup0 (gpointer self) {
	return self ? remote_server_dup (self) : NULL;
}


static void user_list_set_remote_directory_servers (UserList* self, RemoteServer* server_list, int server_list_length1) {
	RemoteServer* _tmp0_ = NULL;
	gint _tmp0__length1 = 0;
	GList* it = NULL;
	GList* _tmp19_ = NULL;
	gboolean _tmp54_ = FALSE;
	GList* _tmp55_ = NULL;
	guint _tmp56_ = 0U;
	gboolean _tmp59_ = FALSE;
	g_return_if_fail (self != NULL);
	_tmp0_ = server_list;
	_tmp0__length1 = server_list_length1;
	{
		RemoteServer* remote_server_collection = NULL;
		gint remote_server_collection_length1 = 0;
		gint _remote_server_collection_size_ = 0;
		gint remote_server_it = 0;
		remote_server_collection = _tmp0_;
		remote_server_collection_length1 = _tmp0__length1;
		for (remote_server_it = 0; remote_server_it < _tmp0__length1; remote_server_it = remote_server_it + 1) {
			RemoteServer _tmp1_ = {0};
			RemoteServer remote_server = {0};
			remote_server_copy (&remote_server_collection[remote_server_it], &_tmp1_);
			remote_server = _tmp1_;
			{
				gchar* list_name = NULL;
				RemoteServer _tmp2_ = {0};
				gchar* _tmp3_ = NULL;
				const gchar* _tmp4_ = NULL;
				PromptBox* _tmp5_ = NULL;
				PromptBox* _tmp6_ = NULL;
				gboolean _tmp7_ = FALSE;
				_tmp2_ = remote_server;
				_tmp3_ = user_list_user_list_name_for_remote_directory_server (self, &_tmp2_);
				list_name = _tmp3_;
				_tmp4_ = list_name;
				_tmp5_ = greeter_list_find_entry ((GreeterList*) self, _tmp4_);
				_tmp6_ = _tmp5_;
				_tmp7_ = _tmp6_ == NULL;
				_g_object_unref0 (_tmp6_);
				if (_tmp7_) {
					PromptBox* e = NULL;
					const gchar* _tmp8_ = NULL;
					PromptBox* _tmp9_ = NULL;
					PromptBox* _tmp10_ = NULL;
					RemoteServer _tmp11_ = {0};
					const gchar* _tmp12_ = NULL;
					PromptBox* _tmp13_ = NULL;
					PromptBox* _tmp14_ = NULL;
					PromptBox* _tmp15_ = NULL;
					RemoteServer _tmp16_ = {0};
					RemoteServer _tmp17_ = {0};
					RemoteServer* _tmp18_ = NULL;
					_tmp8_ = list_name;
					_tmp9_ = prompt_box_new (_tmp8_);
					g_object_ref_sink (_tmp9_);
					e = _tmp9_;
					_tmp10_ = e;
					_tmp11_ = remote_server;
					_tmp12_ = _tmp11_.name;
					prompt_box_set_label (_tmp10_, _tmp12_);
					_tmp13_ = e;
					g_signal_connect_object (_tmp13_, "respond", (GCallback) _user_list_remote_directory_respond_cb_prompt_box_respond, self, 0);
					_tmp14_ = e;
					g_signal_connect_object (_tmp14_, "show-options", (GCallback) _user_list_show_remote_account_dialog_prompt_box_show_options, self, 0);
					_tmp15_ = e;
					greeter_list_add_entry ((GreeterList*) self, _tmp15_);
					_tmp16_ = remote_server;
					_tmp17_ = _tmp16_;
					_tmp18_ = _remote_server_dup0 (&_tmp17_);
					self->priv->remote_directory_server_list = g_list_append (self->priv->remote_directory_server_list, _tmp18_);
					_g_object_unref0 (e);
				}
				_g_free0 (list_name);
				remote_server_destroy (&remote_server);
			}
		}
	}
	_tmp19_ = self->priv->remote_directory_server_list;
	it = _tmp19_;
	while (TRUE) {
		GList* _tmp20_ = NULL;
		RemoteServer* remote_server = NULL;
		GList* _tmp21_ = NULL;
		gconstpointer _tmp22_ = NULL;
		RemoteServer* _tmp23_ = NULL;
		gboolean found = FALSE;
		gboolean _tmp38_ = FALSE;
		_tmp20_ = it;
		if (!(_tmp20_ != NULL)) {
			break;
		}
		_tmp21_ = it;
		_tmp22_ = _tmp21_->data;
		_tmp23_ = _remote_server_dup0 ((RemoteServer*) _tmp22_);
		remote_server = _tmp23_;
		found = FALSE;
		{
			gint i = 0;
			i = 0;
			{
				gboolean _tmp24_ = FALSE;
				_tmp24_ = TRUE;
				while (TRUE) {
					gboolean _tmp25_ = FALSE;
					gboolean _tmp27_ = FALSE;
					gboolean _tmp28_ = FALSE;
					gboolean _tmp31_ = FALSE;
					RemoteServer* _tmp32_ = NULL;
					const gchar* _tmp33_ = NULL;
					RemoteServer* _tmp34_ = NULL;
					gint _tmp34__length1 = 0;
					gint _tmp35_ = 0;
					RemoteServer _tmp36_ = {0};
					const gchar* _tmp37_ = NULL;
					_tmp25_ = _tmp24_;
					if (!_tmp25_) {
						gint _tmp26_ = 0;
						_tmp26_ = i;
						i = _tmp26_ + 1;
					}
					_tmp24_ = FALSE;
					_tmp28_ = found;
					if (!_tmp28_) {
						gint _tmp29_ = 0;
						RemoteServer* _tmp30_ = NULL;
						gint _tmp30__length1 = 0;
						_tmp29_ = i;
						_tmp30_ = server_list;
						_tmp30__length1 = server_list_length1;
						_tmp27_ = _tmp29_ < _tmp30__length1;
					} else {
						_tmp27_ = FALSE;
					}
					_tmp31_ = _tmp27_;
					if (!_tmp31_) {
						break;
					}
					_tmp32_ = remote_server;
					_tmp33_ = (*_tmp32_).url;
					_tmp34_ = server_list;
					_tmp34__length1 = server_list_length1;
					_tmp35_ = i;
					_tmp36_ = _tmp34_[_tmp35_];
					_tmp37_ = _tmp36_.url;
					found = g_strcmp0 (_tmp33_, _tmp37_) == 0;
				}
			}
		}
		_tmp38_ = found;
		if (!_tmp38_) {
			RemoteServer* _tmp39_ = NULL;
			const gchar* _tmp40_ = NULL;
			const gchar* _tmp41_ = NULL;
			RemoteServer* _tmp44_ = NULL;
			RemoteServer _tmp45_ = {0};
			gchar* _tmp46_ = NULL;
			gchar* _tmp47_ = NULL;
			GList* newIt = NULL;
			GList* _tmp48_ = NULL;
			GList* _tmp49_ = NULL;
			GList* _tmp50_ = NULL;
			GList* _tmp51_ = NULL;
			_tmp39_ = remote_server;
			_tmp40_ = (*_tmp39_).url;
			_tmp41_ = self->priv->currently_browsing_server_url;
			if (g_strcmp0 (_tmp40_, _tmp41_) == 0) {
				gchar* _tmp42_ = NULL;
				gchar* _tmp43_ = NULL;
				user_list_remove_remote_login_servers (self);
				_tmp42_ = g_strdup ("");
				_g_free0 (self->priv->currently_browsing_server_url);
				self->priv->currently_browsing_server_url = _tmp42_;
				_tmp43_ = g_strdup ("");
				_g_free0 (self->priv->currently_browsing_server_email);
				self->priv->currently_browsing_server_email = _tmp43_;
			}
			_tmp44_ = remote_server;
			_tmp45_ = *_tmp44_;
			_tmp46_ = user_list_user_list_name_for_remote_directory_server (self, &_tmp45_);
			_tmp47_ = _tmp46_;
			greeter_list_remove_entry ((GreeterList*) self, _tmp47_);
			_g_free0 (_tmp47_);
			_tmp48_ = it;
			_tmp49_ = _tmp48_->next;
			newIt = _tmp49_;
			_tmp50_ = it;
			self->priv->remote_directory_server_list = g_list_delete_link (self->priv->remote_directory_server_list, _tmp50_);
			_tmp51_ = newIt;
			it = _tmp51_;
		} else {
			GList* _tmp52_ = NULL;
			GList* _tmp53_ = NULL;
			_tmp52_ = it;
			_tmp53_ = _tmp52_->next;
			it = _tmp53_;
		}
		_remote_server_free0 (remote_server);
	}
	_tmp55_ = self->priv->remote_directory_server_list;
	_tmp56_ = g_list_length (_tmp55_);
	if (_tmp56_ > ((guint) 0)) {
		gboolean _tmp57_ = FALSE;
		gboolean _tmp58_ = FALSE;
		_tmp57_ = greeter_list_get_always_show_manual ((GreeterList*) self);
		_tmp58_ = _tmp57_;
		_tmp54_ = !_tmp58_;
	} else {
		_tmp54_ = FALSE;
	}
	_tmp59_ = _tmp54_;
	if (_tmp59_) {
		g_debug ("user-list.vala:298: removing manual login since we have a remote login" \
" entry");
		greeter_list_remove_entry ((GreeterList*) self, "*other");
	}
}


static void _user_list_remote_login_respond_cb_prompt_box_respond (PromptBox* _sender, gchar** response, int response_length1, gpointer self) {
	user_list_remote_login_respond_cb (self);
}


static PromptBox* user_list_create_prompt_for_login_server (UserList* self, RemoteServer* remote_server) {
	PromptBox* result = NULL;
	PromptBox* e = NULL;
	RemoteServer _tmp0_ = {0};
	gchar* _tmp1_ = NULL;
	gchar* _tmp2_ = NULL;
	PromptBox* _tmp3_ = NULL;
	PromptBox* _tmp4_ = NULL;
	RemoteServer _tmp5_ = {0};
	const gchar* _tmp6_ = NULL;
	RemoteServer _tmp7_ = {0};
	RemoteServer _tmp8_ = {0};
	RemoteServer* _tmp9_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (remote_server != NULL, NULL);
	_tmp0_ = *remote_server;
	_tmp1_ = user_list_user_list_name_for_remote_login_server (self, &_tmp0_);
	_tmp2_ = _tmp1_;
	_tmp3_ = prompt_box_new (_tmp2_);
	g_object_ref_sink (_tmp3_);
	_tmp4_ = _tmp3_;
	_g_free0 (_tmp2_);
	e = _tmp4_;
	_tmp5_ = *remote_server;
	_tmp6_ = _tmp5_.name;
	prompt_box_set_label (e, _tmp6_);
	g_signal_connect_object (e, "respond", (GCallback) _user_list_remote_login_respond_cb_prompt_box_respond, self, 0);
	greeter_list_add_entry ((GreeterList*) self, e);
	_tmp7_ = *remote_server;
	_tmp8_ = _tmp7_;
	_tmp9_ = _remote_server_dup0 (&_tmp8_);
	self->priv->remote_login_server_list = g_list_append (self->priv->remote_login_server_list, _tmp9_);
	result = e;
	return result;
}


static void user_list_remote_login_servers_updated (UserList* self, const gchar* url, const gchar* email_address, const gchar* data_type, RemoteServer* server_list, int server_list_length1) {
	gboolean _tmp0_ = FALSE;
	const gchar* _tmp1_ = NULL;
	const gchar* _tmp2_ = NULL;
	gboolean _tmp5_ = FALSE;
	g_return_if_fail (self != NULL);
	g_return_if_fail (url != NULL);
	g_return_if_fail (email_address != NULL);
	g_return_if_fail (data_type != NULL);
	_tmp1_ = self->priv->currently_browsing_server_url;
	_tmp2_ = url;
	if (g_strcmp0 (_tmp1_, _tmp2_) == 0) {
		const gchar* _tmp3_ = NULL;
		const gchar* _tmp4_ = NULL;
		_tmp3_ = self->priv->currently_browsing_server_email;
		_tmp4_ = email_address;
		_tmp0_ = g_strcmp0 (_tmp3_, _tmp4_) == 0;
	} else {
		_tmp0_ = FALSE;
	}
	_tmp5_ = _tmp0_;
	if (_tmp5_) {
		RemoteServer* _tmp6_ = NULL;
		gint _tmp6__length1 = 0;
		GList* it = NULL;
		GList* _tmp17_ = NULL;
		_tmp6_ = server_list;
		_tmp6__length1 = server_list_length1;
		{
			RemoteServer* remote_server_collection = NULL;
			gint remote_server_collection_length1 = 0;
			gint _remote_server_collection_size_ = 0;
			gint remote_server_it = 0;
			remote_server_collection = _tmp6_;
			remote_server_collection_length1 = _tmp6__length1;
			for (remote_server_it = 0; remote_server_it < _tmp6__length1; remote_server_it = remote_server_it + 1) {
				RemoteServer _tmp7_ = {0};
				RemoteServer remote_server = {0};
				remote_server_copy (&remote_server_collection[remote_server_it], &_tmp7_);
				remote_server = _tmp7_;
				{
					gchar* list_name = NULL;
					RemoteServer _tmp8_ = {0};
					gchar* _tmp9_ = NULL;
					const gchar* _tmp10_ = NULL;
					PromptBox* _tmp11_ = NULL;
					PromptBox* _tmp12_ = NULL;
					gboolean _tmp13_ = FALSE;
					_tmp8_ = remote_server;
					_tmp9_ = user_list_user_list_name_for_remote_login_server (self, &_tmp8_);
					list_name = _tmp9_;
					_tmp10_ = list_name;
					_tmp11_ = greeter_list_find_entry ((GreeterList*) self, _tmp10_);
					_tmp12_ = _tmp11_;
					_tmp13_ = _tmp12_ == NULL;
					_g_object_unref0 (_tmp12_);
					if (_tmp13_) {
						RemoteServer _tmp14_ = {0};
						PromptBox* _tmp15_ = NULL;
						PromptBox* _tmp16_ = NULL;
						_tmp14_ = remote_server;
						_tmp15_ = user_list_create_prompt_for_login_server (self, &_tmp14_);
						_tmp16_ = _tmp15_;
						_g_object_unref0 (_tmp16_);
					}
					_g_free0 (list_name);
					remote_server_destroy (&remote_server);
				}
			}
		}
		_tmp17_ = self->priv->remote_login_server_list;
		it = _tmp17_;
		while (TRUE) {
			GList* _tmp18_ = NULL;
			RemoteServer remote_server = {0};
			GList* _tmp19_ = NULL;
			gconstpointer _tmp20_ = NULL;
			RemoteServer _tmp21_ = {0};
			gboolean found = FALSE;
			gboolean _tmp36_ = FALSE;
			_tmp18_ = it;
			if (!(_tmp18_ != NULL)) {
				break;
			}
			_tmp19_ = it;
			_tmp20_ = _tmp19_->data;
			remote_server_copy ((RemoteServer*) _tmp20_, &_tmp21_);
			remote_server = _tmp21_;
			found = FALSE;
			{
				gint i = 0;
				i = 0;
				{
					gboolean _tmp22_ = FALSE;
					_tmp22_ = TRUE;
					while (TRUE) {
						gboolean _tmp23_ = FALSE;
						gboolean _tmp25_ = FALSE;
						gboolean _tmp26_ = FALSE;
						gboolean _tmp29_ = FALSE;
						RemoteServer _tmp30_ = {0};
						const gchar* _tmp31_ = NULL;
						RemoteServer* _tmp32_ = NULL;
						gint _tmp32__length1 = 0;
						gint _tmp33_ = 0;
						RemoteServer _tmp34_ = {0};
						const gchar* _tmp35_ = NULL;
						_tmp23_ = _tmp22_;
						if (!_tmp23_) {
							gint _tmp24_ = 0;
							_tmp24_ = i;
							i = _tmp24_ + 1;
						}
						_tmp22_ = FALSE;
						_tmp26_ = found;
						if (!_tmp26_) {
							gint _tmp27_ = 0;
							RemoteServer* _tmp28_ = NULL;
							gint _tmp28__length1 = 0;
							_tmp27_ = i;
							_tmp28_ = server_list;
							_tmp28__length1 = server_list_length1;
							_tmp25_ = _tmp27_ < _tmp28__length1;
						} else {
							_tmp25_ = FALSE;
						}
						_tmp29_ = _tmp25_;
						if (!_tmp29_) {
							break;
						}
						_tmp30_ = remote_server;
						_tmp31_ = _tmp30_.url;
						_tmp32_ = server_list;
						_tmp32__length1 = server_list_length1;
						_tmp33_ = i;
						_tmp34_ = _tmp32_[_tmp33_];
						_tmp35_ = _tmp34_.url;
						found = g_strcmp0 (_tmp31_, _tmp35_) == 0;
					}
				}
			}
			_tmp36_ = found;
			if (!_tmp36_) {
				RemoteServer _tmp37_ = {0};
				gchar* _tmp38_ = NULL;
				gchar* _tmp39_ = NULL;
				GList* newIt = NULL;
				GList* _tmp40_ = NULL;
				GList* _tmp41_ = NULL;
				GList* _tmp42_ = NULL;
				GList* _tmp43_ = NULL;
				_tmp37_ = remote_server;
				_tmp38_ = user_list_user_list_name_for_remote_login_server (self, &_tmp37_);
				_tmp39_ = _tmp38_;
				greeter_list_remove_entry ((GreeterList*) self, _tmp39_);
				_g_free0 (_tmp39_);
				_tmp40_ = it;
				_tmp41_ = _tmp40_->next;
				newIt = _tmp41_;
				_tmp42_ = it;
				self->priv->remote_login_server_list = g_list_delete_link (self->priv->remote_login_server_list, _tmp42_);
				_tmp43_ = newIt;
				it = _tmp43_;
			} else {
				GList* _tmp44_ = NULL;
				GList* _tmp45_ = NULL;
				_tmp44_ = it;
				_tmp45_ = _tmp44_->next;
				it = _tmp45_;
			}
			remote_server_destroy (&remote_server);
		}
	}
}


static void user_list_remote_login_changed (UserList* self, const gchar* url, const gchar* email_address) {
	gboolean _tmp0_ = FALSE;
	const gchar* _tmp1_ = NULL;
	const gchar* _tmp2_ = NULL;
	gboolean _tmp5_ = FALSE;
	g_return_if_fail (self != NULL);
	g_return_if_fail (url != NULL);
	g_return_if_fail (email_address != NULL);
	_tmp1_ = self->priv->currently_browsing_server_url;
	_tmp2_ = url;
	if (g_strcmp0 (_tmp1_, _tmp2_) == 0) {
		const gchar* _tmp3_ = NULL;
		const gchar* _tmp4_ = NULL;
		_tmp3_ = self->priv->currently_browsing_server_email;
		_tmp4_ = email_address;
		_tmp0_ = g_strcmp0 (_tmp3_, _tmp4_) == 0;
	} else {
		_tmp0_ = FALSE;
	}
	_tmp5_ = _tmp0_;
	if (_tmp5_) {
		gchar* _tmp6_ = NULL;
		gchar* _tmp7_ = NULL;
		gchar* directory_list_name = NULL;
		const gchar* _tmp8_ = NULL;
		gchar* _tmp9_ = NULL;
		const gchar* _tmp10_ = NULL;
		user_list_remove_remote_login_servers (self);
		_tmp6_ = g_strdup ("");
		_g_free0 (self->priv->currently_browsing_server_url);
		self->priv->currently_browsing_server_url = _tmp6_;
		_tmp7_ = g_strdup ("");
		_g_free0 (self->priv->currently_browsing_server_email);
		self->priv->currently_browsing_server_email = _tmp7_;
		_tmp8_ = url;
		_tmp9_ = g_strconcat ("*remote_directory*", _tmp8_, NULL);
		directory_list_name = _tmp9_;
		_tmp10_ = directory_list_name;
		greeter_list_set_active_entry ((GreeterList*) self, _tmp10_);
		_g_free0 (directory_list_name);
	}
}


static void _user_list_set_remote_directory_servers_remote_login_service_servers_updated (RemoteLoginService* _sender, RemoteServer* serverList, int serverList_length1, gpointer self) {
	user_list_set_remote_directory_servers (self, serverList, serverList_length1);
}


static void _user_list_remote_login_servers_updated_remote_login_service_login_servers_updated (RemoteLoginService* _sender, const gchar* url, const gchar* emailAddress, const gchar* dataType, RemoteServer* serverList, int serverList_length1, gpointer self) {
	user_list_remote_login_servers_updated (self, url, emailAddress, dataType, serverList, serverList_length1);
}


static void _user_list_remote_login_changed_remote_login_service_login_changed (RemoteLoginService* _sender, const gchar* url, const gchar* emailAddress, gpointer self) {
	user_list_remote_login_changed (self, url, emailAddress);
}


static void __lambda44_ (UserList* self, GObject* obj, GAsyncResult* res) {
	GError * _inner_error_ = NULL;
	g_return_if_fail (res != NULL);
	{
		RemoteLoginService* _tmp0_ = NULL;
		GAsyncResult* _tmp1_ = NULL;
		RemoteLoginService* _tmp2_ = NULL;
		RemoteLoginService* _tmp3_ = NULL;
		RemoteLoginService* _tmp4_ = NULL;
		RemoteLoginService* _tmp5_ = NULL;
		RemoteLoginService* _tmp6_ = NULL;
		_tmp1_ = res;
		_tmp2_ = g_async_result_get_source_object (_tmp1_);
		_tmp3_ = g_async_initable_new_finish (_tmp2_, _tmp1_, &_inner_error_);
		g_object_unref (_tmp2_);
		_tmp0_ = (RemoteLoginService*) _tmp3_;
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == G_IO_ERROR) {
				goto __catch39_g_io_error;
			}
			g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return;
		}
		_g_object_unref0 (self->priv->remote_login_service);
		self->priv->remote_login_service = _tmp0_;
		_tmp4_ = self->priv->remote_login_service;
		g_signal_connect_object (_tmp4_, "servers-updated", (GCallback) _user_list_set_remote_directory_servers_remote_login_service_servers_updated, self, 0);
		_tmp5_ = self->priv->remote_login_service;
		g_signal_connect_object (_tmp5_, "login-servers-updated", (GCallback) _user_list_remote_login_servers_updated_remote_login_service_login_servers_updated, self, 0);
		_tmp6_ = self->priv->remote_login_service;
		g_signal_connect_object (_tmp6_, "login-changed", (GCallback) _user_list_remote_login_changed_remote_login_service_login_changed, self, 0);
		user_list_query_directory_servers (self, NULL, NULL);
	}
	goto __finally39;
	__catch39_g_io_error:
	{
		GError* e = NULL;
		GError* _tmp7_ = NULL;
		const gchar* _tmp8_ = NULL;
		e = _inner_error_;
		_inner_error_ = NULL;
		_tmp7_ = e;
		_tmp8_ = _tmp7_->message;
		g_debug ("user-list.vala:381: Getting the com.canonical.RemoteLogin dbus service" \
" failed. Error: %s", _tmp8_);
		user_list_remove_remote_servers (self);
		_g_object_unref0 (self->priv->remote_login_service);
		self->priv->remote_login_service = NULL;
		_g_error_free0 (e);
	}
	__finally39:
	if (_inner_error_ != NULL) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return;
	}
}


static void ___lambda44__gasync_ready_callback (GObject* source_object, GAsyncResult* res, gpointer self) {
	__lambda44_ (self, source_object, res);
	g_object_unref (self);
}


static void user_list_on_remote_login_service_appeared (UserList* self, GDBusConnection* conn, const gchar* name) {
	GError * _inner_error_ = NULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (conn != NULL);
	g_return_if_fail (name != NULL);
	g_async_initable_new_async (TYPE_REMOTE_LOGIN_SERVICE_PROXY, 0, NULL, ___lambda44__gasync_ready_callback, g_object_ref (self), "g-flags", 0, "g-name", "com.canonical.RemoteLogin", "g-bus-type", G_BUS_TYPE_SESSION, "g-object-path", "/com/canonical/RemoteLogin", "g-interface-name", "com.canonical.RemoteLogin", NULL);
}


static void user_list_on_remote_login_service_vanished (UserList* self, GDBusConnection* conn, const gchar* name) {
	UnityGreeter* _tmp0_ = NULL;
	gboolean _tmp1_ = FALSE;
	g_return_if_fail (self != NULL);
	g_return_if_fail (conn != NULL);
	g_return_if_fail (name != NULL);
	user_list_remove_remote_servers (self);
	_g_object_unref0 (self->priv->remote_login_service);
	self->priv->remote_login_service = NULL;
	_tmp0_ = unity_greeter_singleton;
	_tmp1_ = unity_greeter_hide_users_hint (_tmp0_);
	if (_tmp1_) {
		greeter_list_add_manual_entry ((GreeterList*) self);
		greeter_list_set_active_entry ((GreeterList*) self, "*other");
	}
}


static void user_list_remote_directory_respond_cb_data_free (gpointer _data) {
	UserListRemoteDirectoryRespondCbData* _data_;
	_data_ = _data;
	_g_object_unref0 (_data_->self);
	g_slice_free (UserListRemoteDirectoryRespondCbData, _data_);
}


static void user_list_remote_directory_respond_cb (UserList* self, GAsyncReadyCallback _callback_, gpointer _user_data_) {
	UserListRemoteDirectoryRespondCbData* _data_;
	UserList* _tmp0_ = NULL;
	_data_ = g_slice_new0 (UserListRemoteDirectoryRespondCbData);
	_data_->_async_result = g_simple_async_result_new (G_OBJECT (self), _callback_, _user_data_, user_list_remote_directory_respond_cb);
	g_simple_async_result_set_op_res_gpointer (_data_->_async_result, _data_, user_list_remote_directory_respond_cb_data_free);
	_tmp0_ = _g_object_ref0 (self);
	_data_->self = _tmp0_;
	user_list_remote_directory_respond_cb_co (_data_);
}


static void user_list_remote_directory_respond_cb_finish (UserList* self, GAsyncResult* _res_) {
	UserListRemoteDirectoryRespondCbData* _data_;
	_data_ = g_simple_async_result_get_op_res_gpointer (G_SIMPLE_ASYNC_RESULT (_res_));
}


static gboolean _______lambda39_ (UserList* self) {
	gboolean result = FALSE;
	user_list_test_call_set_remote_directory_servers (self);
	result = FALSE;
	return result;
}


static gboolean ________lambda39__gsource_func (gpointer self) {
	gboolean result;
	result = _______lambda39_ (self);
	return result;
}


static gboolean ________lambda40_ (UserList* self) {
	gboolean result = FALSE;
	user_list_test_call_remote_login_servers_updated (self);
	result = FALSE;
	return result;
}


static gboolean _________lambda40__gsource_func (gpointer self) {
	gboolean result;
	result = ________lambda40_ (self);
	return result;
}


static gboolean _________lambda42_ (UserList* self) {
	gboolean result = FALSE;
	const gchar* _tmp0_ = NULL;
	const gchar* _tmp1_ = NULL;
	_tmp0_ = self->priv->currently_browsing_server_url;
	_tmp1_ = self->priv->currently_browsing_server_email;
	user_list_remote_login_changed (self, _tmp0_, _tmp1_);
	result = FALSE;
	return result;
}


static gboolean __________lambda42__gsource_func (gpointer self) {
	gboolean result;
	result = _________lambda42_ (self);
	return result;
}


static void user_list_remote_directory_respond_cb_ready (GObject* source_object, GAsyncResult* _res_, gpointer _user_data_) {
	UserListRemoteDirectoryRespondCbData* _data_;
	_data_ = _user_data_;
	_data_->_source_object_ = source_object;
	_data_->_res_ = _res_;
	user_list_remote_directory_respond_cb_co (_data_);
}


static gboolean user_list_remote_directory_respond_cb_co (UserListRemoteDirectoryRespondCbData* _data_) {
	switch (_data_->_state_) {
		case 0:
		goto _state_0;
		case 1:
		goto _state_1;
		default:
		g_assert_not_reached ();
	}
	_state_0:
	user_list_remove_remote_login_servers (_data_->self);
	_data_->_tmp0_ = NULL;
	_data_->_tmp0_ = g_strdup ("");
	_g_free0 (_data_->self->priv->currently_browsing_server_url);
	_data_->self->priv->currently_browsing_server_url = _data_->_tmp0_;
	_data_->_tmp1_ = NULL;
	_data_->_tmp1_ = g_strdup ("");
	_g_free0 (_data_->self->priv->currently_browsing_server_email);
	_data_->self->priv->currently_browsing_server_email = _data_->_tmp1_;
	_data_->_tmp2_ = NULL;
	_data_->_tmp2_ = _data_->self->priv->current_remote_fields;
	_data_->_tmp3_ = NULL;
	_data_->_tmp3_ = g_hash_table_lookup (_data_->_tmp2_, "password");
	_data_->_tmp4_ = NULL;
	_data_->_tmp4_ = (GtkWidget*) _data_->_tmp3_;
	_data_->_tmp5_ = NULL;
	_data_->_tmp5_ = _g_object_ref0 (G_TYPE_CHECK_INSTANCE_TYPE (_data_->_tmp4_, TYPE_DASH_ENTRY) ? ((DashEntry*) _data_->_tmp4_) : NULL);
	_data_->password_field = _data_->_tmp5_;
	_data_->_tmp6_ = NULL;
	_data_->_tmp6_ = _data_->self->priv->current_remote_fields;
	_data_->_tmp7_ = NULL;
	_data_->_tmp7_ = g_hash_table_lookup (_data_->_tmp6_, "email");
	_data_->_tmp8_ = NULL;
	_data_->_tmp8_ = (GtkWidget*) _data_->_tmp7_;
	_data_->_tmp9_ = NULL;
	_data_->_tmp9_ = _g_object_ref0 (G_TYPE_CHECK_INSTANCE_TYPE (_data_->_tmp8_, GTK_TYPE_ENTRY) ? ((GtkEntry*) _data_->_tmp8_) : NULL);
	_data_->email_field = _data_->_tmp9_;
	_data_->_tmp10_ = NULL;
	_data_->_tmp10_ = _data_->password_field;
	if (_data_->_tmp10_ == NULL) {
		g_debug ("user-list.vala:411: Something wrong happened in remote_directory_respo" \
"nd_cb. There was no password field");
		_g_object_unref0 (_data_->email_field);
		_g_object_unref0 (_data_->password_field);
		if (_data_->_state_ == 0) {
			g_simple_async_result_complete_in_idle (_data_->_async_result);
		} else {
			g_simple_async_result_complete (_data_->_async_result);
		}
		g_object_unref (_data_->_async_result);
		return FALSE;
	}
	_data_->_tmp11_ = NULL;
	_data_->_tmp11_ = _data_->email_field;
	if (_data_->_tmp11_ == NULL) {
		g_debug ("user-list.vala:416: Something wrong happened in remote_directory_respo" \
"nd_cb. There was no email field");
		_g_object_unref0 (_data_->email_field);
		_g_object_unref0 (_data_->password_field);
		if (_data_->_state_ == 0) {
			g_simple_async_result_complete_in_idle (_data_->_async_result);
		} else {
			g_simple_async_result_complete (_data_->_async_result);
		}
		g_object_unref (_data_->_async_result);
		return FALSE;
	}
	_data_->_tmp12_ = NULL;
	_data_->_tmp12_ = g_new0 (RemoteServer, 0);
	_data_->server_list_length1 = 0;
	_data_->_server_list_size_ = 0;
	_data_->server_list = _data_->_tmp12_;
	_data_->server_list_length1 = 0;
	_data_->_server_list_size_ = _data_->server_list_length1;
	_data_->_tmp13_ = NULL;
	_data_->_tmp13_ = _data_->email_field;
	_data_->_tmp14_ = NULL;
	_data_->_tmp14_ = gtk_entry_get_text (_data_->_tmp13_);
	_data_->_tmp15_ = NULL;
	_data_->_tmp15_ = _data_->_tmp14_;
	_data_->_tmp16_ = NULL;
	_data_->_tmp16_ = g_strdup (_data_->_tmp15_);
	_data_->email = _data_->_tmp16_;
	_data_->email_valid = FALSE;
	{
		_data_->_tmp17_ = NULL;
		_data_->_tmp17_ = g_regex_new ("[a-zA-Z0-9.!#$%&'\\*\\+/=?^_`{|}~-]+@[a-zA-Z0-9-]+(?:\\.[a-zA-Z0-9-]+)" \
"*", 0, 0, &_data_->_inner_error_);
		_data_->re = _data_->_tmp17_;
		if (_data_->_inner_error_ != NULL) {
			if (_data_->_inner_error_->domain == G_REGEX_ERROR) {
				goto __catch40_g_regex_error;
			}
			_g_free0 (_data_->email);
			_data_->server_list = (_vala_RemoteServer_array_free (_data_->server_list, _data_->server_list_length1), NULL);
			_g_object_unref0 (_data_->email_field);
			_g_object_unref0 (_data_->password_field);
			g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _data_->_inner_error_->message, g_quark_to_string (_data_->_inner_error_->domain), _data_->_inner_error_->code);
			g_clear_error (&_data_->_inner_error_);
			return FALSE;
		}
		_data_->_tmp18_ = NULL;
		_data_->_tmp18_ = _data_->re;
		_data_->_tmp19_ = NULL;
		_data_->_tmp19_ = _data_->email;
		_data_->_tmp20_ = NULL;
		_data_->_tmp21_ = FALSE;
		_data_->_tmp21_ = g_regex_match_all (_data_->_tmp18_, _data_->_tmp19_, 0, &_data_->_tmp20_);
		_g_match_info_unref0 (_data_->info);
		_data_->info = _data_->_tmp20_;
		_data_->email_valid = _data_->_tmp21_;
		_data_->_tmp24_ = FALSE;
		_data_->_tmp24_ = _data_->email_valid;
		if (_data_->_tmp24_) {
			_data_->_tmp25_ = NULL;
			_data_->_tmp25_ = _data_->info;
			_data_->_tmp26_ = 0;
			_data_->_tmp26_ = g_match_info_get_match_count (_data_->_tmp25_);
			_data_->_tmp23_ = _data_->_tmp26_ > 0;
		} else {
			_data_->_tmp23_ = FALSE;
		}
		_data_->_tmp27_ = FALSE;
		_data_->_tmp27_ = _data_->_tmp23_;
		if (_data_->_tmp27_) {
			_data_->_tmp28_ = NULL;
			_data_->_tmp28_ = _data_->info;
			_data_->_tmp29_ = NULL;
			_data_->_tmp29_ = g_match_info_fetch (_data_->_tmp28_, 0);
			_data_->_tmp30_ = NULL;
			_data_->_tmp30_ = _data_->_tmp29_;
			_data_->_tmp31_ = NULL;
			_data_->_tmp31_ = _data_->email;
			_data_->_tmp22_ = g_strcmp0 (_data_->_tmp30_, _data_->_tmp31_) == 0;
			_g_free0 (_data_->_tmp30_);
		} else {
			_data_->_tmp22_ = FALSE;
		}
		_data_->_tmp32_ = FALSE;
		_data_->_tmp32_ = _data_->_tmp22_;
		_data_->email_valid = _data_->_tmp32_;
		_g_match_info_unref0 (_data_->info);
		_g_regex_unref0 (_data_->re);
	}
	goto __finally40;
	__catch40_g_regex_error:
	{
		_data_->e = _data_->_inner_error_;
		_data_->_inner_error_ = NULL;
		_data_->_tmp33_ = NULL;
		_data_->_tmp33_ = _data_->e;
		_data_->_tmp34_ = NULL;
		_data_->_tmp34_ = _data_->_tmp33_->message;
		g_debug ("user-list.vala:435: Calling email regex match failed. Error: %s", _data_->_tmp34_);
		_g_error_free0 (_data_->e);
	}
	__finally40:
	if (_data_->_inner_error_ != NULL) {
		_g_free0 (_data_->email);
		_data_->server_list = (_vala_RemoteServer_array_free (_data_->server_list, _data_->server_list_length1), NULL);
		_g_object_unref0 (_data_->email_field);
		_g_object_unref0 (_data_->password_field);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _data_->_inner_error_->message, g_quark_to_string (_data_->_inner_error_->domain), _data_->_inner_error_->code);
		g_clear_error (&_data_->_inner_error_);
		return FALSE;
	}
	_data_->_tmp35_ = NULL;
	_data_->_tmp35_ = greeter_list_get_selected_entry ((GreeterList*) _data_->self);
	_data_->_tmp36_ = NULL;
	_data_->_tmp36_ = _data_->_tmp35_;
	prompt_box_reset_messages (_data_->_tmp36_);
	_data_->_tmp37_ = FALSE;
	_data_->_tmp37_ = _data_->email_valid;
	if (!_data_->_tmp37_) {
		((GreeterList*) _data_->self)->will_clear = TRUE;
		_data_->_tmp38_ = NULL;
		_data_->_tmp38_ = _ ("Please enter a complete e-mail address");
		greeter_list_show_message ((GreeterList*) _data_->self, _data_->_tmp38_, TRUE);
		_data_->_tmp39_ = NULL;
		_data_->_tmp39_ = _data_->self->priv->remote_directory_server_list;
		user_list_create_remote_fields_for_current_item (_data_->self, _data_->_tmp39_, NULL, NULL);
	} else {
		_data_->login_success = FALSE;
		{
			_data_->_tmp40_ = NULL;
			_data_->_tmp40_ = greeter_list_get_selected_entry ((GreeterList*) _data_->self);
			_data_->_tmp41_ = NULL;
			_data_->_tmp41_ = _data_->_tmp40_;
			_data_->_tmp42_ = NULL;
			_data_->_tmp42_ = prompt_box_get_id (_data_->_tmp41_);
			_data_->_tmp43_ = NULL;
			_data_->_tmp43_ = _data_->_tmp42_;
			_data_->_tmp44_ = NULL;
			_data_->_tmp44_ = user_list_url_from_remote_loding_server_list_name (_data_->self, _data_->_tmp43_);
			_data_->url = _data_->_tmp44_;
			_data_->_tmp45_ = NULL;
			_data_->_tmp45_ = unity_greeter_singleton;
			_data_->_tmp46_ = FALSE;
			_data_->_tmp46_ = _data_->_tmp45_->test_mode;
			if (_data_->_tmp46_) {
				_data_->_tmp47_ = NULL;
				_data_->_tmp47_ = _data_->password_field;
				_data_->_tmp48_ = NULL;
				_data_->_tmp48_ = gtk_entry_get_text ((GtkEntry*) _data_->_tmp47_);
				_data_->_tmp49_ = NULL;
				_data_->_tmp49_ = _data_->_tmp48_;
				if (g_strcmp0 (_data_->_tmp49_, "password") == 0) {
					_data_->_tmp50_ = NULL;
					_data_->_tmp51_ = 0;
					user_list_test_fill_remote_login_servers (_data_->self, &_data_->_tmp50_, &_data_->_tmp51_);
					_data_->server_list = (_vala_RemoteServer_array_free (_data_->server_list, _data_->server_list_length1), NULL);
					_data_->server_list = _data_->_tmp50_;
					_data_->server_list_length1 = _data_->_tmp51_;
					_data_->_server_list_size_ = _data_->server_list_length1;
					_data_->login_success = TRUE;
				} else {
					_data_->_tmp52_ = NULL;
					_data_->_tmp52_ = _data_->password_field;
					_data_->_tmp53_ = NULL;
					_data_->_tmp53_ = gtk_entry_get_text ((GtkEntry*) _data_->_tmp52_);
					_data_->_tmp54_ = NULL;
					_data_->_tmp54_ = _data_->_tmp53_;
					if (g_strcmp0 (_data_->_tmp54_, "delay1") == 0) {
						_data_->_tmp55_ = NULL;
						_data_->_tmp56_ = 0;
						user_list_test_fill_remote_login_servers (_data_->self, &_data_->_tmp55_, &_data_->_tmp56_);
						_data_->server_list = (_vala_RemoteServer_array_free (_data_->server_list, _data_->server_list_length1), NULL);
						_data_->server_list = _data_->_tmp55_;
						_data_->server_list_length1 = _data_->_tmp56_;
						_data_->_server_list_size_ = _data_->server_list_length1;
						_data_->login_success = TRUE;
						g_timeout_add_full (G_PRIORITY_DEFAULT, (guint) 5000, ________lambda39__gsource_func, g_object_ref (_data_->self), g_object_unref);
					} else {
						_data_->_tmp57_ = NULL;
						_data_->_tmp57_ = _data_->password_field;
						_data_->_tmp58_ = NULL;
						_data_->_tmp58_ = gtk_entry_get_text ((GtkEntry*) _data_->_tmp57_);
						_data_->_tmp59_ = NULL;
						_data_->_tmp59_ = _data_->_tmp58_;
						if (g_strcmp0 (_data_->_tmp59_, "delay2") == 0) {
							_data_->_tmp60_ = NULL;
							_data_->_tmp61_ = 0;
							user_list_test_fill_remote_login_servers (_data_->self, &_data_->_tmp60_, &_data_->_tmp61_);
							_data_->server_list = (_vala_RemoteServer_array_free (_data_->server_list, _data_->server_list_length1), NULL);
							_data_->server_list = _data_->_tmp60_;
							_data_->server_list_length1 = _data_->_tmp61_;
							_data_->_server_list_size_ = _data_->server_list_length1;
							_data_->login_success = TRUE;
							g_timeout_add_full (G_PRIORITY_DEFAULT, (guint) 5000, _________lambda40__gsource_func, g_object_ref (_data_->self), g_object_unref);
						} else {
							_data_->_tmp62_ = NULL;
							_data_->_tmp62_ = _data_->password_field;
							_data_->_tmp63_ = NULL;
							_data_->_tmp63_ = gtk_entry_get_text ((GtkEntry*) _data_->_tmp62_);
							_data_->_tmp64_ = NULL;
							_data_->_tmp64_ = _data_->_tmp63_;
							if (g_strcmp0 (_data_->_tmp64_, "delay3") == 0) {
								_data_->_tmp65_ = NULL;
								_data_->_tmp66_ = 0;
								user_list_test_fill_remote_login_servers (_data_->self, &_data_->_tmp65_, &_data_->_tmp66_);
								_data_->server_list = (_vala_RemoteServer_array_free (_data_->server_list, _data_->server_list_length1), NULL);
								_data_->server_list = _data_->_tmp65_;
								_data_->server_list_length1 = _data_->_tmp66_;
								_data_->_server_list_size_ = _data_->server_list_length1;
								_data_->login_success = TRUE;
								g_timeout_add_full (G_PRIORITY_DEFAULT, (guint) 5000, __________lambda42__gsource_func, g_object_ref (_data_->self), g_object_unref);
							} else {
								_data_->_tmp67_ = NULL;
								_data_->_tmp67_ = _data_->password_field;
								_data_->_tmp68_ = NULL;
								_data_->_tmp68_ = gtk_entry_get_text ((GtkEntry*) _data_->_tmp67_);
								_data_->_tmp69_ = NULL;
								_data_->_tmp69_ = _data_->_tmp68_;
								if (g_strcmp0 (_data_->_tmp69_, "duplicate") == 0) {
									_data_->_tmp70_ = NULL;
									_data_->_tmp71_ = 0;
									user_list_test_fill_remote_login_servers_duplicate_entries (_data_->self, &_data_->_tmp70_, &_data_->_tmp71_);
									_data_->server_list = (_vala_RemoteServer_array_free (_data_->server_list, _data_->server_list_length1), NULL);
									_data_->server_list = _data_->_tmp70_;
									_data_->server_list_length1 = _data_->_tmp71_;
									_data_->_server_list_size_ = _data_->server_list_length1;
									_data_->login_success = TRUE;
								}
							}
						}
					}
				}
			} else {
				_data_->allowcache = TRUE;
				_data_->_tmp74_ = NULL;
				_data_->_tmp74_ = greeter_list_get_selected_entry ((GreeterList*) _data_->self);
				_data_->_tmp75_ = NULL;
				_data_->_tmp75_ = _data_->_tmp74_;
				_data_->_tmp76_ = FALSE;
				_data_->_tmp76_ = prompt_box_get_has_errors (_data_->_tmp75_);
				_data_->_tmp77_ = FALSE;
				_data_->_tmp77_ = _data_->_tmp76_;
				if (_data_->_tmp77_) {
					_data_->_tmp78_ = NULL;
					_data_->_tmp78_ = _data_->self->priv->currently_browsing_server_email;
					_data_->_tmp79_ = NULL;
					_data_->_tmp79_ = _data_->email;
					_data_->_tmp73_ = g_strcmp0 (_data_->_tmp78_, _data_->_tmp79_) == 0;
				} else {
					_data_->_tmp73_ = FALSE;
				}
				_data_->_tmp80_ = FALSE;
				_data_->_tmp80_ = _data_->_tmp73_;
				if (_data_->_tmp80_) {
					_data_->_tmp81_ = NULL;
					_data_->_tmp81_ = _data_->self->priv->currently_browsing_server_url;
					_data_->_tmp82_ = NULL;
					_data_->_tmp82_ = _data_->url;
					_data_->_tmp72_ = g_strcmp0 (_data_->_tmp81_, _data_->_tmp82_) == 0;
				} else {
					_data_->_tmp72_ = FALSE;
				}
				_data_->_tmp83_ = FALSE;
				_data_->_tmp83_ = _data_->_tmp72_;
				if (_data_->_tmp83_) {
					_data_->allowcache = FALSE;
				}
				_data_->_tmp84_ = NULL;
				_data_->_tmp84_ = _data_->self->priv->remote_login_service;
				_data_->_tmp85_ = NULL;
				_data_->_tmp85_ = _data_->url;
				_data_->_tmp86_ = NULL;
				_data_->_tmp86_ = _data_->email;
				_data_->_tmp87_ = NULL;
				_data_->_tmp87_ = _data_->password_field;
				_data_->_tmp88_ = NULL;
				_data_->_tmp88_ = gtk_entry_get_text ((GtkEntry*) _data_->_tmp87_);
				_data_->_tmp89_ = NULL;
				_data_->_tmp89_ = _data_->_tmp88_;
				_data_->_tmp90_ = FALSE;
				_data_->_tmp90_ = _data_->allowcache;
				_data_->_tmp91_ = FALSE;
				_data_->_tmp92_ = NULL;
				_data_->_tmp93_ = NULL;
				_data_->_tmp94_ = 0;
				_data_->_state_ = 1;
				remote_login_service_get_servers_for_login (_data_->_tmp84_, _data_->_tmp85_, _data_->_tmp86_, _data_->_tmp89_, _data_->_tmp90_, user_list_remote_directory_respond_cb_ready, _data_);
				return FALSE;
				_state_1:
				remote_login_service_get_servers_for_login_finish (_data_->_tmp84_, _data_->_res_, &_data_->_tmp91_, &_data_->_tmp92_, &_data_->_tmp93_, &_data_->_tmp94_, &_data_->_inner_error_);
				_data_->login_success = _data_->_tmp91_;
				_g_free0 (_data_->data_type);
				_data_->data_type = _data_->_tmp92_;
				_data_->server_list = (_vala_RemoteServer_array_free (_data_->server_list, _data_->server_list_length1), NULL);
				_data_->server_list = _data_->_tmp93_;
				_data_->server_list_length1 = _data_->_tmp94_;
				_data_->_server_list_size_ = _data_->server_list_length1;
				if (_data_->_inner_error_ != NULL) {
					_g_free0 (_data_->data_type);
					_g_free0 (_data_->url);
					if (_data_->_inner_error_->domain == G_IO_ERROR) {
						goto __catch41_g_io_error;
					}
					_g_free0 (_data_->data_type);
					_g_free0 (_data_->url);
					_g_free0 (_data_->email);
					_data_->server_list = (_vala_RemoteServer_array_free (_data_->server_list, _data_->server_list_length1), NULL);
					_g_object_unref0 (_data_->email_field);
					_g_object_unref0 (_data_->password_field);
					g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _data_->_inner_error_->message, g_quark_to_string (_data_->_inner_error_->domain), _data_->_inner_error_->code);
					g_clear_error (&_data_->_inner_error_);
					return FALSE;
				}
				_g_free0 (_data_->data_type);
			}
			_data_->_tmp95_ = NULL;
			_data_->_tmp95_ = _data_->url;
			_data_->_tmp96_ = NULL;
			_data_->_tmp96_ = g_strdup (_data_->_tmp95_);
			_g_free0 (_data_->self->priv->currently_browsing_server_url);
			_data_->self->priv->currently_browsing_server_url = _data_->_tmp96_;
			_data_->_tmp97_ = NULL;
			_data_->_tmp97_ = _data_->email;
			_data_->_tmp98_ = NULL;
			_data_->_tmp98_ = g_strdup (_data_->_tmp97_);
			_g_free0 (_data_->self->priv->currently_browsing_server_email);
			_data_->self->priv->currently_browsing_server_email = _data_->_tmp98_;
			_g_free0 (_data_->url);
		}
		goto __finally41;
		__catch41_g_io_error:
		{
			_data_->_vala1_e = _data_->_inner_error_;
			_data_->_inner_error_ = NULL;
			_data_->_tmp99_ = NULL;
			_data_->_tmp99_ = _data_->_vala1_e;
			_data_->_tmp100_ = NULL;
			_data_->_tmp100_ = _data_->_tmp99_->message;
			g_debug ("user-list.vala:496: Calling get_servers in com.canonical.RemoteLogin d" \
"bus service failed. Error: %s", _data_->_tmp100_);
			_g_error_free0 (_data_->_vala1_e);
		}
		__finally41:
		if (_data_->_inner_error_ != NULL) {
			_g_free0 (_data_->email);
			_data_->server_list = (_vala_RemoteServer_array_free (_data_->server_list, _data_->server_list_length1), NULL);
			_g_object_unref0 (_data_->email_field);
			_g_object_unref0 (_data_->password_field);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _data_->_inner_error_->message, g_quark_to_string (_data_->_inner_error_->domain), _data_->_inner_error_->code);
			g_clear_error (&_data_->_inner_error_);
			return FALSE;
		}
		_data_->_tmp101_ = FALSE;
		_data_->_tmp101_ = _data_->login_success;
		if (_data_->_tmp101_) {
			_data_->_tmp102_ = NULL;
			_data_->_tmp102_ = _data_->password_field;
			dash_entry_set_did_respond (_data_->_tmp102_, FALSE);
			_data_->_tmp103_ = NULL;
			_data_->_tmp103__length1 = 0;
			_data_->_tmp103_ = _data_->server_list;
			_data_->_tmp103__length1 = _data_->server_list_length1;
			if (_data_->_tmp103__length1 == 0) {
				user_list_show_remote_account_dialog (_data_->self);
			} else {
				_data_->_tmp104_ = NULL;
				_data_->_tmp104_ = g_strdup ("");
				_data_->last_used_server_list_name = _data_->_tmp104_;
				_data_->_tmp105_ = NULL;
				_data_->_tmp105__length1 = 0;
				_data_->_tmp105_ = _data_->server_list;
				_data_->_tmp105__length1 = _data_->server_list_length1;
				{
					_data_->remote_server_collection_length1 = 0;
					_data_->_remote_server_collection_size_ = 0;
					_data_->remote_server_collection = _data_->_tmp105_;
					_data_->remote_server_collection_length1 = _data_->_tmp105__length1;
					for (_data_->remote_server_it = 0; _data_->remote_server_it < _data_->_tmp105__length1; _data_->remote_server_it = _data_->remote_server_it + 1) {
						memset (&_data_->_tmp106_, 0, sizeof (RemoteServer));
						remote_server_copy (&_data_->remote_server_collection[_data_->remote_server_it], &_data_->_tmp106_);
						_data_->remote_server = _data_->_tmp106_;
						{
							memset (&_data_->_tmp107_, 0, sizeof (RemoteServer));
							_data_->_tmp107_ = _data_->remote_server;
							_data_->_tmp108_ = NULL;
							_data_->_tmp108_ = user_list_create_prompt_for_login_server (_data_->self, &_data_->_tmp107_);
							_data_->_vala2_e = _data_->_tmp108_;
							memset (&_data_->_tmp109_, 0, sizeof (RemoteServer));
							_data_->_tmp109_ = _data_->remote_server;
							_data_->_tmp110_ = FALSE;
							_data_->_tmp110_ = _data_->_tmp109_.last_used_server;
							if (_data_->_tmp110_) {
								_data_->_tmp111_ = NULL;
								_data_->_tmp111_ = _data_->_vala2_e;
								_data_->_tmp112_ = NULL;
								_data_->_tmp112_ = prompt_box_get_id (_data_->_tmp111_);
								_data_->_tmp113_ = NULL;
								_data_->_tmp113_ = _data_->_tmp112_;
								_data_->_tmp114_ = NULL;
								_data_->_tmp114_ = g_strdup (_data_->_tmp113_);
								_g_free0 (_data_->last_used_server_list_name);
								_data_->last_used_server_list_name = _data_->_tmp114_;
							}
							_g_object_unref0 (_data_->_vala2_e);
							remote_server_destroy (&_data_->remote_server);
						}
					}
				}
				_data_->_tmp115_ = NULL;
				_data_->_tmp115_ = _data_->last_used_server_list_name;
				if (g_strcmp0 (_data_->_tmp115_, "") != 0) {
					_data_->_tmp116_ = NULL;
					_data_->_tmp116_ = _data_->last_used_server_list_name;
					greeter_list_set_active_entry ((GreeterList*) _data_->self, _data_->_tmp116_);
				} else {
					greeter_list_set_active_first_entry_with_prefix ((GreeterList*) _data_->self, "*remote_login");
				}
				_g_free0 (_data_->last_used_server_list_name);
			}
		} else {
			((GreeterList*) _data_->self)->will_clear = TRUE;
			_data_->_tmp117_ = NULL;
			_data_->_tmp117_ = _ ("Incorrect e-mail address or password");
			greeter_list_show_message ((GreeterList*) _data_->self, _data_->_tmp117_, TRUE);
			_data_->_tmp118_ = NULL;
			_data_->_tmp118_ = _data_->self->priv->remote_directory_server_list;
			user_list_create_remote_fields_for_current_item (_data_->self, _data_->_tmp118_, NULL, NULL);
		}
	}
	_g_free0 (_data_->email);
	_data_->server_list = (_vala_RemoteServer_array_free (_data_->server_list, _data_->server_list_length1), NULL);
	_g_object_unref0 (_data_->email_field);
	_g_object_unref0 (_data_->password_field);
	if (_data_->_state_ == 0) {
		g_simple_async_result_complete_in_idle (_data_->_async_result);
	} else {
		g_simple_async_result_complete (_data_->_async_result);
	}
	g_object_unref (_data_->_async_result);
	return FALSE;
}


static gboolean ____lambda41_ (UserList* self) {
	gboolean result = FALSE;
	greeter_list_authentication_complete_cb ((GreeterList*) self);
	result = FALSE;
	return result;
}


static gboolean _____lambda41__gsource_func (gpointer self) {
	gboolean result;
	result = ____lambda41_ (self);
	return result;
}


static void user_list_remote_login_respond_cb (UserList* self) {
	PromptBox* _tmp0_ = NULL;
	PromptBox* _tmp1_ = NULL;
	const gchar* _tmp2_ = NULL;
	const gchar* _tmp3_ = NULL;
	gchar* _tmp4_ = NULL;
	UnityGreeter* _tmp5_ = NULL;
	gboolean _tmp6_ = FALSE;
	g_return_if_fail (self != NULL);
	gtk_widget_set_sensitive ((GtkWidget*) self, FALSE);
	((GreeterList*) self)->will_clear = TRUE;
	_tmp0_ = greeter_list_get_selected_entry ((GreeterList*) self);
	_tmp1_ = _tmp0_;
	_tmp2_ = prompt_box_get_id (_tmp1_);
	_tmp3_ = _tmp2_;
	_tmp4_ = g_strdup (_tmp3_);
	_g_free0 (((GreeterList*) self)->greeter_authenticating_user);
	((GreeterList*) self)->greeter_authenticating_user = _tmp4_;
	_tmp5_ = unity_greeter_singleton;
	_tmp6_ = _tmp5_->test_mode;
	if (_tmp6_) {
		GtkEntry* field = NULL;
		GHashTable* _tmp7_ = NULL;
		gconstpointer _tmp8_ = NULL;
		GtkWidget* _tmp9_ = NULL;
		GtkEntry* _tmp10_ = NULL;
		GtkEntry* _tmp11_ = NULL;
		const gchar* _tmp12_ = NULL;
		const gchar* _tmp13_ = NULL;
		GtkEntry* _tmp14_ = NULL;
		const gchar* _tmp15_ = NULL;
		const gchar* _tmp16_ = NULL;
		_tmp7_ = self->priv->current_remote_fields;
		_tmp8_ = g_hash_table_lookup (_tmp7_, "password");
		_tmp9_ = (GtkWidget*) _tmp8_;
		_tmp10_ = _g_object_ref0 (G_TYPE_CHECK_INSTANCE_TYPE (_tmp9_, GTK_TYPE_ENTRY) ? ((GtkEntry*) _tmp9_) : NULL);
		field = _tmp10_;
		_tmp11_ = field;
		_tmp12_ = gtk_entry_get_text (_tmp11_);
		_tmp13_ = _tmp12_;
		((GreeterList*) self)->test_is_authenticated = g_strcmp0 (_tmp13_, "password") == 0;
		_tmp14_ = field;
		_tmp15_ = gtk_entry_get_text (_tmp14_);
		_tmp16_ = _tmp15_;
		if (g_strcmp0 (_tmp16_, "delay") == 0) {
			g_timeout_add_full (G_PRIORITY_DEFAULT, (guint) 5000, _____lambda41__gsource_func, g_object_ref (self), g_object_unref);
		} else {
			greeter_list_authentication_complete_cb ((GreeterList*) self);
		}
		_g_object_unref0 (field);
	} else {
		UnityGreeter* _tmp17_ = NULL;
		gchar* _tmp18_ = NULL;
		gchar* _tmp19_ = NULL;
		RemoteLoginService* _tmp20_ = NULL;
		const gchar* _tmp21_ = NULL;
		PromptBox* _tmp22_ = NULL;
		PromptBox* _tmp23_ = NULL;
		const gchar* _tmp24_ = NULL;
		const gchar* _tmp25_ = NULL;
		gchar* _tmp26_ = NULL;
		gchar* _tmp27_ = NULL;
		_tmp17_ = unity_greeter_singleton;
		_tmp18_ = greeter_list_get_lightdm_session ((GreeterList*) self);
		_tmp19_ = _tmp18_;
		unity_greeter_authenticate_remote (_tmp17_, _tmp19_, NULL);
		_g_free0 (_tmp19_);
		_tmp20_ = self->priv->remote_login_service;
		_tmp21_ = self->priv->currently_browsing_server_url;
		_tmp22_ = greeter_list_get_selected_entry ((GreeterList*) self);
		_tmp23_ = _tmp22_;
		_tmp24_ = prompt_box_get_id (_tmp23_);
		_tmp25_ = _tmp24_;
		_tmp26_ = user_list_url_from_remote_loding_server_list_name (self, _tmp25_);
		_tmp27_ = _tmp26_;
		remote_login_service_set_last_used_server (_tmp20_, _tmp21_, _tmp27_, NULL, NULL);
		_g_free0 (_tmp27_);
	}
}


static Block7Data* block7_data_ref (Block7Data* _data7_) {
	g_atomic_int_inc (&_data7_->_ref_count_);
	return _data7_;
}


static void block7_data_unref (void * _userdata_) {
	Block7Data* _data7_;
	_data7_ = (Block7Data*) _userdata_;
	if (g_atomic_int_dec_and_test (&_data7_->_ref_count_)) {
		UserList * self;
		self = _data7_->self;
		_g_object_unref0 (_data7_->dialog);
		_g_object_unref0 (self);
		g_slice_free (Block7Data, _data7_);
	}
}


static void __lambda43_ (Block7Data* _data7_, gint id) {
	UserList * self;
	gint _tmp0_ = 0;
	GtkMessageDialog* _tmp11_ = NULL;
	self = _data7_->self;
	_tmp0_ = id;
	if (_tmp0_ == 1) {
		gchar* config_session = NULL;
		gchar* _tmp1_ = NULL;
		const gchar* _tmp2_ = NULL;
		gboolean _tmp3_ = FALSE;
		_tmp1_ = g_strdup ("uccsconfigure");
		config_session = _tmp1_;
		_tmp2_ = config_session;
		_tmp3_ = user_list_is_supported_remote_session (self, _tmp2_);
		if (_tmp3_) {
			PromptBox* _tmp4_ = NULL;
			PromptBox* _tmp5_ = NULL;
			const gchar* _tmp6_ = NULL;
			const gchar* _tmp7_ = NULL;
			gchar* _tmp8_ = NULL;
			UnityGreeter* _tmp9_ = NULL;
			const gchar* _tmp10_ = NULL;
			_tmp4_ = greeter_list_get_selected_entry ((GreeterList*) self);
			_tmp5_ = _tmp4_;
			_tmp6_ = prompt_box_get_id (_tmp5_);
			_tmp7_ = _tmp6_;
			_tmp8_ = g_strdup (_tmp7_);
			_g_free0 (((GreeterList*) self)->greeter_authenticating_user);
			((GreeterList*) self)->greeter_authenticating_user = _tmp8_;
			_tmp9_ = unity_greeter_singleton;
			_tmp10_ = config_session;
			unity_greeter_authenticate_remote (_tmp9_, _tmp10_, NULL);
		}
		_g_free0 (config_session);
	}
	_tmp11_ = _data7_->dialog;
	gtk_widget_destroy ((GtkWidget*) _tmp11_);
}


static void ___lambda43__gtk_dialog_response (GtkDialog* _sender, gint response_id, gpointer self) {
	__lambda43_ (self, response_id);
}


static void user_list_show_remote_account_dialog (UserList* self) {
	Block7Data* _data7_;
	GtkMessageDialog* _tmp0_ = NULL;
	GtkMessageDialog* _tmp1_ = NULL;
	GtkMessageDialog* _tmp2_ = NULL;
	const gchar* _tmp3_ = NULL;
	GtkMessageDialog* _tmp4_ = NULL;
	const gchar* _tmp5_ = NULL;
	gboolean _tmp6_ = FALSE;
	gboolean _tmp7_ = FALSE;
	GtkMessageDialog* _tmp21_ = NULL;
	GtkMessageDialog* _tmp22_ = NULL;
	GtkMessageDialog* _tmp23_ = NULL;
	g_return_if_fail (self != NULL);
	_data7_ = g_slice_new0 (Block7Data);
	_data7_->_ref_count_ = 1;
	_data7_->self = g_object_ref (self);
	_tmp0_ = (GtkMessageDialog*) gtk_message_dialog_new (NULL, 0, GTK_MESSAGE_OTHER, GTK_BUTTONS_NONE, "");
	g_object_ref_sink (_tmp0_);
	_data7_->dialog = _tmp0_;
	_tmp1_ = _data7_->dialog;
	gtk_window_set_position ((GtkWindow*) _tmp1_, GTK_WIN_POS_CENTER_ALWAYS);
	_tmp2_ = _data7_->dialog;
	_tmp3_ = _ ("If you have an account on an RDP or Citrix server, Remote Login lets y" \
"ou run applications from that server.");
	g_object_set (_tmp2_, "secondary-text", _tmp3_, NULL);
	_tmp4_ = _data7_->dialog;
	_tmp5_ = _ ("If you have an account on an RDP server, Remote Login lets you run app" \
"lications from that server.");
	g_object_set (_tmp4_, "secondary-text", _tmp5_, NULL);
	_tmp6_ = user_list_get_offer_guest (self);
	_tmp7_ = _tmp6_;
	if (_tmp7_) {
		GtkMessageDialog* _tmp8_ = NULL;
		const gchar* _tmp9_ = NULL;
		GtkWidget* b = NULL;
		GtkMessageDialog* _tmp10_ = NULL;
		const gchar* _tmp11_ = NULL;
		GtkWidget* _tmp12_ = NULL;
		GtkWidget* _tmp13_ = NULL;
		GtkWidget* _tmp14_ = NULL;
		GtkMessageDialog* _tmp15_ = NULL;
		const gchar* _tmp16_ = NULL;
		_tmp8_ = _data7_->dialog;
		_tmp9_ = _ ("Cancel");
		gtk_dialog_add_button ((GtkDialog*) _tmp8_, _tmp9_, 0);
		_tmp10_ = _data7_->dialog;
		_tmp11_ = _ ("Set Up");
		_tmp12_ = gtk_dialog_add_button ((GtkDialog*) _tmp10_, _tmp11_, 1);
		_tmp13_ = _g_object_ref0 (_tmp12_);
		b = _tmp13_;
		_tmp14_ = b;
		gtk_widget_grab_focus (_tmp14_);
		_tmp15_ = _data7_->dialog;
		_tmp16_ = _ ("You need an Ubuntu Remote Login account to use this service. Would you" \
" like to set up an account now?");
		g_object_set (_tmp15_, "text", _tmp16_, NULL);
		_g_object_unref0 (b);
	} else {
		GtkMessageDialog* _tmp17_ = NULL;
		const gchar* _tmp18_ = NULL;
		GtkMessageDialog* _tmp19_ = NULL;
		const gchar* _tmp20_ = NULL;
		_tmp17_ = _data7_->dialog;
		_tmp18_ = _ ("OK");
		gtk_dialog_add_button ((GtkDialog*) _tmp17_, _tmp18_, 0);
		_tmp19_ = _data7_->dialog;
		_tmp20_ = _ ("You need an Ubuntu Remote Login account to use this service. Visit ucc" \
"s.canonical.com to set up an account.");
		g_object_set (_tmp19_, "text", _tmp20_, NULL);
	}
	_tmp21_ = _data7_->dialog;
	gtk_widget_show_all ((GtkWidget*) _tmp21_);
	_tmp22_ = _data7_->dialog;
	g_signal_connect_data ((GtkDialog*) _tmp22_, "response", (GCallback) ___lambda43__gtk_dialog_response, block7_data_ref (_data7_), (GClosureNotify) block7_data_unref, 0);
	_tmp23_ = _data7_->dialog;
	gtk_dialog_run ((GtkDialog*) _tmp23_);
	block7_data_unref (_data7_);
	_data7_ = NULL;
}


static gboolean user_list_change_background_timeout_cb (UserList* self) {
	gboolean result = FALSE;
	gchar* new_background_file = NULL;
	gboolean _tmp0_ = FALSE;
	Background* _tmp7_ = NULL;
	Background* _tmp8_ = NULL;
	const gchar* _tmp9_ = NULL;
	g_return_val_if_fail (self != NULL, FALSE);
	new_background_file = NULL;
	_tmp0_ = ug_settings_get_boolean (UG_SETTINGS_KEY_DRAW_USER_BACKGROUNDS);
	if (!_tmp0_) {
		_g_free0 (new_background_file);
		new_background_file = NULL;
	} else {
		PromptBox* _tmp1_ = NULL;
		PromptBox* _tmp2_ = NULL;
		_tmp1_ = greeter_list_get_selected_entry ((GreeterList*) self);
		_tmp2_ = _tmp1_;
		if (G_TYPE_CHECK_INSTANCE_TYPE (_tmp2_, TYPE_USER_PROMPT_BOX)) {
			PromptBox* _tmp3_ = NULL;
			PromptBox* _tmp4_ = NULL;
			const gchar* _tmp5_ = NULL;
			gchar* _tmp6_ = NULL;
			_tmp3_ = greeter_list_get_selected_entry ((GreeterList*) self);
			_tmp4_ = _tmp3_;
			_tmp5_ = (G_TYPE_CHECK_INSTANCE_TYPE (_tmp4_, TYPE_USER_PROMPT_BOX) ? ((UserPromptBox*) _tmp4_) : NULL)->background;
			_tmp6_ = g_strdup (_tmp5_);
			_g_free0 (new_background_file);
			new_background_file = _tmp6_;
		}
	}
	_tmp7_ = greeter_list_get_background ((GreeterList*) self);
	_tmp8_ = _tmp7_;
	_tmp9_ = new_background_file;
	background_set_current_background (_tmp8_, _tmp9_);
	self->priv->change_background_timeout = (guint) 0;
	result = FALSE;
	_g_free0 (new_background_file);
	return result;
}


static gboolean _user_list_change_background_timeout_cb_gsource_func (gpointer self) {
	gboolean result;
	result = user_list_change_background_timeout_cb (self);
	return result;
}


static void user_list_change_background (UserList* self) {
	Background* _tmp0_ = NULL;
	Background* _tmp1_ = NULL;
	const gchar* _tmp2_ = NULL;
	const gchar* _tmp3_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = greeter_list_get_background ((GreeterList*) self);
	_tmp1_ = _tmp0_;
	_tmp2_ = background_get_current_background (_tmp1_);
	_tmp3_ = _tmp2_;
	if (_tmp3_ != NULL) {
		guint _tmp4_ = 0U;
		_tmp4_ = self->priv->change_background_timeout;
		if (_tmp4_ == ((guint) 0)) {
			guint _tmp5_ = 0U;
			_tmp5_ = g_idle_add_full (G_PRIORITY_DEFAULT_IDLE, _user_list_change_background_timeout_cb_gsource_func, g_object_ref (self), g_object_unref);
			self->priv->change_background_timeout = _tmp5_;
		}
	} else {
		user_list_change_background_timeout_cb (self);
	}
}


gint user_list_user_list_compare_entry (PromptBox* a, PromptBox* b) {
	gint result = 0;
	gboolean _tmp0_ = FALSE;
	PromptBox* _tmp1_ = NULL;
	const gchar* _tmp2_ = NULL;
	const gchar* _tmp3_ = NULL;
	gboolean _tmp4_ = FALSE;
	gboolean _tmp9_ = FALSE;
	gboolean _tmp10_ = FALSE;
	PromptBox* _tmp11_ = NULL;
	const gchar* _tmp12_ = NULL;
	const gchar* _tmp13_ = NULL;
	gboolean _tmp14_ = FALSE;
	gboolean _tmp19_ = FALSE;
	PromptBox* _tmp20_ = NULL;
	PromptBox* _tmp21_ = NULL;
	gint _tmp22_ = 0;
	g_return_val_if_fail (a != NULL, 0);
	g_return_val_if_fail (b != NULL, 0);
	_tmp1_ = a;
	_tmp2_ = prompt_box_get_id (_tmp1_);
	_tmp3_ = _tmp2_;
	_tmp4_ = g_str_has_prefix (_tmp3_, "*remote_directory");
	if (_tmp4_) {
		PromptBox* _tmp5_ = NULL;
		const gchar* _tmp6_ = NULL;
		const gchar* _tmp7_ = NULL;
		gboolean _tmp8_ = FALSE;
		_tmp5_ = b;
		_tmp6_ = prompt_box_get_id (_tmp5_);
		_tmp7_ = _tmp6_;
		_tmp8_ = g_str_has_prefix (_tmp7_, "*remote_directory");
		_tmp0_ = !_tmp8_;
	} else {
		_tmp0_ = FALSE;
	}
	_tmp9_ = _tmp0_;
	if (_tmp9_) {
		result = 1;
		return result;
	}
	_tmp11_ = a;
	_tmp12_ = prompt_box_get_id (_tmp11_);
	_tmp13_ = _tmp12_;
	_tmp14_ = g_str_has_prefix (_tmp13_, "*remote_login");
	if (_tmp14_) {
		PromptBox* _tmp15_ = NULL;
		const gchar* _tmp16_ = NULL;
		const gchar* _tmp17_ = NULL;
		gboolean _tmp18_ = FALSE;
		_tmp15_ = b;
		_tmp16_ = prompt_box_get_id (_tmp15_);
		_tmp17_ = _tmp16_;
		_tmp18_ = g_str_has_prefix (_tmp17_, "*remote_login");
		_tmp10_ = !_tmp18_;
	} else {
		_tmp10_ = FALSE;
	}
	_tmp19_ = _tmp10_;
	if (_tmp19_) {
		result = 1;
		return result;
	}
	_tmp20_ = a;
	_tmp21_ = b;
	_tmp22_ = greeter_list_compare_entry (_tmp20_, _tmp21_);
	result = _tmp22_;
	return result;
}


static gint _user_list_user_list_compare_entry_gcompare_func (gconstpointer a, gconstpointer b) {
	gint result;
	result = user_list_user_list_compare_entry (a, b);
	return result;
}


static void user_list_real_insert_entry (GreeterList* base, PromptBox* entry) {
	UserList * self;
	PromptBox* _tmp0_ = NULL;
	PromptBox* _tmp1_ = NULL;
	self = (UserList*) base;
	g_return_if_fail (entry != NULL);
	_tmp0_ = entry;
	_tmp1_ = _g_object_ref0 (_tmp0_);
	((GreeterList*) self)->entries = g_list_insert_sorted (((GreeterList*) self)->entries, _tmp1_, _user_list_user_list_compare_entry_gcompare_func);
}


static void user_list_real_setup_prompt_box (GreeterList* base, gboolean fade) {
	UserList * self;
	gboolean _tmp0_ = FALSE;
	UserPromptBox* userbox = NULL;
	PromptBox* _tmp1_ = NULL;
	PromptBox* _tmp2_ = NULL;
	UserPromptBox* _tmp3_ = NULL;
	UserPromptBox* _tmp4_ = NULL;
	self = (UserList*) base;
	_tmp0_ = fade;
	GREETER_LIST_CLASS (user_list_parent_class)->setup_prompt_box (G_TYPE_CHECK_INSTANCE_CAST (self, TYPE_GREETER_LIST, GreeterList), _tmp0_);
	_tmp1_ = greeter_list_get_selected_entry ((GreeterList*) self);
	_tmp2_ = _tmp1_;
	_tmp3_ = _g_object_ref0 (G_TYPE_CHECK_INSTANCE_TYPE (_tmp2_, TYPE_USER_PROMPT_BOX) ? ((UserPromptBox*) _tmp2_) : NULL);
	userbox = _tmp3_;
	_tmp4_ = userbox;
	if (_tmp4_ != NULL) {
		PromptBox* _tmp5_ = NULL;
		PromptBox* _tmp6_ = NULL;
		UserPromptBox* _tmp7_ = NULL;
		gboolean _tmp8_ = FALSE;
		_tmp5_ = greeter_list_get_selected_entry ((GreeterList*) self);
		_tmp6_ = _tmp5_;
		_tmp7_ = userbox;
		_tmp8_ = _tmp7_->is_active;
		prompt_box_set_is_active (_tmp6_, _tmp8_);
	}
	_g_object_unref0 (userbox);
}


static void user_list_entry_selected_cb (UserList* self, const gchar* username) {
	UnityGreeter* _tmp0_ = NULL;
	const gchar* _tmp1_ = NULL;
	PromptBox* _tmp2_ = NULL;
	PromptBox* _tmp3_ = NULL;
	PromptBox* _tmp7_ = NULL;
	PromptBox* _tmp8_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = unity_greeter_singleton;
	_tmp1_ = username;
	unity_greeter_set_state (_tmp0_, "last-user", _tmp1_);
	_tmp2_ = greeter_list_get_selected_entry ((GreeterList*) self);
	_tmp3_ = _tmp2_;
	if (G_TYPE_CHECK_INSTANCE_TYPE (_tmp3_, TYPE_USER_PROMPT_BOX)) {
		PromptBox* _tmp4_ = NULL;
		PromptBox* _tmp5_ = NULL;
		const gchar* _tmp6_ = NULL;
		_tmp4_ = greeter_list_get_selected_entry ((GreeterList*) self);
		_tmp5_ = _tmp4_;
		_tmp6_ = (G_TYPE_CHECK_INSTANCE_TYPE (_tmp5_, TYPE_USER_PROMPT_BOX) ? ((UserPromptBox*) _tmp5_) : NULL)->session;
		user_list_set_session (self, _tmp6_);
	} else {
		user_list_set_session (self, NULL);
	}
	_tmp7_ = greeter_list_get_selected_entry ((GreeterList*) self);
	_tmp8_ = _tmp7_;
	prompt_box_clear (_tmp8_);
	_email_autocompleter_unref0 (self->priv->remote_server_email_field_autocompleter);
	self->priv->remote_server_email_field_autocompleter = NULL;
	greeter_list_start_authentication ((GreeterList*) self);
}


static void user_list_real_start_authentication (GreeterList* base) {
	UserList * self;
	gchar* _tmp0_ = NULL;
	PromptBox* _tmp1_ = NULL;
	PromptBox* _tmp2_ = NULL;
	const gchar* _tmp3_ = NULL;
	const gchar* _tmp4_ = NULL;
	gboolean _tmp5_ = FALSE;
	self = (UserList*) base;
	gtk_widget_set_sensitive ((GtkWidget*) self, TRUE);
	_tmp0_ = g_strdup ("");
	_g_free0 (((GreeterList*) self)->greeter_authenticating_user);
	((GreeterList*) self)->greeter_authenticating_user = _tmp0_;
	_tmp1_ = greeter_list_get_selected_entry ((GreeterList*) self);
	_tmp2_ = _tmp1_;
	_tmp3_ = prompt_box_get_id (_tmp2_);
	_tmp4_ = _tmp3_;
	_tmp5_ = g_str_has_prefix (_tmp4_, "*remote_directory");
	if (_tmp5_) {
		GList* _tmp6_ = NULL;
		((GreeterList*) self)->prompted = TRUE;
		_tmp6_ = self->priv->remote_directory_server_list;
		user_list_create_remote_fields_for_current_item (self, _tmp6_, NULL, NULL);
	} else {
		PromptBox* _tmp7_ = NULL;
		PromptBox* _tmp8_ = NULL;
		const gchar* _tmp9_ = NULL;
		const gchar* _tmp10_ = NULL;
		gboolean _tmp11_ = FALSE;
		_tmp7_ = greeter_list_get_selected_entry ((GreeterList*) self);
		_tmp8_ = _tmp7_;
		_tmp9_ = prompt_box_get_id (_tmp8_);
		_tmp10_ = _tmp9_;
		_tmp11_ = g_str_has_prefix (_tmp10_, "*remote_login");
		if (_tmp11_) {
			GList* _tmp12_ = NULL;
			((GreeterList*) self)->prompted = TRUE;
			_tmp12_ = self->priv->remote_login_server_list;
			user_list_create_remote_fields_for_current_item (self, _tmp12_, NULL, NULL);
		} else {
			GREETER_LIST_CLASS (user_list_parent_class)->start_authentication (G_TYPE_CHECK_INSTANCE_CAST (self, TYPE_GREETER_LIST, GreeterList));
		}
	}
}


static void user_list_create_remote_fields_for_current_item_data_free (gpointer _data) {
	UserListCreateRemoteFieldsForCurrentItemData* _data_;
	_data_ = _data;
	_g_object_unref0 (_data_->self);
	g_slice_free (UserListCreateRemoteFieldsForCurrentItemData, _data_);
}


static void user_list_create_remote_fields_for_current_item (UserList* self, GList* server_list, GAsyncReadyCallback _callback_, gpointer _user_data_) {
	UserListCreateRemoteFieldsForCurrentItemData* _data_;
	UserList* _tmp0_ = NULL;
	GList* _tmp1_ = NULL;
	_data_ = g_slice_new0 (UserListCreateRemoteFieldsForCurrentItemData);
	_data_->_async_result = g_simple_async_result_new (G_OBJECT (self), _callback_, _user_data_, user_list_create_remote_fields_for_current_item);
	g_simple_async_result_set_op_res_gpointer (_data_->_async_result, _data_, user_list_create_remote_fields_for_current_item_data_free);
	_tmp0_ = _g_object_ref0 (self);
	_data_->self = _tmp0_;
	_tmp1_ = server_list;
	_data_->server_list = _tmp1_;
	user_list_create_remote_fields_for_current_item_co (_data_);
}


static void user_list_create_remote_fields_for_current_item_finish (UserList* self, GAsyncResult* _res_) {
	UserListCreateRemoteFieldsForCurrentItemData* _data_;
	_data_ = g_simple_async_result_get_op_res_gpointer (G_SIMPLE_ASYNC_RESULT (_res_));
}


static void _g_object_unref0_ (gpointer var) {
	(var == NULL) ? NULL : (var = (g_object_unref (var), NULL));
}


static gpointer _remote_server_field_dup0 (gpointer self) {
	return self ? remote_server_field_dup (self) : NULL;
}


static gint _remote_server_field_sort_function_gcompare_func (gconstpointer a, gconstpointer b) {
	gint result;
	result = remote_server_field_sort_function (a, b);
	return result;
}


static gint g_ptr_array_get_length (GPtrArray* self) {
	gint result;
	guint _tmp0_ = 0U;
	g_return_val_if_fail (self != NULL, 0);
	_tmp0_ = self->len;
	result = (gint) _tmp0_;
	return result;
}


static void g_ptr_array_set_length (GPtrArray* self, gint value) {
	gint _tmp0_ = 0;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	g_ptr_array_set_size (self, _tmp0_);
}


static Block8Data* block8_data_ref (Block8Data* _data8_) {
	g_atomic_int_inc (&_data8_->_ref_count_);
	return _data8_;
}


static void block8_data_unref (void * _userdata_) {
	Block8Data* _data8_;
	_data8_ = (Block8Data*) _userdata_;
	if (g_atomic_int_dec_and_test (&_data8_->_ref_count_)) {
		GPtrArray * self;
		self = _data8_->self;
		_g_ptr_array_unref0 (self);
		g_slice_free (Block8Data, _data8_);
	}
}


static gint __lambda0_ (Block8Data* _data8_, gconstpointer** a, gconstpointer** b) {
	GPtrArray * self;
	gint result = 0;
	GCompareFunc _tmp0_ = NULL;
	gconstpointer** _tmp1_ = NULL;
	gconstpointer** _tmp2_ = NULL;
	gint _tmp3_ = 0;
	self = _data8_->self;
	_tmp0_ = _data8_->compare_func;
	_tmp1_ = a;
	_tmp2_ = b;
	_tmp3_ = _tmp0_ ((gconstpointer**) (*_tmp1_), (gconstpointer**) (*_tmp2_));
	result = _tmp3_;
	return result;
}


static gint ___lambda0__gcompare_data_func (gconstpointer a, gconstpointer b, gpointer self) {
	gint result;
	result = __lambda0_ (self, a, b);
	return result;
}


static void vala_g_ptr_array_sort (GPtrArray* self, GCompareFunc compare_func) {
	Block8Data* _data8_;
	GCompareFunc _tmp0_ = NULL;
	g_return_if_fail (self != NULL);
	_data8_ = g_slice_new0 (Block8Data);
	_data8_->_ref_count_ = 1;
	_data8_->self = g_ptr_array_ref (self);
	_tmp0_ = compare_func;
	_data8_->compare_func = _tmp0_;
	g_ptr_array_sort_with_data (self, ___lambda0__gcompare_data_func, _data8_);
	block8_data_unref (_data8_);
	_data8_ = NULL;
}


static void user_list_create_remote_fields_for_current_item_ready (GObject* source_object, GAsyncResult* _res_, gpointer _user_data_) {
	UserListCreateRemoteFieldsForCurrentItemData* _data_;
	_data_ = _user_data_;
	_data_->_source_object_ = source_object;
	_data_->_res_ = _res_;
	user_list_create_remote_fields_for_current_item_co (_data_);
}


static void _remote_server_field_free0_ (gpointer var) {
	(var == NULL) ? NULL : (var = (remote_server_field_free (var), NULL));
}


static void _g_list_free__remote_server_field_free0_ (GList* self) {
	g_list_foreach (self, (GFunc) _remote_server_field_free0_, NULL);
	g_list_free (self);
}


static gboolean user_list_create_remote_fields_for_current_item_co (UserListCreateRemoteFieldsForCurrentItemData* _data_) {
	switch (_data_->_state_) {
		case 0:
		goto _state_0;
		case 1:
		goto _state_1;
		default:
		g_assert_not_reached ();
	}
	_state_0:
	_data_->_tmp0_ = NULL;
	_data_->_tmp0_ = g_str_hash;
	_data_->_tmp1_ = NULL;
	_data_->_tmp1_ = g_str_equal;
	_data_->_tmp2_ = NULL;
	_data_->_tmp2_ = g_hash_table_new_full (_data_->_tmp0_, _data_->_tmp1_, _g_free0_, _g_object_unref0_);
	_g_hash_table_unref0 (_data_->self->priv->current_remote_fields);
	_data_->self->priv->current_remote_fields = _data_->_tmp2_;
	_data_->_tmp3_ = NULL;
	_data_->_tmp3_ = greeter_list_get_selected_entry ((GreeterList*) _data_->self);
	_data_->_tmp4_ = NULL;
	_data_->_tmp4_ = _data_->_tmp3_;
	_data_->_tmp5_ = NULL;
	_data_->_tmp5_ = prompt_box_get_id (_data_->_tmp4_);
	_data_->_tmp6_ = NULL;
	_data_->_tmp6_ = _data_->_tmp5_;
	_data_->_tmp7_ = NULL;
	_data_->_tmp7_ = user_list_url_from_remote_loding_server_list_name (_data_->self, _data_->_tmp6_);
	_data_->url = _data_->_tmp7_;
	_data_->_tmp8_ = NULL;
	_data_->_tmp8_ = greeter_list_get_selected_entry ((GreeterList*) _data_->self);
	_data_->_tmp9_ = NULL;
	_data_->_tmp9_ = _data_->_tmp8_;
	_data_->_tmp10_ = NULL;
	_data_->_tmp10_ = prompt_box_get_id (_data_->_tmp9_);
	_data_->_tmp11_ = NULL;
	_data_->_tmp11_ = _data_->_tmp10_;
	_data_->_tmp12_ = NULL;
	_data_->_tmp12_ = user_list_username_from_remote_loding_server_list_name (_data_->self, _data_->_tmp11_);
	_data_->username = _data_->_tmp12_;
	_data_->_tmp13_ = NULL;
	_data_->_tmp13_ = _data_->server_list;
	{
		_data_->remote_server_collection = _data_->_tmp13_;
		for (_data_->remote_server_it = _data_->remote_server_collection; _data_->remote_server_it != NULL; _data_->remote_server_it = _data_->remote_server_it->next) {
			_data_->_tmp14_ = NULL;
			_data_->_tmp14_ = _remote_server_dup0 ((RemoteServer*) _data_->remote_server_it->data);
			_data_->remote_server = _data_->_tmp14_;
			{
				_data_->_tmp15_ = NULL;
				_data_->_tmp15_ = _data_->remote_server;
				memset (&_data_->_tmp16_, 0, sizeof (RemoteServer));
				_data_->_tmp16_ = *_data_->_tmp15_;
				_data_->_tmp17_ = NULL;
				_data_->_tmp17_ = user_list_username_from_remote_server_fields (_data_->self, &_data_->_tmp16_);
				_data_->remote_username = _data_->_tmp17_;
				_data_->_tmp19_ = NULL;
				_data_->_tmp19_ = _data_->remote_server;
				_data_->_tmp20_ = NULL;
				_data_->_tmp20_ = (*_data_->_tmp19_).url;
				_data_->_tmp21_ = NULL;
				_data_->_tmp21_ = _data_->url;
				if (g_strcmp0 (_data_->_tmp20_, _data_->_tmp21_) == 0) {
					_data_->_tmp23_ = NULL;
					_data_->_tmp23_ = _data_->username;
					if (_data_->_tmp23_ == NULL) {
						_data_->_tmp22_ = TRUE;
					} else {
						_data_->_tmp24_ = NULL;
						_data_->_tmp24_ = _data_->username;
						_data_->_tmp25_ = NULL;
						_data_->_tmp25_ = _data_->remote_username;
						_data_->_tmp22_ = g_strcmp0 (_data_->_tmp24_, _data_->_tmp25_) == 0;
					}
					_data_->_tmp26_ = FALSE;
					_data_->_tmp26_ = _data_->_tmp22_;
					_data_->_tmp18_ = _data_->_tmp26_;
				} else {
					_data_->_tmp18_ = FALSE;
				}
				_data_->_tmp27_ = FALSE;
				_data_->_tmp27_ = _data_->_tmp18_;
				if (_data_->_tmp27_) {
					_data_->_tmp28_ = NULL;
					_data_->_tmp28_ = greeter_list_get_selected_entry ((GreeterList*) _data_->self);
					_data_->_tmp29_ = NULL;
					_data_->_tmp29_ = _data_->_tmp28_;
					_data_->_tmp30_ = NULL;
					_data_->_tmp30_ = prompt_box_get_id (_data_->_tmp29_);
					_data_->_tmp31_ = NULL;
					_data_->_tmp31_ = _data_->_tmp30_;
					_data_->_tmp32_ = FALSE;
					_data_->_tmp32_ = g_str_has_prefix (_data_->_tmp31_, "*remote_login");
					if (_data_->_tmp32_) {
						_data_->_tmp33_ = NULL;
						_data_->_tmp33_ = _data_->remote_server;
						_data_->_tmp34_ = NULL;
						_data_->_tmp34_ = (*_data_->_tmp33_).type;
						_data_->_tmp35_ = FALSE;
						_data_->_tmp35_ = user_list_is_supported_remote_session (_data_->self, _data_->_tmp34_);
						if (!_data_->_tmp35_) {
							_data_->_tmp36_ = NULL;
							_data_->_tmp36_ = _ ("Server type not supported.");
							greeter_list_show_message ((GreeterList*) _data_->self, _data_->_tmp36_, TRUE);
						}
					}
					_data_->fields = NULL;
					_data_->_tmp37_ = NULL;
					_data_->_tmp37_ = _data_->remote_server;
					_data_->_tmp38_ = NULL;
					_data_->_tmp38__length1 = 0;
					_data_->_tmp38_ = (*_data_->_tmp37_).fields;
					_data_->_tmp38__length1 = (*_data_->_tmp37_).fields_length1;
					{
						_data_->field_collection_length1 = 0;
						_data_->_field_collection_size_ = 0;
						_data_->field_collection = _data_->_tmp38_;
						_data_->field_collection_length1 = _data_->_tmp38__length1;
						for (_data_->field_it = 0; _data_->field_it < _data_->_tmp38__length1; _data_->field_it = _data_->field_it + 1) {
							memset (&_data_->_tmp39_, 0, sizeof (RemoteServerField));
							remote_server_field_copy (&_data_->field_collection[_data_->field_it], &_data_->_tmp39_);
							_data_->field = _data_->_tmp39_;
							{
								memset (&_data_->_tmp40_, 0, sizeof (RemoteServerField));
								_data_->_tmp40_ = _data_->field;
								memset (&_data_->_tmp41_, 0, sizeof (RemoteServerField));
								_data_->_tmp41_ = _data_->_tmp40_;
								_data_->_tmp42_ = NULL;
								_data_->_tmp42_ = _remote_server_field_dup0 (&_data_->_tmp41_);
								_data_->fields = g_list_append (_data_->fields, _data_->_tmp42_);
								remote_server_field_destroy (&_data_->field);
							}
						}
					}
					_data_->fields = g_list_sort (_data_->fields, _remote_server_field_sort_function_gcompare_func);
					_data_->_tmp43_ = NULL;
					_data_->_tmp43_ = _data_->fields;
					{
						_data_->_vala1_field_collection = _data_->_tmp43_;
						for (_data_->_vala1_field_it = _data_->_vala1_field_collection; _data_->_vala1_field_it != NULL; _data_->_vala1_field_it = _data_->_vala1_field_it->next) {
							_data_->_tmp44_ = NULL;
							_data_->_tmp44_ = _remote_server_field_dup0 ((RemoteServerField*) _data_->_vala1_field_it->data);
							_data_->_vala1_field = _data_->_tmp44_;
							{
								_data_->widget = NULL;
								_data_->_tmp45_ = NULL;
								_data_->_tmp45_ = g_strdup ("");
								_data_->default_value = _data_->_tmp45_;
								_data_->_tmp47_ = NULL;
								_data_->_tmp47_ = _data_->_vala1_field;
								_data_->_tmp48_ = NULL;
								_data_->_tmp48_ = (*_data_->_tmp47_).default_value;
								if (_data_->_tmp48_ != NULL) {
									_data_->_tmp49_ = NULL;
									_data_->_tmp49_ = _data_->_vala1_field;
									_data_->_tmp50_ = NULL;
									_data_->_tmp50_ = (*_data_->_tmp49_).default_value;
									_data_->_tmp51_ = NULL;
									_data_->_tmp51_ = G_VARIANT_TYPE_STRING;
									_data_->_tmp52_ = FALSE;
									_data_->_tmp52_ = g_variant_is_of_type (_data_->_tmp50_, _data_->_tmp51_);
									_data_->_tmp46_ = _data_->_tmp52_;
								} else {
									_data_->_tmp46_ = FALSE;
								}
								_data_->_tmp53_ = FALSE;
								_data_->_tmp53_ = _data_->_tmp46_;
								if (_data_->_tmp53_) {
									_data_->_tmp54_ = NULL;
									_data_->_tmp54_ = _data_->_vala1_field;
									_data_->_tmp55_ = NULL;
									_data_->_tmp55_ = (*_data_->_tmp54_).default_value;
									_data_->_tmp56_ = NULL;
									_data_->_tmp56_ = g_variant_get_string (_data_->_tmp55_, NULL);
									_data_->_tmp57_ = NULL;
									_data_->_tmp57_ = g_strdup (_data_->_tmp56_);
									_g_free0 (_data_->default_value);
									_data_->default_value = _data_->_tmp57_;
								}
								_data_->_tmp58_ = NULL;
								_data_->_tmp58_ = _data_->_vala1_field;
								_data_->_tmp59_ = NULL;
								_data_->_tmp59_ = (*_data_->_tmp58_).type;
								if (g_strcmp0 (_data_->_tmp59_, "username") == 0) {
									_data_->_tmp60_ = NULL;
									_data_->_tmp60_ = _ ("Username:");
									_data_->_tmp61_ = NULL;
									_data_->_tmp61_ = greeter_list_add_prompt ((GreeterList*) _data_->self, _data_->_tmp60_, FALSE);
									_data_->entry = _data_->_tmp61_;
									_data_->_tmp62_ = NULL;
									_data_->_tmp62_ = _data_->entry;
									_data_->_tmp63_ = NULL;
									_data_->_tmp63_ = _data_->default_value;
									gtk_entry_set_text ((GtkEntry*) _data_->_tmp62_, _data_->_tmp63_);
									_data_->_tmp64_ = NULL;
									_data_->_tmp64_ = _data_->entry;
									_data_->_tmp65_ = NULL;
									_data_->_tmp65_ = _g_object_ref0 ((GtkWidget*) _data_->_tmp64_);
									_g_object_unref0 (_data_->widget);
									_data_->widget = _data_->_tmp65_;
									_g_object_unref0 (_data_->entry);
								} else {
									_data_->_tmp66_ = NULL;
									_data_->_tmp66_ = _data_->_vala1_field;
									_data_->_tmp67_ = NULL;
									_data_->_tmp67_ = (*_data_->_tmp66_).type;
									if (g_strcmp0 (_data_->_tmp67_, "password") == 0) {
										_data_->_tmp68_ = NULL;
										_data_->_tmp68_ = _ ("Password:");
										_data_->_tmp69_ = NULL;
										_data_->_tmp69_ = greeter_list_add_prompt ((GreeterList*) _data_->self, _data_->_tmp68_, TRUE);
										_data_->_vala1_entry = _data_->_tmp69_;
										_data_->_tmp70_ = NULL;
										_data_->_tmp70_ = _data_->_vala1_entry;
										_data_->_tmp71_ = NULL;
										_data_->_tmp71_ = _data_->default_value;
										gtk_entry_set_text ((GtkEntry*) _data_->_tmp70_, _data_->_tmp71_);
										_data_->_tmp72_ = NULL;
										_data_->_tmp72_ = _data_->_vala1_entry;
										_data_->_tmp73_ = NULL;
										_data_->_tmp73_ = _g_object_ref0 ((GtkWidget*) _data_->_tmp72_);
										_g_object_unref0 (_data_->widget);
										_data_->widget = _data_->_tmp73_;
										_g_object_unref0 (_data_->_vala1_entry);
									} else {
										_data_->_tmp74_ = NULL;
										_data_->_tmp74_ = _data_->_vala1_field;
										_data_->_tmp75_ = NULL;
										_data_->_tmp75_ = (*_data_->_tmp74_).type;
										if (g_strcmp0 (_data_->_tmp75_, "domain") == 0) {
											_data_->_tmp76_ = NULL;
											_data_->_tmp76_ = g_new0 (gchar*, 0 + 1);
											_data_->domainsArray_length1 = 0;
											_data_->_domainsArray_size_ = 0;
											_data_->domainsArray = _data_->_tmp76_;
											_data_->domainsArray_length1 = 0;
											_data_->_domainsArray_size_ = _data_->domainsArray_length1;
											_data_->_tmp79_ = NULL;
											_data_->_tmp79_ = _data_->_vala1_field;
											_data_->_tmp80_ = NULL;
											_data_->_tmp80_ = (*_data_->_tmp79_).properties;
											if (_data_->_tmp80_ != NULL) {
												_data_->_tmp81_ = NULL;
												_data_->_tmp81_ = _data_->_vala1_field;
												_data_->_tmp82_ = NULL;
												_data_->_tmp82_ = (*_data_->_tmp81_).properties;
												_data_->_tmp83_ = FALSE;
												_data_->_tmp83_ = g_hash_table_contains (_data_->_tmp82_, "domains");
												_data_->_tmp78_ = _data_->_tmp83_;
											} else {
												_data_->_tmp78_ = FALSE;
											}
											_data_->_tmp84_ = FALSE;
											_data_->_tmp84_ = _data_->_tmp78_;
											if (_data_->_tmp84_) {
												_data_->_tmp85_ = NULL;
												_data_->_tmp85_ = _data_->_vala1_field;
												_data_->_tmp86_ = NULL;
												_data_->_tmp86_ = (*_data_->_tmp85_).properties;
												_data_->_tmp87_ = NULL;
												_data_->_tmp87_ = g_hash_table_lookup (_data_->_tmp86_, "domains");
												_data_->_tmp88_ = NULL;
												_data_->_tmp88_ = G_VARIANT_TYPE_ARRAY;
												_data_->_tmp89_ = FALSE;
												_data_->_tmp89_ = g_variant_is_of_type ((GVariant*) _data_->_tmp87_, _data_->_tmp88_);
												_data_->_tmp77_ = _data_->_tmp89_;
											} else {
												_data_->_tmp77_ = FALSE;
											}
											_data_->_tmp90_ = FALSE;
											_data_->_tmp90_ = _data_->_tmp77_;
											if (_data_->_tmp90_) {
												_data_->_tmp91_ = NULL;
												_data_->_tmp91_ = _data_->_vala1_field;
												_data_->_tmp92_ = NULL;
												_data_->_tmp92_ = (*_data_->_tmp91_).properties;
												_data_->_tmp93_ = NULL;
												_data_->_tmp93_ = g_hash_table_lookup (_data_->_tmp92_, "domains");
												memset (&_data_->_tmp94_, 0, sizeof (size_t));
												_data_->_tmp95_ = NULL;
												_data_->_tmp95_ = g_variant_dup_strv ((GVariant*) _data_->_tmp93_, &_data_->_tmp94_);
												_data_->domainsArray = (_vala_array_free (_data_->domainsArray, _data_->domainsArray_length1, (GDestroyNotify) g_free), NULL);
												_data_->domainsArray = _data_->_tmp95_;
												_data_->domainsArray_length1 = _data_->_tmp94_;
												_data_->_domainsArray_size_ = _data_->domainsArray_length1;
											}
											_data_->_tmp96_ = NULL;
											_data_->_tmp96_ = g_ptr_array_new_with_free_func (_g_free0_);
											_data_->domains = _data_->_tmp96_;
											{
												_data_->i = 0;
												{
													_data_->_tmp97_ = TRUE;
													while (TRUE) {
														_data_->_tmp98_ = FALSE;
														_data_->_tmp98_ = _data_->_tmp97_;
														if (!_data_->_tmp98_) {
															_data_->_tmp99_ = 0;
															_data_->_tmp99_ = _data_->i;
															_data_->i = _data_->_tmp99_ + 1;
														}
														_data_->_tmp97_ = FALSE;
														_data_->_tmp100_ = 0;
														_data_->_tmp100_ = _data_->i;
														_data_->_tmp101_ = NULL;
														_data_->_tmp101__length1 = 0;
														_data_->_tmp101_ = _data_->domainsArray;
														_data_->_tmp101__length1 = _data_->domainsArray_length1;
														if (!(_data_->_tmp100_ < _data_->_tmp101__length1)) {
															break;
														}
														_data_->_tmp102_ = NULL;
														_data_->_tmp102_ = _data_->domains;
														_data_->_tmp103_ = NULL;
														_data_->_tmp103__length1 = 0;
														_data_->_tmp103_ = _data_->domainsArray;
														_data_->_tmp103__length1 = _data_->domainsArray_length1;
														_data_->_tmp104_ = 0;
														_data_->_tmp104_ = _data_->i;
														_data_->_tmp105_ = NULL;
														_data_->_tmp105_ = _data_->_tmp103_[_data_->_tmp104_];
														_data_->_tmp106_ = NULL;
														_data_->_tmp106_ = g_strdup (_data_->_tmp105_);
														g_ptr_array_add (_data_->_tmp102_, _data_->_tmp106_);
													}
												}
											}
											_data_->_tmp110_ = NULL;
											_data_->_tmp110_ = _data_->_vala1_field;
											_data_->_tmp111_ = NULL;
											_data_->_tmp111_ = (*_data_->_tmp110_).properties;
											if (_data_->_tmp111_ != NULL) {
												_data_->_tmp112_ = NULL;
												_data_->_tmp112_ = _data_->_vala1_field;
												_data_->_tmp113_ = NULL;
												_data_->_tmp113_ = (*_data_->_tmp112_).properties;
												_data_->_tmp114_ = FALSE;
												_data_->_tmp114_ = g_hash_table_contains (_data_->_tmp113_, "read-only");
												_data_->_tmp109_ = _data_->_tmp114_;
											} else {
												_data_->_tmp109_ = FALSE;
											}
											_data_->_tmp115_ = FALSE;
											_data_->_tmp115_ = _data_->_tmp109_;
											if (_data_->_tmp115_) {
												_data_->_tmp116_ = NULL;
												_data_->_tmp116_ = _data_->_vala1_field;
												_data_->_tmp117_ = NULL;
												_data_->_tmp117_ = (*_data_->_tmp116_).properties;
												_data_->_tmp118_ = NULL;
												_data_->_tmp118_ = g_hash_table_lookup (_data_->_tmp117_, "read-only");
												_data_->_tmp119_ = NULL;
												_data_->_tmp119_ = G_VARIANT_TYPE_BOOLEAN;
												_data_->_tmp120_ = FALSE;
												_data_->_tmp120_ = g_variant_is_of_type ((GVariant*) _data_->_tmp118_, _data_->_tmp119_);
												_data_->_tmp108_ = _data_->_tmp120_;
											} else {
												_data_->_tmp108_ = FALSE;
											}
											_data_->_tmp121_ = FALSE;
											_data_->_tmp121_ = _data_->_tmp108_;
											if (_data_->_tmp121_) {
												_data_->_tmp122_ = NULL;
												_data_->_tmp122_ = _data_->_vala1_field;
												_data_->_tmp123_ = NULL;
												_data_->_tmp123_ = (*_data_->_tmp122_).properties;
												_data_->_tmp124_ = NULL;
												_data_->_tmp124_ = g_hash_table_lookup (_data_->_tmp123_, "read-only");
												_data_->_tmp125_ = FALSE;
												_data_->_tmp125_ = g_variant_get_boolean ((GVariant*) _data_->_tmp124_);
												_data_->_tmp107_ = _data_->_tmp125_;
											} else {
												_data_->_tmp107_ = FALSE;
											}
											_data_->_tmp126_ = FALSE;
											_data_->_tmp126_ = _data_->_tmp107_;
											_data_->read_only = _data_->_tmp126_;
											_data_->_tmp128_ = NULL;
											_data_->_tmp128_ = _data_->domains;
											_data_->_tmp129_ = 0;
											_data_->_tmp129_ = g_ptr_array_get_length (_data_->_tmp128_);
											_data_->_tmp130_ = 0;
											_data_->_tmp130_ = _data_->_tmp129_;
											if (_data_->_tmp130_ == 0) {
												_data_->_tmp127_ = TRUE;
											} else {
												_data_->_tmp132_ = NULL;
												_data_->_tmp132_ = _data_->domains;
												_data_->_tmp133_ = 0;
												_data_->_tmp133_ = g_ptr_array_get_length (_data_->_tmp132_);
												_data_->_tmp134_ = 0;
												_data_->_tmp134_ = _data_->_tmp133_;
												if (_data_->_tmp134_ == 1) {
													_data_->_tmp136_ = NULL;
													_data_->_tmp136_ = _data_->domains;
													_data_->_tmp137_ = NULL;
													_data_->_tmp137_ = g_ptr_array_index (_data_->_tmp136_, (guint) 0);
													_data_->_tmp138_ = NULL;
													_data_->_tmp138_ = _data_->default_value;
													if (g_strcmp0 ((const gchar*) _data_->_tmp137_, _data_->_tmp138_) == 0) {
														_data_->_tmp135_ = TRUE;
													} else {
														_data_->_tmp139_ = NULL;
														_data_->_tmp139_ = _data_->default_value;
														_data_->_tmp140_ = 0;
														_data_->_tmp140_ = strlen (_data_->_tmp139_);
														_data_->_tmp141_ = 0;
														_data_->_tmp141_ = _data_->_tmp140_;
														_data_->_tmp135_ = _data_->_tmp141_ == 0;
													}
													_data_->_tmp142_ = FALSE;
													_data_->_tmp142_ = _data_->_tmp135_;
													_data_->_tmp131_ = _data_->_tmp142_;
												} else {
													_data_->_tmp131_ = FALSE;
												}
												_data_->_tmp143_ = FALSE;
												_data_->_tmp143_ = _data_->_tmp131_;
												_data_->_tmp127_ = _data_->_tmp143_;
											}
											_data_->_tmp144_ = FALSE;
											_data_->_tmp144_ = _data_->_tmp127_;
											if (_data_->_tmp144_) {
												_data_->_tmp145_ = NULL;
												_data_->_tmp145_ = _ ("Domain:");
												_data_->_tmp146_ = NULL;
												_data_->_tmp146_ = greeter_list_add_prompt ((GreeterList*) _data_->self, _data_->_tmp145_, FALSE);
												_data_->prompt = _data_->_tmp146_;
												_data_->_tmp148_ = NULL;
												_data_->_tmp148_ = _data_->domains;
												_data_->_tmp149_ = 0;
												_data_->_tmp149_ = g_ptr_array_get_length (_data_->_tmp148_);
												_data_->_tmp150_ = 0;
												_data_->_tmp150_ = _data_->_tmp149_;
												if (_data_->_tmp150_ == 1) {
													_data_->_tmp151_ = NULL;
													_data_->_tmp151_ = _data_->domains;
													_data_->_tmp152_ = NULL;
													_data_->_tmp152_ = g_ptr_array_index (_data_->_tmp151_, (guint) 0);
													_data_->_tmp147_ = (const gchar*) _data_->_tmp152_;
												} else {
													_data_->_tmp153_ = NULL;
													_data_->_tmp153_ = _data_->default_value;
													_data_->_tmp147_ = _data_->_tmp153_;
												}
												_data_->_tmp154_ = NULL;
												_data_->_tmp154_ = _data_->prompt;
												_data_->_tmp155_ = NULL;
												_data_->_tmp155_ = _data_->_tmp147_;
												gtk_entry_set_text ((GtkEntry*) _data_->_tmp154_, _data_->_tmp155_);
												_data_->_tmp156_ = NULL;
												_data_->_tmp156_ = _data_->prompt;
												_data_->_tmp157_ = FALSE;
												_data_->_tmp157_ = _data_->read_only;
												gtk_widget_set_sensitive ((GtkWidget*) _data_->_tmp156_, !_data_->_tmp157_);
												_data_->_tmp158_ = NULL;
												_data_->_tmp158_ = _data_->prompt;
												_data_->_tmp159_ = NULL;
												_data_->_tmp159_ = _g_object_ref0 ((GtkWidget*) _data_->_tmp158_);
												_g_object_unref0 (_data_->widget);
												_data_->widget = _data_->_tmp159_;
												_g_object_unref0 (_data_->prompt);
											} else {
												_data_->_tmp160_ = NULL;
												_data_->_tmp160_ = _data_->default_value;
												_data_->_tmp161_ = 0;
												_data_->_tmp161_ = strlen (_data_->_tmp160_);
												_data_->_tmp162_ = 0;
												_data_->_tmp162_ = _data_->_tmp161_;
												if (_data_->_tmp162_ > 0) {
													_data_->found = FALSE;
													{
														_data_->_vala1_i = 0;
														{
															_data_->_tmp163_ = TRUE;
															while (TRUE) {
																_data_->_tmp164_ = FALSE;
																_data_->_tmp164_ = _data_->_tmp163_;
																if (!_data_->_tmp164_) {
																	_data_->_tmp165_ = 0;
																	_data_->_tmp165_ = _data_->_vala1_i;
																	_data_->_vala1_i = _data_->_tmp165_ + 1;
																}
																_data_->_tmp163_ = FALSE;
																_data_->_tmp167_ = FALSE;
																_data_->_tmp167_ = _data_->found;
																if (!_data_->_tmp167_) {
																	_data_->_tmp168_ = 0;
																	_data_->_tmp168_ = _data_->_vala1_i;
																	_data_->_tmp169_ = NULL;
																	_data_->_tmp169_ = _data_->domains;
																	_data_->_tmp170_ = 0;
																	_data_->_tmp170_ = g_ptr_array_get_length (_data_->_tmp169_);
																	_data_->_tmp171_ = 0;
																	_data_->_tmp171_ = _data_->_tmp170_;
																	_data_->_tmp166_ = _data_->_tmp168_ < _data_->_tmp171_;
																} else {
																	_data_->_tmp166_ = FALSE;
																}
																_data_->_tmp172_ = FALSE;
																_data_->_tmp172_ = _data_->_tmp166_;
																if (!_data_->_tmp172_) {
																	break;
																}
																_data_->_tmp173_ = NULL;
																_data_->_tmp173_ = _data_->default_value;
																_data_->_tmp174_ = NULL;
																_data_->_tmp174_ = _data_->domains;
																_data_->_tmp175_ = 0;
																_data_->_tmp175_ = _data_->_vala1_i;
																_data_->_tmp176_ = NULL;
																_data_->_tmp176_ = g_ptr_array_index (_data_->_tmp174_, (guint) _data_->_tmp175_);
																_data_->found = g_strcmp0 (_data_->_tmp173_, (const gchar*) _data_->_tmp176_) == 0;
															}
														}
													}
													_data_->_tmp177_ = FALSE;
													_data_->_tmp177_ = _data_->found;
													if (!_data_->_tmp177_) {
														_data_->_tmp178_ = NULL;
														_data_->_tmp178_ = _data_->domains;
														_data_->_tmp179_ = NULL;
														_data_->_tmp179_ = _data_->default_value;
														_data_->_tmp180_ = NULL;
														_data_->_tmp180_ = g_strdup (_data_->_tmp179_);
														g_ptr_array_add (_data_->_tmp178_, _data_->_tmp180_);
													}
												}
												_data_->_tmp181_ = NULL;
												_data_->_tmp181_ = _data_->domains;
												_data_->_tmp182_ = NULL;
												_data_->_tmp182_ = g_strcmp0;
												vala_g_ptr_array_sort (_data_->_tmp181_, _data_->_tmp182_);
												_data_->_tmp183_ = NULL;
												_data_->_tmp183_ = _data_->domains;
												_data_->_tmp184_ = FALSE;
												_data_->_tmp184_ = _data_->read_only;
												_data_->_tmp185_ = NULL;
												_data_->_tmp185_ = greeter_list_add_combo ((GreeterList*) _data_->self, _data_->_tmp183_, _data_->_tmp184_);
												_data_->combo = _data_->_tmp185_;
												_data_->_tmp186_ = NULL;
												_data_->_tmp186_ = _data_->default_value;
												_data_->_tmp187_ = 0;
												_data_->_tmp187_ = strlen (_data_->_tmp186_);
												_data_->_tmp188_ = 0;
												_data_->_tmp188_ = _data_->_tmp187_;
												if (_data_->_tmp188_ > 0) {
													_data_->_tmp189_ = FALSE;
													_data_->_tmp189_ = _data_->read_only;
													if (_data_->_tmp189_) {
														{
															_data_->_vala2_i = 0;
															{
																_data_->_tmp190_ = TRUE;
																while (TRUE) {
																	_data_->_tmp191_ = FALSE;
																	_data_->_tmp191_ = _data_->_tmp190_;
																	if (!_data_->_tmp191_) {
																		_data_->_tmp192_ = 0;
																		_data_->_tmp192_ = _data_->_vala2_i;
																		_data_->_vala2_i = _data_->_tmp192_ + 1;
																	}
																	_data_->_tmp190_ = FALSE;
																	_data_->_tmp193_ = 0;
																	_data_->_tmp193_ = _data_->_vala2_i;
																	_data_->_tmp194_ = NULL;
																	_data_->_tmp194_ = _data_->domains;
																	_data_->_tmp195_ = 0;
																	_data_->_tmp195_ = g_ptr_array_get_length (_data_->_tmp194_);
																	_data_->_tmp196_ = 0;
																	_data_->_tmp196_ = _data_->_tmp195_;
																	if (!(_data_->_tmp193_ < _data_->_tmp196_)) {
																		break;
																	}
																	_data_->_tmp197_ = NULL;
																	_data_->_tmp197_ = _data_->default_value;
																	_data_->_tmp198_ = NULL;
																	_data_->_tmp198_ = _data_->domains;
																	_data_->_tmp199_ = 0;
																	_data_->_tmp199_ = _data_->_vala2_i;
																	_data_->_tmp200_ = NULL;
																	_data_->_tmp200_ = g_ptr_array_index (_data_->_tmp198_, (guint) _data_->_tmp199_);
																	if (g_strcmp0 (_data_->_tmp197_, (const gchar*) _data_->_tmp200_) == 0) {
																		_data_->_tmp201_ = NULL;
																		_data_->_tmp201_ = _data_->combo;
																		_data_->_tmp202_ = 0;
																		_data_->_tmp202_ = _data_->_vala2_i;
																		gtk_combo_box_set_active (_data_->_tmp201_, _data_->_tmp202_);
																		break;
																	}
																}
															}
														}
													} else {
														_data_->_tmp203_ = NULL;
														_data_->_tmp203_ = _data_->combo;
														_data_->_tmp204_ = NULL;
														_data_->_tmp204_ = gtk_bin_get_child ((GtkBin*) _data_->_tmp203_);
														_data_->_tmp205_ = NULL;
														_data_->_tmp205_ = _g_object_ref0 (G_TYPE_CHECK_INSTANCE_TYPE (_data_->_tmp204_, GTK_TYPE_ENTRY) ? ((GtkEntry*) _data_->_tmp204_) : NULL);
														_data_->_vala2_entry = _data_->_tmp205_;
														_data_->_tmp206_ = NULL;
														_data_->_tmp206_ = _data_->_vala2_entry;
														_data_->_tmp207_ = NULL;
														_data_->_tmp207_ = _data_->default_value;
														gtk_entry_set_text (_data_->_tmp206_, _data_->_tmp207_);
														_g_object_unref0 (_data_->_vala2_entry);
													}
												}
												_data_->_tmp208_ = NULL;
												_data_->_tmp208_ = _data_->combo;
												_data_->_tmp209_ = NULL;
												_data_->_tmp209_ = _g_object_ref0 ((GtkWidget*) _data_->_tmp208_);
												_g_object_unref0 (_data_->widget);
												_data_->widget = _data_->_tmp209_;
												_g_object_unref0 (_data_->combo);
											}
											_g_ptr_array_unref0 (_data_->domains);
											_data_->domainsArray = (_vala_array_free (_data_->domainsArray, _data_->domainsArray_length1, (GDestroyNotify) g_free), NULL);
										} else {
											_data_->_tmp210_ = NULL;
											_data_->_tmp210_ = _data_->_vala1_field;
											_data_->_tmp211_ = NULL;
											_data_->_tmp211_ = (*_data_->_tmp210_).type;
											if (g_strcmp0 (_data_->_tmp211_, "email") == 0) {
												_data_->email_domains_length1 = 0;
												_data_->_email_domains_size_ = 0;
												{
													_data_->_tmp212_ = NULL;
													_data_->_tmp212_ = unity_greeter_singleton;
													_data_->_tmp213_ = FALSE;
													_data_->_tmp213_ = _data_->_tmp212_->test_mode;
													if (_data_->_tmp213_) {
														_data_->_tmp214_ = NULL;
														_data_->_tmp214_ = g_strdup ("canonical.com");
														_data_->_tmp215_ = NULL;
														_data_->_tmp215_ = g_strdup ("ubuntu.org");
														_data_->_tmp216_ = NULL;
														_data_->_tmp216_ = g_strdup ("candy.com");
														_data_->_tmp217_ = NULL;
														_data_->_tmp217_ = g_strdup ("urban.net");
														_data_->_tmp218_ = NULL;
														_data_->_tmp218_ = g_new0 (gchar*, 4 + 1);
														_data_->_tmp218_[0] = _data_->_tmp214_;
														_data_->_tmp218_[1] = _data_->_tmp215_;
														_data_->_tmp218_[2] = _data_->_tmp216_;
														_data_->_tmp218_[3] = _data_->_tmp217_;
														_data_->email_domains = (_vala_array_free (_data_->email_domains, _data_->email_domains_length1, (GDestroyNotify) g_free), NULL);
														_data_->email_domains = _data_->_tmp218_;
														_data_->email_domains_length1 = 4;
														_data_->_email_domains_size_ = _data_->email_domains_length1;
													} else {
														_data_->_tmp219_ = NULL;
														_data_->_tmp219_ = _data_->self->priv->remote_login_service;
														_data_->_tmp220_ = NULL;
														_data_->_tmp220_ = _data_->url;
														_data_->_tmp221_ = NULL;
														_data_->_tmp222_ = 0;
														_data_->_state_ = 1;
														remote_login_service_get_cached_domains_for_server (_data_->_tmp219_, _data_->_tmp220_, user_list_create_remote_fields_for_current_item_ready, _data_);
														return FALSE;
														_state_1:
														remote_login_service_get_cached_domains_for_server_finish (_data_->_tmp219_, _data_->_res_, &_data_->_tmp221_, &_data_->_tmp222_, &_data_->_inner_error_);
														_data_->email_domains = (_vala_array_free (_data_->email_domains, _data_->email_domains_length1, (GDestroyNotify) g_free), NULL);
														_data_->email_domains = _data_->_tmp221_;
														_data_->email_domains_length1 = _data_->_tmp222_;
														_data_->_email_domains_size_ = _data_->email_domains_length1;
														if (_data_->_inner_error_ != NULL) {
															if (_data_->_inner_error_->domain == G_IO_ERROR) {
																goto __catch42_g_io_error;
															}
															_data_->email_domains = (_vala_array_free (_data_->email_domains, _data_->email_domains_length1, (GDestroyNotify) g_free), NULL);
															_g_free0 (_data_->default_value);
															_g_object_unref0 (_data_->widget);
															_remote_server_field_free0 (_data_->_vala1_field);
															__g_list_free__remote_server_field_free0_0 (_data_->fields);
															_g_free0 (_data_->remote_username);
															_remote_server_free0 (_data_->remote_server);
															_g_free0 (_data_->username);
															_g_free0 (_data_->url);
															g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _data_->_inner_error_->message, g_quark_to_string (_data_->_inner_error_->domain), _data_->_inner_error_->code);
															g_clear_error (&_data_->_inner_error_);
															return FALSE;
														}
													}
												}
												goto __finally42;
												__catch42_g_io_error:
												{
													_data_->e = _data_->_inner_error_;
													_data_->_inner_error_ = NULL;
													_data_->_tmp223_ = 0;
													_data_->_tmp223_ = 0;
													_data_->email_domains = g_renew (gchar*, _data_->email_domains, 0);
													(_data_->_tmp223_ > _data_->email_domains_length1) ? memset (_data_->email_domains + _data_->email_domains_length1, 0, sizeof (gchar*) * (_data_->_tmp223_ - _data_->email_domains_length1)) : NULL;
													_data_->email_domains_length1 = _data_->_tmp223_;
													_data_->_email_domains_size_ = _data_->_tmp223_;
													_data_->_tmp224_ = NULL;
													_data_->_tmp224_ = _data_->e;
													_data_->_tmp225_ = NULL;
													_data_->_tmp225_ = _data_->_tmp224_->message;
													g_debug ("user-list.vala:785: Calling get_cached_domains_for_server in com.canon" \
"ical.RemoteLogin dbus service failed. Error: %s", _data_->_tmp225_);
													_g_error_free0 (_data_->e);
												}
												__finally42:
												if (_data_->_inner_error_ != NULL) {
													_data_->email_domains = (_vala_array_free (_data_->email_domains, _data_->email_domains_length1, (GDestroyNotify) g_free), NULL);
													_g_free0 (_data_->default_value);
													_g_object_unref0 (_data_->widget);
													_remote_server_field_free0 (_data_->_vala1_field);
													__g_list_free__remote_server_field_free0_0 (_data_->fields);
													_g_free0 (_data_->remote_username);
													_remote_server_free0 (_data_->remote_server);
													_g_free0 (_data_->username);
													_g_free0 (_data_->url);
													g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _data_->_inner_error_->message, g_quark_to_string (_data_->_inner_error_->domain), _data_->_inner_error_->code);
													g_clear_error (&_data_->_inner_error_);
													return FALSE;
												}
												_data_->_tmp226_ = NULL;
												_data_->_tmp226_ = _ ("Email address:");
												_data_->_tmp227_ = NULL;
												_data_->_tmp227_ = greeter_list_add_prompt ((GreeterList*) _data_->self, _data_->_tmp226_, FALSE);
												_data_->_vala3_entry = _data_->_tmp227_;
												_data_->_tmp228_ = NULL;
												_data_->_tmp228_ = _data_->_vala3_entry;
												_data_->_tmp229_ = NULL;
												_data_->_tmp229_ = _data_->default_value;
												gtk_entry_set_text ((GtkEntry*) _data_->_tmp228_, _data_->_tmp229_);
												_data_->_tmp230_ = NULL;
												_data_->_tmp230_ = _data_->_vala3_entry;
												_data_->_tmp231_ = NULL;
												_data_->_tmp231_ = _g_object_ref0 ((GtkWidget*) _data_->_tmp230_);
												_g_object_unref0 (_data_->widget);
												_data_->widget = _data_->_tmp231_;
												_data_->_tmp232_ = NULL;
												_data_->_tmp232__length1 = 0;
												_data_->_tmp232_ = _data_->email_domains;
												_data_->_tmp232__length1 = _data_->email_domains_length1;
												if (_data_->_tmp232__length1 > 0) {
													_data_->_tmp233_ = NULL;
													_data_->_tmp233_ = _data_->_vala3_entry;
													_data_->_tmp234_ = NULL;
													_data_->_tmp234__length1 = 0;
													_data_->_tmp234_ = _data_->email_domains;
													_data_->_tmp234__length1 = _data_->email_domains_length1;
													_data_->_tmp235_ = NULL;
													_data_->_tmp235_ = email_autocompleter_new ((GtkEntry*) _data_->_tmp233_, _data_->_tmp234_, _data_->_tmp234__length1);
													_email_autocompleter_unref0 (_data_->self->priv->remote_server_email_field_autocompleter);
													_data_->self->priv->remote_server_email_field_autocompleter = _data_->_tmp235_;
												}
												_g_object_unref0 (_data_->_vala3_entry);
												_data_->email_domains = (_vala_array_free (_data_->email_domains, _data_->email_domains_length1, (GDestroyNotify) g_free), NULL);
											} else {
												_data_->_tmp236_ = NULL;
												_data_->_tmp236_ = _data_->_vala1_field;
												_data_->_tmp237_ = NULL;
												_data_->_tmp237_ = (*_data_->_tmp236_).type;
												g_debug ("user-list.vala:796: Found field of type %s, don't know what to do with" \
" it", _data_->_tmp237_);
												_g_free0 (_data_->default_value);
												_g_object_unref0 (_data_->widget);
												_remote_server_field_free0 (_data_->_vala1_field);
												continue;
											}
										}
									}
								}
								_data_->_tmp238_ = NULL;
								_data_->_tmp238_ = _data_->self->priv->current_remote_fields;
								_data_->_tmp239_ = NULL;
								_data_->_tmp239_ = _data_->_vala1_field;
								_data_->_tmp240_ = NULL;
								_data_->_tmp240_ = (*_data_->_tmp239_).type;
								_data_->_tmp241_ = NULL;
								_data_->_tmp241_ = g_strdup (_data_->_tmp240_);
								_data_->_tmp242_ = NULL;
								_data_->_tmp242_ = _data_->widget;
								_data_->_tmp243_ = NULL;
								_data_->_tmp243_ = _g_object_ref0 (_data_->_tmp242_);
								g_hash_table_insert (_data_->_tmp238_, _data_->_tmp241_, _data_->_tmp243_);
								_g_free0 (_data_->default_value);
								_g_object_unref0 (_data_->widget);
								_remote_server_field_free0 (_data_->_vala1_field);
							}
						}
					}
					__g_list_free__remote_server_field_free0_0 (_data_->fields);
					_g_free0 (_data_->remote_username);
					_remote_server_free0 (_data_->remote_server);
					break;
				}
				_g_free0 (_data_->remote_username);
				_remote_server_free0 (_data_->remote_server);
			}
		}
	}
	_g_free0 (_data_->username);
	_g_free0 (_data_->url);
	if (_data_->_state_ == 0) {
		g_simple_async_result_complete_in_idle (_data_->_async_result);
	} else {
		g_simple_async_result_complete (_data_->_async_result);
	}
	g_object_unref (_data_->_async_result);
	return FALSE;
}


static void user_list_real_focus_prompt (GreeterList* base) {
	UserList * self;
	PromptBox* _tmp0_ = NULL;
	PromptBox* _tmp1_ = NULL;
	const gchar* _tmp2_ = NULL;
	const gchar* _tmp3_ = NULL;
	gboolean _tmp4_ = FALSE;
	self = (UserList*) base;
	_tmp0_ = greeter_list_get_selected_entry ((GreeterList*) self);
	_tmp1_ = _tmp0_;
	_tmp2_ = prompt_box_get_id (_tmp1_);
	_tmp3_ = _tmp2_;
	_tmp4_ = g_str_has_prefix (_tmp3_, "*remote_login");
	if (_tmp4_) {
		gchar* url = NULL;
		PromptBox* _tmp5_ = NULL;
		PromptBox* _tmp6_ = NULL;
		const gchar* _tmp7_ = NULL;
		const gchar* _tmp8_ = NULL;
		gchar* _tmp9_ = NULL;
		GList* _tmp10_ = NULL;
		_tmp5_ = greeter_list_get_selected_entry ((GreeterList*) self);
		_tmp6_ = _tmp5_;
		_tmp7_ = prompt_box_get_id (_tmp6_);
		_tmp8_ = _tmp7_;
		_tmp9_ = user_list_url_from_remote_loding_server_list_name (self, _tmp8_);
		url = _tmp9_;
		_tmp10_ = self->priv->remote_login_server_list;
		{
			GList* remote_server_collection = NULL;
			GList* remote_server_it = NULL;
			remote_server_collection = _tmp10_;
			for (remote_server_it = remote_server_collection; remote_server_it != NULL; remote_server_it = remote_server_it->next) {
				RemoteServer* _tmp11_ = NULL;
				RemoteServer* remote_server = NULL;
				_tmp11_ = _remote_server_dup0 ((RemoteServer*) remote_server_it->data);
				remote_server = _tmp11_;
				{
					RemoteServer* _tmp12_ = NULL;
					const gchar* _tmp13_ = NULL;
					const gchar* _tmp14_ = NULL;
					_tmp12_ = remote_server;
					_tmp13_ = (*_tmp12_).url;
					_tmp14_ = url;
					if (g_strcmp0 (_tmp13_, _tmp14_) == 0) {
						RemoteServer* _tmp15_ = NULL;
						const gchar* _tmp16_ = NULL;
						gboolean _tmp17_ = FALSE;
						_tmp15_ = remote_server;
						_tmp16_ = (*_tmp15_).type;
						_tmp17_ = user_list_is_supported_remote_session (self, _tmp16_);
						if (!_tmp17_) {
							PromptBox* _tmp18_ = NULL;
							PromptBox* _tmp19_ = NULL;
							_tmp18_ = greeter_list_get_selected_entry ((GreeterList*) self);
							_tmp19_ = _tmp18_;
							gtk_widget_set_sensitive ((GtkWidget*) _tmp19_, FALSE);
							_remote_server_free0 (remote_server);
							_g_free0 (url);
							return;
						}
					}
					_remote_server_free0 (remote_server);
				}
			}
		}
		_g_free0 (url);
	}
	GREETER_LIST_CLASS (user_list_parent_class)->focus_prompt (G_TYPE_CHECK_INSTANCE_CAST (self, TYPE_GREETER_LIST, GreeterList));
}


static void user_list_real_show_authenticated (GreeterList* base, gboolean successful) {
	UserList * self;
	gboolean _tmp0_ = FALSE;
	GreeterListMode _tmp21_ = 0;
	self = (UserList*) base;
	_tmp0_ = successful;
	if (_tmp0_) {
		PromptBox* _tmp1_ = NULL;
		PromptBox* _tmp2_ = NULL;
		const gchar* _tmp3_ = NULL;
		const gchar* _tmp4_ = NULL;
		PromptBox* _tmp5_ = NULL;
		PromptBox* _tmp6_ = NULL;
		const gchar* _tmp7_ = NULL;
		const gchar* _tmp8_ = NULL;
		gchar* _tmp9_ = NULL;
		gchar* _tmp10_ = NULL;
		_tmp1_ = greeter_list_get_selected_entry ((GreeterList*) self);
		_tmp2_ = _tmp1_;
		_tmp3_ = _ ("Log In");
		_tmp4_ = _ ("Login as %s");
		_tmp5_ = greeter_list_get_selected_entry ((GreeterList*) self);
		_tmp6_ = _tmp5_;
		_tmp7_ = prompt_box_get_label (_tmp6_);
		_tmp8_ = _tmp7_;
		_tmp9_ = g_strdup_printf (_tmp4_, _tmp8_);
		_tmp10_ = _tmp9_;
		prompt_box_add_button (_tmp2_, _tmp3_, _tmp10_);
		_g_free0 (_tmp10_);
	} else {
		PromptBox* _tmp11_ = NULL;
		PromptBox* _tmp12_ = NULL;
		const gchar* _tmp13_ = NULL;
		const gchar* _tmp14_ = NULL;
		PromptBox* _tmp15_ = NULL;
		PromptBox* _tmp16_ = NULL;
		const gchar* _tmp17_ = NULL;
		const gchar* _tmp18_ = NULL;
		gchar* _tmp19_ = NULL;
		gchar* _tmp20_ = NULL;
		_tmp11_ = greeter_list_get_selected_entry ((GreeterList*) self);
		_tmp12_ = _tmp11_;
		_tmp13_ = _ ("Retry");
		_tmp14_ = _ ("Retry as %s");
		_tmp15_ = greeter_list_get_selected_entry ((GreeterList*) self);
		_tmp16_ = _tmp15_;
		_tmp17_ = prompt_box_get_label (_tmp16_);
		_tmp18_ = _tmp17_;
		_tmp19_ = g_strdup_printf (_tmp14_, _tmp18_);
		_tmp20_ = _tmp19_;
		prompt_box_add_button (_tmp12_, _tmp13_, _tmp20_);
		_g_free0 (_tmp20_);
	}
	_tmp21_ = ((GreeterList*) self)->mode;
	if (_tmp21_ != GREETER_LIST_MODE_SCROLLING) {
		PromptBox* _tmp22_ = NULL;
		PromptBox* _tmp23_ = NULL;
		_tmp22_ = greeter_list_get_selected_entry ((GreeterList*) self);
		_tmp23_ = _tmp22_;
		prompt_box_show_prompts (_tmp23_);
	}
	greeter_list_focus_prompt ((GreeterList*) self);
	greeter_list_redraw_greeter_box ((GreeterList*) self);
}


static void _user_list_prompt_box_respond_cb_prompt_box_respond (PromptBox* _sender, gchar** response, int response_length1, gpointer self) {
	user_list_prompt_box_respond_cb (self, response, response_length1);
}


static void _user_list_prompt_box_login_cb_prompt_box_login (PromptBox* _sender, gpointer self) {
	user_list_prompt_box_login_cb (self);
}


static void _user_list_prompt_box_show_options_cb_prompt_box_show_options (PromptBox* _sender, gpointer self) {
	user_list_prompt_box_show_options_cb (self);
}


void user_list_add_user (UserList* self, const gchar* name, const gchar* label, const gchar* background, gboolean is_active, gboolean has_messages, const gchar* session) {
	UserPromptBox* e = NULL;
	const gchar* _tmp0_ = NULL;
	PromptBox* _tmp1_ = NULL;
	UserPromptBox* _tmp2_ = NULL;
	UserPromptBox* _tmp3_ = NULL;
	UserPromptBox* _tmp12_ = NULL;
	const gchar* _tmp13_ = NULL;
	gchar* _tmp14_ = NULL;
	UserPromptBox* _tmp15_ = NULL;
	gboolean _tmp16_ = FALSE;
	UserPromptBox* _tmp17_ = NULL;
	const gchar* _tmp18_ = NULL;
	gchar* _tmp19_ = NULL;
	UserPromptBox* _tmp20_ = NULL;
	const gchar* _tmp21_ = NULL;
	UserPromptBox* _tmp22_ = NULL;
	gboolean _tmp23_ = FALSE;
	UserPromptBox* _tmp24_ = NULL;
	gboolean _tmp25_ = FALSE;
	gboolean _tmp26_ = FALSE;
	gboolean _tmp27_ = FALSE;
	gboolean _tmp30_ = FALSE;
	g_return_if_fail (self != NULL);
	g_return_if_fail (name != NULL);
	g_return_if_fail (label != NULL);
	_tmp0_ = name;
	_tmp1_ = greeter_list_find_entry ((GreeterList*) self, _tmp0_);
	_tmp2_ = G_TYPE_CHECK_INSTANCE_TYPE (_tmp1_, TYPE_USER_PROMPT_BOX) ? ((UserPromptBox*) _tmp1_) : NULL;
	if (_tmp2_ == NULL) {
		_g_object_unref0 (_tmp1_);
	}
	e = _tmp2_;
	_tmp3_ = e;
	if (_tmp3_ == NULL) {
		const gchar* _tmp4_ = NULL;
		UserPromptBox* _tmp5_ = NULL;
		UserPromptBox* _tmp6_ = NULL;
		UserPromptBox* _tmp7_ = NULL;
		UserPromptBox* _tmp8_ = NULL;
		UserPromptBox* _tmp9_ = NULL;
		const gchar* _tmp10_ = NULL;
		UserPromptBox* _tmp11_ = NULL;
		_tmp4_ = name;
		_tmp5_ = user_prompt_box_new (_tmp4_);
		g_object_ref_sink (_tmp5_);
		_g_object_unref0 (e);
		e = _tmp5_;
		_tmp6_ = e;
		g_signal_connect_object ((PromptBox*) _tmp6_, "respond", (GCallback) _user_list_prompt_box_respond_cb_prompt_box_respond, self, 0);
		_tmp7_ = e;
		g_signal_connect_object ((PromptBox*) _tmp7_, "login", (GCallback) _user_list_prompt_box_login_cb_prompt_box_login, self, 0);
		_tmp8_ = e;
		g_signal_connect_object ((PromptBox*) _tmp8_, "show-options", (GCallback) _user_list_prompt_box_show_options_cb_prompt_box_show_options, self, 0);
		_tmp9_ = e;
		_tmp10_ = label;
		prompt_box_set_label ((PromptBox*) _tmp9_, _tmp10_);
		_tmp11_ = e;
		greeter_list_add_entry ((GreeterList*) self, (PromptBox*) _tmp11_);
	}
	_tmp12_ = e;
	_tmp13_ = background;
	_tmp14_ = g_strdup (_tmp13_);
	_g_free0 (_tmp12_->background);
	_tmp12_->background = _tmp14_;
	_tmp15_ = e;
	_tmp16_ = is_active;
	_tmp15_->is_active = _tmp16_;
	_tmp17_ = e;
	_tmp18_ = session;
	_tmp19_ = g_strdup (_tmp18_);
	_g_free0 (_tmp17_->session);
	_tmp17_->session = _tmp19_;
	_tmp20_ = e;
	_tmp21_ = label;
	prompt_box_set_label ((PromptBox*) _tmp20_, _tmp21_);
	_tmp22_ = e;
	_tmp23_ = has_messages;
	prompt_box_set_show_message_icon ((PromptBox*) _tmp22_, _tmp23_);
	_tmp24_ = e;
	_tmp25_ = is_active;
	prompt_box_set_is_active ((PromptBox*) _tmp24_, _tmp25_);
	_tmp27_ = greeter_list_have_entries ((GreeterList*) self);
	if (_tmp27_) {
		gboolean _tmp28_ = FALSE;
		gboolean _tmp29_ = FALSE;
		_tmp28_ = greeter_list_get_always_show_manual ((GreeterList*) self);
		_tmp29_ = _tmp28_;
		_tmp26_ = !_tmp29_;
	} else {
		_tmp26_ = FALSE;
	}
	_tmp30_ = _tmp26_;
	if (_tmp30_) {
		greeter_list_remove_entry ((GreeterList*) self, "*other");
	}
	_g_object_unref0 (e);
}


static void user_list_real_add_manual_entry (GreeterList* base) {
	UserList * self;
	gchar* text = NULL;
	const gchar* _tmp0_ = NULL;
	const gchar* _tmp1_ = NULL;
	gchar* _tmp2_ = NULL;
	const gchar* _tmp3_ = NULL;
	const gchar* _tmp6_ = NULL;
	self = (UserList*) base;
	_tmp0_ = greeter_list_get_manual_name ((GreeterList*) self);
	_tmp1_ = _tmp0_;
	_tmp2_ = g_strdup (_tmp1_);
	text = _tmp2_;
	_tmp3_ = text;
	if (_tmp3_ == NULL) {
		const gchar* _tmp4_ = NULL;
		gchar* _tmp5_ = NULL;
		_tmp4_ = _ ("Login");
		_tmp5_ = g_strdup (_tmp4_);
		_g_free0 (text);
		text = _tmp5_;
	}
	_tmp6_ = text;
	user_list_add_user (self, "*other", _tmp6_, NULL, FALSE, FALSE, NULL);
	_g_free0 (text);
}


void user_list_prompt_box_respond_cb (UserList* self, gchar** responses, int responses_length1) {
	PromptBox* _tmp0_ = NULL;
	PromptBox* _tmp1_ = NULL;
	gchar** _tmp2_ = NULL;
	gint _tmp2__length1 = 0;
	g_return_if_fail (self != NULL);
	_tmp0_ = greeter_list_get_selected_entry ((GreeterList*) self);
	_tmp1_ = _tmp0_;
	gtk_widget_set_sensitive ((GtkWidget*) _tmp1_, FALSE);
	((GreeterList*) self)->will_clear = TRUE;
	((GreeterList*) self)->unacknowledged_messages = FALSE;
	_tmp2_ = responses;
	_tmp2__length1 = responses_length1;
	{
		gchar** response_collection = NULL;
		gint response_collection_length1 = 0;
		gint _response_collection_size_ = 0;
		gint response_it = 0;
		response_collection = _tmp2_;
		response_collection_length1 = _tmp2__length1;
		for (response_it = 0; response_it < _tmp2__length1; response_it = response_it + 1) {
			gchar* _tmp3_ = NULL;
			gchar* response = NULL;
			_tmp3_ = g_strdup (response_collection[response_it]);
			response = _tmp3_;
			{
				UnityGreeter* _tmp4_ = NULL;
				gboolean _tmp5_ = FALSE;
				_tmp4_ = unity_greeter_singleton;
				_tmp5_ = _tmp4_->test_mode;
				if (_tmp5_) {
					const gchar* _tmp6_ = NULL;
					_tmp6_ = response;
					user_list_test_respond (self, _tmp6_);
				} else {
					UnityGreeter* _tmp7_ = NULL;
					const gchar* _tmp8_ = NULL;
					_tmp7_ = unity_greeter_singleton;
					_tmp8_ = response;
					unity_greeter_respond (_tmp7_, _tmp8_);
				}
				_g_free0 (response);
			}
		}
	}
}


static void user_list_prompt_box_login_cb (UserList* self) {
	PromptBox* _tmp0_ = NULL;
	PromptBox* _tmp1_ = NULL;
	const gchar* _tmp2_ = NULL;
	const gchar* _tmp3_ = NULL;
	gboolean is_authenticated = FALSE;
	UnityGreeter* _tmp4_ = NULL;
	gboolean _tmp5_ = FALSE;
	gboolean _tmp9_ = FALSE;
	g_return_if_fail (self != NULL);
	_tmp0_ = greeter_list_get_selected_entry ((GreeterList*) self);
	_tmp1_ = _tmp0_;
	_tmp2_ = prompt_box_get_id (_tmp1_);
	_tmp3_ = _tmp2_;
	g_debug ("user-list.vala:897: Start session for %s", _tmp3_);
	((GreeterList*) self)->unacknowledged_messages = FALSE;
	is_authenticated = FALSE;
	_tmp4_ = unity_greeter_singleton;
	_tmp5_ = _tmp4_->test_mode;
	if (_tmp5_) {
		gboolean _tmp6_ = FALSE;
		_tmp6_ = ((GreeterList*) self)->test_is_authenticated;
		is_authenticated = _tmp6_;
	} else {
		UnityGreeter* _tmp7_ = NULL;
		gboolean _tmp8_ = FALSE;
		_tmp7_ = unity_greeter_singleton;
		_tmp8_ = unity_greeter_is_authenticated (_tmp7_);
		is_authenticated = _tmp8_;
	}
	_tmp9_ = is_authenticated;
	if (_tmp9_) {
		greeter_list_authentication_complete_cb ((GreeterList*) self);
	} else {
		PromptBox* _tmp10_ = NULL;
		PromptBox* _tmp11_ = NULL;
		_tmp10_ = greeter_list_get_selected_entry ((GreeterList*) self);
		_tmp11_ = _tmp10_;
		prompt_box_clear (_tmp11_);
		greeter_list_start_authentication ((GreeterList*) self);
	}
}


static void _user_list_session_clicked_cb_session_list_session_clicked (SessionList* _sender, const gchar* session, gpointer self) {
	user_list_session_clicked_cb (self, session);
}


static void user_list_prompt_box_show_options_cb (UserList* self) {
	SessionList* session_chooser = NULL;
	Background* _tmp0_ = NULL;
	Background* _tmp1_ = NULL;
	const gchar* _tmp2_ = NULL;
	const gchar* _tmp3_ = NULL;
	const gchar* _tmp4_ = NULL;
	const gchar* _tmp5_ = NULL;
	SessionList* _tmp6_ = NULL;
	UnityGreeter* _tmp7_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = greeter_list_get_background ((GreeterList*) self);
	_tmp1_ = _tmp0_;
	_tmp2_ = user_list_get_session (self);
	_tmp3_ = _tmp2_;
	_tmp4_ = user_list_get_default_session (self);
	_tmp5_ = _tmp4_;
	_tmp6_ = session_list_new (_tmp1_, _tmp3_, _tmp5_);
	g_object_ref_sink (_tmp6_);
	session_chooser = _tmp6_;
	g_signal_connect_object (session_chooser, "session-clicked", (GCallback) _user_list_session_clicked_cb_session_list_session_clicked, self, 0);
	_tmp7_ = unity_greeter_singleton;
	unity_greeter_push_list (_tmp7_, (GreeterList*) session_chooser);
	_g_object_unref0 (session_chooser);
}


static void user_list_session_clicked_cb (UserList* self, const gchar* session) {
	const gchar* _tmp0_ = NULL;
	UnityGreeter* _tmp1_ = NULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (session != NULL);
	_tmp0_ = session;
	user_list_set_session (self, _tmp0_);
	_tmp1_ = unity_greeter_singleton;
	unity_greeter_pop_list (_tmp1_);
}


static gboolean user_list_should_show_session_badge (UserList* self) {
	gboolean result = FALSE;
	UnityGreeter* _tmp0_ = NULL;
	gboolean _tmp1_ = FALSE;
	g_return_val_if_fail (self != NULL, FALSE);
	_tmp0_ = unity_greeter_singleton;
	_tmp1_ = _tmp0_->test_mode;
	if (_tmp1_) {
		gchar* _tmp2_ = NULL;
		gchar* _tmp3_ = NULL;
		gboolean _tmp4_ = FALSE;
		_tmp2_ = greeter_list_get_selected_id ((GreeterList*) self);
		_tmp3_ = _tmp2_;
		_tmp4_ = g_strcmp0 (_tmp3_, "no-badge") != 0;
		_g_free0 (_tmp3_);
		result = _tmp4_;
		return result;
	} else {
		GList* _tmp5_ = NULL;
		guint _tmp6_ = 0U;
		_tmp5_ = lightdm_get_sessions ();
		_tmp6_ = g_list_length (_tmp5_);
		result = _tmp6_ > ((guint) 1);
		return result;
	}
}


static GdkPixbuf* user_list_get_badge (UserList* self) {
	GdkPixbuf* result = NULL;
	PromptBox* _tmp0_ = NULL;
	PromptBox* _tmp1_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = greeter_list_get_selected_entry ((GreeterList*) self);
	_tmp1_ = _tmp0_;
	if (G_TYPE_CHECK_INSTANCE_TYPE (_tmp1_, TYPE_USER_PROMPT_BOX)) {
		gboolean _tmp2_ = FALSE;
		_tmp2_ = user_list_should_show_session_badge (self);
		if (!_tmp2_) {
			result = NULL;
			return result;
		} else {
			const gchar* _tmp3_ = NULL;
			const gchar* _tmp4_ = NULL;
			_tmp3_ = user_list_get_session (self);
			_tmp4_ = _tmp3_;
			if (_tmp4_ == NULL) {
				const gchar* _tmp5_ = NULL;
				const gchar* _tmp6_ = NULL;
				GdkPixbuf* _tmp7_ = NULL;
				_tmp5_ = user_list_get_default_session (self);
				_tmp6_ = _tmp5_;
				_tmp7_ = session_list_get_badge (_tmp6_);
				result = _tmp7_;
				return result;
			} else {
				const gchar* _tmp8_ = NULL;
				const gchar* _tmp9_ = NULL;
				GdkPixbuf* _tmp10_ = NULL;
				_tmp8_ = user_list_get_session (self);
				_tmp9_ = _tmp8_;
				_tmp10_ = session_list_get_badge (_tmp9_);
				result = _tmp10_;
				return result;
			}
		}
	} else {
		PromptBox* _tmp11_ = NULL;
		PromptBox* _tmp12_ = NULL;
		const gchar* _tmp13_ = NULL;
		const gchar* _tmp14_ = NULL;
		gboolean _tmp15_ = FALSE;
		_tmp11_ = greeter_list_get_selected_entry ((GreeterList*) self);
		_tmp12_ = _tmp11_;
		_tmp13_ = prompt_box_get_id (_tmp12_);
		_tmp14_ = _tmp13_;
		_tmp15_ = g_str_has_prefix (_tmp14_, "*remote_directory");
		if (_tmp15_) {
			GdkPixbuf* _tmp16_ = NULL;
			_tmp16_ = session_list_get_badge ("remote-login");
			result = _tmp16_;
			return result;
		} else {
			result = NULL;
			return result;
		}
	}
}


static gboolean user_list_is_supported_remote_session (UserList* self, const gchar* session_internal_name) {
	gboolean result = FALSE;
	UnityGreeter* _tmp0_ = NULL;
	gboolean _tmp1_ = FALSE;
	gboolean found = FALSE;
	GList* _tmp3_ = NULL;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (session_internal_name != NULL, FALSE);
	_tmp0_ = unity_greeter_singleton;
	_tmp1_ = _tmp0_->test_mode;
	if (_tmp1_) {
		const gchar* _tmp2_ = NULL;
		_tmp2_ = session_internal_name;
		result = g_strcmp0 (_tmp2_, "rdp") == 0;
		return result;
	}
	found = FALSE;
	_tmp3_ = lightdm_get_remote_sessions ();
	{
		GList* session_collection = NULL;
		GList* session_it = NULL;
		session_collection = _tmp3_;
		for (session_it = session_collection; session_it != NULL; session_it = session_it->next) {
			LightDMSession* session = NULL;
			session = (LightDMSession*) session_it->data;
			{
				LightDMSession* _tmp4_ = NULL;
				const gchar* _tmp5_ = NULL;
				const gchar* _tmp6_ = NULL;
				const gchar* _tmp7_ = NULL;
				_tmp4_ = session;
				_tmp5_ = lightdm_session_get_key (_tmp4_);
				_tmp6_ = _tmp5_;
				_tmp7_ = session_internal_name;
				if (g_strcmp0 (_tmp6_, _tmp7_) == 0) {
					found = TRUE;
					break;
				}
			}
		}
	}
	result = found;
	return result;
}


static gchar* user_list_real_get_lightdm_session (GreeterList* base) {
	UserList * self;
	gchar* result = NULL;
	PromptBox* _tmp0_ = NULL;
	PromptBox* _tmp1_ = NULL;
	const gchar* _tmp2_ = NULL;
	const gchar* _tmp3_ = NULL;
	gboolean _tmp4_ = FALSE;
	self = (UserList*) base;
	_tmp0_ = greeter_list_get_selected_entry ((GreeterList*) self);
	_tmp1_ = _tmp0_;
	_tmp2_ = prompt_box_get_id (_tmp1_);
	_tmp3_ = _tmp2_;
	_tmp4_ = g_str_has_prefix (_tmp3_, "*remote_login");
	if (_tmp4_) {
		gchar* url = NULL;
		PromptBox* _tmp5_ = NULL;
		PromptBox* _tmp6_ = NULL;
		const gchar* _tmp7_ = NULL;
		const gchar* _tmp8_ = NULL;
		gchar* _tmp9_ = NULL;
		GList* it = NULL;
		GList* _tmp10_ = NULL;
		gchar* answer = NULL;
		gchar* _tmp11_ = NULL;
		const gchar* _tmp27_ = NULL;
		gboolean _tmp28_ = FALSE;
		_tmp5_ = greeter_list_get_selected_entry ((GreeterList*) self);
		_tmp6_ = _tmp5_;
		_tmp7_ = prompt_box_get_id (_tmp6_);
		_tmp8_ = _tmp7_;
		_tmp9_ = user_list_url_from_remote_loding_server_list_name (self, _tmp8_);
		url = _tmp9_;
		_tmp10_ = self->priv->remote_login_server_list;
		it = _tmp10_;
		_tmp11_ = g_strdup ("");
		answer = _tmp11_;
		while (TRUE) {
			gboolean _tmp12_ = FALSE;
			const gchar* _tmp13_ = NULL;
			gboolean _tmp15_ = FALSE;
			RemoteServer remote_server = {0};
			GList* _tmp16_ = NULL;
			gconstpointer _tmp17_ = NULL;
			RemoteServer _tmp18_ = {0};
			RemoteServer _tmp19_ = {0};
			const gchar* _tmp20_ = NULL;
			const gchar* _tmp21_ = NULL;
			GList* _tmp25_ = NULL;
			GList* _tmp26_ = NULL;
			_tmp13_ = answer;
			if (g_strcmp0 (_tmp13_, "") == 0) {
				GList* _tmp14_ = NULL;
				_tmp14_ = it;
				_tmp12_ = _tmp14_ != NULL;
			} else {
				_tmp12_ = FALSE;
			}
			_tmp15_ = _tmp12_;
			if (!_tmp15_) {
				break;
			}
			_tmp16_ = it;
			_tmp17_ = _tmp16_->data;
			remote_server_copy ((RemoteServer*) _tmp17_, &_tmp18_);
			remote_server = _tmp18_;
			_tmp19_ = remote_server;
			_tmp20_ = _tmp19_.url;
			_tmp21_ = url;
			if (g_strcmp0 (_tmp20_, _tmp21_) == 0) {
				RemoteServer _tmp22_ = {0};
				const gchar* _tmp23_ = NULL;
				gchar* _tmp24_ = NULL;
				_tmp22_ = remote_server;
				_tmp23_ = _tmp22_.type;
				_tmp24_ = g_strdup (_tmp23_);
				_g_free0 (answer);
				answer = _tmp24_;
			}
			_tmp25_ = it;
			_tmp26_ = _tmp25_->next;
			it = _tmp26_;
			remote_server_destroy (&remote_server);
		}
		_tmp27_ = answer;
		_tmp28_ = user_list_is_supported_remote_session (self, _tmp27_);
		if (_tmp28_) {
			result = answer;
			_g_free0 (url);
			return result;
		} else {
			gchar* _tmp29_ = NULL;
			_tmp29_ = g_strdup ("");
			result = _tmp29_;
			_g_free0 (answer);
			_g_free0 (url);
			return result;
		}
		_g_free0 (answer);
		_g_free0 (url);
	} else {
		const gchar* _tmp30_ = NULL;
		const gchar* _tmp31_ = NULL;
		gchar* _tmp32_ = NULL;
		_tmp30_ = user_list_get_session (self);
		_tmp31_ = _tmp30_;
		_tmp32_ = g_strdup (_tmp31_);
		result = _tmp32_;
		return result;
	}
}


static void _user_list_user_added_cb_lightdm_user_list_user_added (LightDMUserList* _sender, LightDMUser* user, gpointer self) {
	user_list_user_added_cb (self, user);
}


static void _user_list_user_added_cb_lightdm_user_list_user_changed (LightDMUserList* _sender, LightDMUser* user, gpointer self) {
	user_list_user_added_cb (self, user);
}


static void _user_list_user_removed_cb_lightdm_user_list_user_removed (LightDMUserList* _sender, LightDMUser* user, gpointer self) {
	user_list_user_removed_cb (self, user);
}


static void user_list_fill_list (UserList* self) {
	UnityGreeter* _tmp0_ = NULL;
	gboolean _tmp1_ = FALSE;
	g_return_if_fail (self != NULL);
	_tmp0_ = unity_greeter_singleton;
	_tmp1_ = _tmp0_->test_mode;
	if (_tmp1_) {
		user_list_test_fill_list (self);
	} else {
		UnityGreeter* _tmp2_ = NULL;
		gchar* _tmp3_ = NULL;
		gchar* _tmp4_ = NULL;
		UnityGreeter* _tmp5_ = NULL;
		gboolean _tmp6_ = FALSE;
		UnityGreeter* _tmp7_ = NULL;
		gboolean _tmp8_ = FALSE;
		UnityGreeter* _tmp18_ = NULL;
		gboolean _tmp19_ = FALSE;
		gboolean _tmp20_ = FALSE;
		gchar* last_user = NULL;
		UnityGreeter* _tmp21_ = NULL;
		gchar* _tmp22_ = NULL;
		UnityGreeter* _tmp23_ = NULL;
		gchar* _tmp24_ = NULL;
		gchar* _tmp25_ = NULL;
		gboolean _tmp26_ = FALSE;
		_tmp2_ = unity_greeter_singleton;
		_tmp3_ = unity_greeter_default_session_hint (_tmp2_);
		_tmp4_ = _tmp3_;
		user_list_set_default_session (self, _tmp4_);
		_g_free0 (_tmp4_);
		_tmp5_ = unity_greeter_singleton;
		_tmp6_ = unity_greeter_show_manual_login_hint (_tmp5_);
		greeter_list_set_always_show_manual ((GreeterList*) self, _tmp6_);
		_tmp7_ = unity_greeter_singleton;
		_tmp8_ = unity_greeter_hide_users_hint (_tmp7_);
		if (!_tmp8_) {
			LightDMUserList* users = NULL;
			LightDMUserList* _tmp9_ = NULL;
			LightDMUserList* _tmp10_ = NULL;
			LightDMUserList* _tmp11_ = NULL;
			LightDMUserList* _tmp12_ = NULL;
			LightDMUserList* _tmp13_ = NULL;
			LightDMUserList* _tmp14_ = NULL;
			GList* _tmp15_ = NULL;
			GList* _tmp16_ = NULL;
			_tmp9_ = lightdm_user_list_get_instance ();
			_tmp10_ = _g_object_ref0 (_tmp9_);
			users = _tmp10_;
			_tmp11_ = users;
			g_signal_connect_object (_tmp11_, "user-added", (GCallback) _user_list_user_added_cb_lightdm_user_list_user_added, self, 0);
			_tmp12_ = users;
			g_signal_connect_object (_tmp12_, "user-changed", (GCallback) _user_list_user_added_cb_lightdm_user_list_user_changed, self, 0);
			_tmp13_ = users;
			g_signal_connect_object (_tmp13_, "user-removed", (GCallback) _user_list_user_removed_cb_lightdm_user_list_user_removed, self, 0);
			_tmp14_ = users;
			_tmp15_ = lightdm_user_list_get_users (_tmp14_);
			_tmp16_ = _tmp15_;
			{
				GList* user_collection = NULL;
				GList* user_it = NULL;
				user_collection = _tmp16_;
				for (user_it = user_collection; user_it != NULL; user_it = user_it->next) {
					LightDMUser* user = NULL;
					user = (LightDMUser*) user_it->data;
					{
						LightDMUser* _tmp17_ = NULL;
						_tmp17_ = user;
						user_list_user_added_cb (self, _tmp17_);
					}
				}
			}
			_g_object_unref0 (users);
		}
		_tmp18_ = unity_greeter_singleton;
		_tmp19_ = unity_greeter_has_guest_account_hint (_tmp18_);
		if (_tmp19_) {
			g_debug ("user-list.vala:1019: Adding guest account entry");
			user_list_set_offer_guest (self, TRUE);
		}
		_tmp20_ = greeter_list_have_entries ((GreeterList*) self);
		if (!_tmp20_) {
			greeter_list_add_manual_entry ((GreeterList*) self);
		}
		_tmp21_ = unity_greeter_singleton;
		_tmp22_ = unity_greeter_get_state (_tmp21_, "last-user");
		last_user = _tmp22_;
		_tmp23_ = unity_greeter_singleton;
		_tmp24_ = unity_greeter_select_user_hint (_tmp23_);
		_tmp25_ = _tmp24_;
		_tmp26_ = _tmp25_ != NULL;
		_g_free0 (_tmp25_);
		if (_tmp26_) {
			UnityGreeter* _tmp27_ = NULL;
			gchar* _tmp28_ = NULL;
			gchar* _tmp29_ = NULL;
			_tmp27_ = unity_greeter_singleton;
			_tmp28_ = unity_greeter_select_user_hint (_tmp27_);
			_tmp29_ = _tmp28_;
			greeter_list_set_active_entry ((GreeterList*) self, _tmp29_);
			_g_free0 (_tmp29_);
		} else {
			const gchar* _tmp30_ = NULL;
			_tmp30_ = last_user;
			if (_tmp30_ != NULL) {
				const gchar* _tmp31_ = NULL;
				_tmp31_ = last_user;
				greeter_list_set_active_entry ((GreeterList*) self, _tmp31_);
			}
		}
		_g_free0 (last_user);
	}
}


static void user_list_user_added_cb (UserList* self, LightDMUser* user) {
	LightDMUser* _tmp0_ = NULL;
	const gchar* _tmp1_ = NULL;
	const gchar* _tmp2_ = NULL;
	LightDMUser* _tmp3_ = NULL;
	const gchar* _tmp4_ = NULL;
	const gchar* _tmp5_ = NULL;
	gboolean _tmp6_ = FALSE;
	gboolean _tmp7_ = FALSE;
	gchar* label = NULL;
	LightDMUser* _tmp16_ = NULL;
	const gchar* _tmp17_ = NULL;
	const gchar* _tmp18_ = NULL;
	gchar* _tmp19_ = NULL;
	LightDMUser* _tmp20_ = NULL;
	const gchar* _tmp21_ = NULL;
	const gchar* _tmp22_ = NULL;
	LightDMUser* _tmp27_ = NULL;
	const gchar* _tmp28_ = NULL;
	const gchar* _tmp29_ = NULL;
	const gchar* _tmp30_ = NULL;
	LightDMUser* _tmp31_ = NULL;
	const gchar* _tmp32_ = NULL;
	const gchar* _tmp33_ = NULL;
	LightDMUser* _tmp34_ = NULL;
	gboolean _tmp35_ = FALSE;
	gboolean _tmp36_ = FALSE;
	LightDMUser* _tmp37_ = NULL;
	gboolean _tmp38_ = FALSE;
	gboolean _tmp39_ = FALSE;
	LightDMUser* _tmp40_ = NULL;
	const gchar* _tmp41_ = NULL;
	const gchar* _tmp42_ = NULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (user != NULL);
	_tmp0_ = user;
	_tmp1_ = lightdm_user_get_name (_tmp0_);
	_tmp2_ = _tmp1_;
	_tmp3_ = user;
	_tmp4_ = lightdm_user_get_real_name (_tmp3_);
	_tmp5_ = _tmp4_;
	g_debug ("user-list.vala:1037: Adding/updating user %s (%s)", _tmp2_, _tmp5_);
	_tmp6_ = user_list_get_show_hidden_users (self);
	_tmp7_ = _tmp6_;
	if (!_tmp7_) {
		gchar** hidden_users = NULL;
		gint _tmp8_ = 0;
		gchar** _tmp9_ = NULL;
		gint hidden_users_length1 = 0;
		gint _hidden_users_size_ = 0;
		gchar** _tmp10_ = NULL;
		gint _tmp10__length1 = 0;
		_tmp9_ = ug_settings_get_strv (UG_SETTINGS_KEY_HIDDEN_USERS, &_tmp8_);
		hidden_users = _tmp9_;
		hidden_users_length1 = _tmp8_;
		_hidden_users_size_ = hidden_users_length1;
		_tmp10_ = hidden_users;
		_tmp10__length1 = hidden_users_length1;
		{
			gchar** username_collection = NULL;
			gint username_collection_length1 = 0;
			gint _username_collection_size_ = 0;
			gint username_it = 0;
			username_collection = _tmp10_;
			username_collection_length1 = _tmp10__length1;
			for (username_it = 0; username_it < _tmp10__length1; username_it = username_it + 1) {
				gchar* _tmp11_ = NULL;
				gchar* username = NULL;
				_tmp11_ = g_strdup (username_collection[username_it]);
				username = _tmp11_;
				{
					const gchar* _tmp12_ = NULL;
					LightDMUser* _tmp13_ = NULL;
					const gchar* _tmp14_ = NULL;
					const gchar* _tmp15_ = NULL;
					_tmp12_ = username;
					_tmp13_ = user;
					_tmp14_ = lightdm_user_get_name (_tmp13_);
					_tmp15_ = _tmp14_;
					if (g_strcmp0 (_tmp12_, _tmp15_) == 0) {
						_g_free0 (username);
						hidden_users = (_vala_array_free (hidden_users, hidden_users_length1, (GDestroyNotify) g_free), NULL);
						return;
					}
					_g_free0 (username);
				}
			}
		}
		hidden_users = (_vala_array_free (hidden_users, hidden_users_length1, (GDestroyNotify) g_free), NULL);
	}
	_tmp16_ = user;
	_tmp17_ = lightdm_user_get_real_name (_tmp16_);
	_tmp18_ = _tmp17_;
	_tmp19_ = g_strdup (_tmp18_);
	label = _tmp19_;
	_tmp20_ = user;
	_tmp21_ = lightdm_user_get_real_name (_tmp20_);
	_tmp22_ = _tmp21_;
	if (g_strcmp0 (_tmp22_, "") == 0) {
		LightDMUser* _tmp23_ = NULL;
		const gchar* _tmp24_ = NULL;
		const gchar* _tmp25_ = NULL;
		gchar* _tmp26_ = NULL;
		_tmp23_ = user;
		_tmp24_ = lightdm_user_get_name (_tmp23_);
		_tmp25_ = _tmp24_;
		_tmp26_ = g_strdup (_tmp25_);
		_g_free0 (label);
		label = _tmp26_;
	}
	_tmp27_ = user;
	_tmp28_ = lightdm_user_get_name (_tmp27_);
	_tmp29_ = _tmp28_;
	_tmp30_ = label;
	_tmp31_ = user;
	_tmp32_ = lightdm_user_get_background (_tmp31_);
	_tmp33_ = _tmp32_;
	_tmp34_ = user;
	_tmp35_ = lightdm_user_get_logged_in (_tmp34_);
	_tmp36_ = _tmp35_;
	_tmp37_ = user;
	_tmp38_ = lightdm_user_get_has_messages (_tmp37_);
	_tmp39_ = _tmp38_;
	_tmp40_ = user;
	_tmp41_ = lightdm_user_get_session (_tmp40_);
	_tmp42_ = _tmp41_;
	user_list_add_user (self, _tmp29_, _tmp30_, _tmp33_, _tmp36_, _tmp39_, _tmp42_);
	_g_free0 (label);
}


static void user_list_user_removed_cb (UserList* self, LightDMUser* user) {
	LightDMUser* _tmp0_ = NULL;
	const gchar* _tmp1_ = NULL;
	const gchar* _tmp2_ = NULL;
	LightDMUser* _tmp3_ = NULL;
	const gchar* _tmp4_ = NULL;
	const gchar* _tmp5_ = NULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (user != NULL);
	_tmp0_ = user;
	_tmp1_ = lightdm_user_get_name (_tmp0_);
	_tmp2_ = _tmp1_;
	g_debug ("user-list.vala:1056: Removing user %s", _tmp2_);
	_tmp3_ = user;
	_tmp4_ = lightdm_user_get_name (_tmp3_);
	_tmp5_ = _tmp4_;
	greeter_list_remove_entry ((GreeterList*) self, _tmp5_);
}


static void user_list_real_show_prompt_cb (GreeterList* base, const gchar* text, LightDMPromptType type) {
	UserList * self;
	PromptBox* _tmp0_ = NULL;
	PromptBox* _tmp1_ = NULL;
	const gchar* _tmp2_ = NULL;
	const gchar* _tmp3_ = NULL;
	gboolean _tmp4_ = FALSE;
	self = (UserList*) base;
	g_return_if_fail (text != NULL);
	_tmp0_ = greeter_list_get_selected_entry ((GreeterList*) self);
	_tmp1_ = _tmp0_;
	_tmp2_ = prompt_box_get_id (_tmp1_);
	_tmp3_ = _tmp2_;
	_tmp4_ = g_str_has_prefix (_tmp3_, "*remote_login");
	if (_tmp4_) {
		const gchar* _tmp5_ = NULL;
		_tmp5_ = text;
		if (g_strcmp0 (_tmp5_, "remote login:") == 0) {
			GtkEntry* field = NULL;
			GHashTable* _tmp6_ = NULL;
			gconstpointer _tmp7_ = NULL;
			GtkWidget* _tmp8_ = NULL;
			GtkEntry* _tmp9_ = NULL;
			const gchar* _tmp10_ = NULL;
			GtkEntry* _tmp11_ = NULL;
			gchar* answer = NULL;
			const gchar* _tmp15_ = NULL;
			gchar* _tmp16_ = NULL;
			UnityGreeter* _tmp17_ = NULL;
			const gchar* _tmp18_ = NULL;
			_tmp6_ = self->priv->current_remote_fields;
			_tmp7_ = g_hash_table_lookup (_tmp6_, "username");
			_tmp8_ = (GtkWidget*) _tmp7_;
			_tmp9_ = _g_object_ref0 (G_TYPE_CHECK_INSTANCE_TYPE (_tmp8_, GTK_TYPE_ENTRY) ? ((GtkEntry*) _tmp8_) : NULL);
			field = _tmp9_;
			_tmp11_ = field;
			if (_tmp11_ != NULL) {
				GtkEntry* _tmp12_ = NULL;
				const gchar* _tmp13_ = NULL;
				const gchar* _tmp14_ = NULL;
				_tmp12_ = field;
				_tmp13_ = gtk_entry_get_text (_tmp12_);
				_tmp14_ = _tmp13_;
				_tmp10_ = _tmp14_;
			} else {
				_tmp10_ = "";
			}
			_tmp15_ = _tmp10_;
			_tmp16_ = g_strdup (_tmp15_);
			answer = _tmp16_;
			_tmp17_ = unity_greeter_singleton;
			_tmp18_ = answer;
			unity_greeter_respond (_tmp17_, _tmp18_);
			_g_free0 (answer);
			_g_object_unref0 (field);
		} else {
			const gchar* _tmp19_ = NULL;
			_tmp19_ = text;
			if (g_strcmp0 (_tmp19_, "password:") == 0) {
				GtkEntry* field = NULL;
				GHashTable* _tmp20_ = NULL;
				gconstpointer _tmp21_ = NULL;
				GtkWidget* _tmp22_ = NULL;
				GtkEntry* _tmp23_ = NULL;
				const gchar* _tmp24_ = NULL;
				GtkEntry* _tmp25_ = NULL;
				gchar* answer = NULL;
				const gchar* _tmp29_ = NULL;
				gchar* _tmp30_ = NULL;
				UnityGreeter* _tmp31_ = NULL;
				const gchar* _tmp32_ = NULL;
				_tmp20_ = self->priv->current_remote_fields;
				_tmp21_ = g_hash_table_lookup (_tmp20_, "password");
				_tmp22_ = (GtkWidget*) _tmp21_;
				_tmp23_ = _g_object_ref0 (G_TYPE_CHECK_INSTANCE_TYPE (_tmp22_, GTK_TYPE_ENTRY) ? ((GtkEntry*) _tmp22_) : NULL);
				field = _tmp23_;
				_tmp25_ = field;
				if (_tmp25_ != NULL) {
					GtkEntry* _tmp26_ = NULL;
					const gchar* _tmp27_ = NULL;
					const gchar* _tmp28_ = NULL;
					_tmp26_ = field;
					_tmp27_ = gtk_entry_get_text (_tmp26_);
					_tmp28_ = _tmp27_;
					_tmp24_ = _tmp28_;
				} else {
					_tmp24_ = "";
				}
				_tmp29_ = _tmp24_;
				_tmp30_ = g_strdup (_tmp29_);
				answer = _tmp30_;
				_tmp31_ = unity_greeter_singleton;
				_tmp32_ = answer;
				unity_greeter_respond (_tmp31_, _tmp32_);
				_g_free0 (answer);
				_g_object_unref0 (field);
			} else {
				const gchar* _tmp33_ = NULL;
				_tmp33_ = text;
				if (g_strcmp0 (_tmp33_, "remote host:") == 0) {
					gchar* answer = NULL;
					PromptBox* _tmp34_ = NULL;
					PromptBox* _tmp35_ = NULL;
					const gchar* _tmp36_ = NULL;
					const gchar* _tmp37_ = NULL;
					gchar* _tmp38_ = NULL;
					UnityGreeter* _tmp39_ = NULL;
					const gchar* _tmp40_ = NULL;
					_tmp34_ = greeter_list_get_selected_entry ((GreeterList*) self);
					_tmp35_ = _tmp34_;
					_tmp36_ = prompt_box_get_id (_tmp35_);
					_tmp37_ = _tmp36_;
					_tmp38_ = user_list_url_from_remote_loding_server_list_name (self, _tmp37_);
					answer = _tmp38_;
					_tmp39_ = unity_greeter_singleton;
					_tmp40_ = answer;
					unity_greeter_respond (_tmp39_, _tmp40_);
					_g_free0 (answer);
				} else {
					const gchar* _tmp41_ = NULL;
					_tmp41_ = text;
					if (g_strcmp0 (_tmp41_, "domain:") == 0) {
						GtkEntry* field = NULL;
						GHashTable* _tmp42_ = NULL;
						gconstpointer _tmp43_ = NULL;
						GtkWidget* _tmp44_ = NULL;
						GtkEntry* _tmp45_ = NULL;
						const gchar* _tmp46_ = NULL;
						GtkEntry* _tmp47_ = NULL;
						gchar* answer = NULL;
						const gchar* _tmp51_ = NULL;
						gchar* _tmp52_ = NULL;
						UnityGreeter* _tmp53_ = NULL;
						const gchar* _tmp54_ = NULL;
						_tmp42_ = self->priv->current_remote_fields;
						_tmp43_ = g_hash_table_lookup (_tmp42_, "domain");
						_tmp44_ = (GtkWidget*) _tmp43_;
						_tmp45_ = _g_object_ref0 (G_TYPE_CHECK_INSTANCE_TYPE (_tmp44_, GTK_TYPE_ENTRY) ? ((GtkEntry*) _tmp44_) : NULL);
						field = _tmp45_;
						_tmp47_ = field;
						if (_tmp47_ != NULL) {
							GtkEntry* _tmp48_ = NULL;
							const gchar* _tmp49_ = NULL;
							const gchar* _tmp50_ = NULL;
							_tmp48_ = field;
							_tmp49_ = gtk_entry_get_text (_tmp48_);
							_tmp50_ = _tmp49_;
							_tmp46_ = _tmp50_;
						} else {
							_tmp46_ = "";
						}
						_tmp51_ = _tmp46_;
						_tmp52_ = g_strdup (_tmp51_);
						answer = _tmp52_;
						_tmp53_ = unity_greeter_singleton;
						_tmp54_ = answer;
						unity_greeter_respond (_tmp53_, _tmp54_);
						_g_free0 (answer);
						_g_object_unref0 (field);
					}
				}
			}
		}
	} else {
		const gchar* _tmp55_ = NULL;
		LightDMPromptType _tmp56_ = 0;
		_tmp55_ = text;
		_tmp56_ = type;
		GREETER_LIST_CLASS (user_list_parent_class)->show_prompt_cb (G_TYPE_CHECK_INSTANCE_CAST (self, TYPE_GREETER_LIST, GreeterList), _tmp55_, _tmp56_);
	}
}


static gboolean _user_list_test_key_press_cb_gtk_widget_key_press_event (GtkWidget* _sender, GdkEventKey* event, gpointer self) {
	gboolean result;
	result = user_list_test_key_press_cb (self, event);
	return result;
}


static void _vala_RemoteServerField_array_free (RemoteServerField* array, gint array_length) {
	if (array != NULL) {
		int i;
		for (i = 0; i < array_length; i = i + 1) {
			remote_server_field_destroy (&array[i]);
		}
	}
	g_free (array);
}


static void _vala_array_add2 (RemoteServer** array, int* length, int* size, const RemoteServer* value) {
	if ((*length) == (*size)) {
		*size = (*size) ? (2 * (*size)) : 4;
		*array = g_renew (RemoteServer, *array, *size);
	}
	(*array)[(*length)++] = *value;
}


static gboolean ___lambda45_ (UserList* self) {
	gboolean result = FALSE;
	RemoteServer* test_server_list = NULL;
	RemoteServer* _tmp0_ = NULL;
	gint test_server_list_length1 = 0;
	gint _test_server_list_size_ = 0;
	RemoteServer remote_server = {0};
	gchar* _tmp1_ = NULL;
	gchar* _tmp2_ = NULL;
	gchar* _tmp3_ = NULL;
	RemoteServerField* _tmp4_ = NULL;
	RemoteServerField field1 = {0};
	gchar* _tmp5_ = NULL;
	RemoteServerField field2 = {0};
	gchar* _tmp6_ = NULL;
	RemoteServerField _tmp7_ = {0};
	RemoteServerField _tmp8_ = {0};
	RemoteServerField _tmp9_ = {0};
	RemoteServerField _tmp10_ = {0};
	RemoteServerField* _tmp11_ = NULL;
	RemoteServer* _tmp12_ = NULL;
	gint _tmp12__length1 = 0;
	RemoteServer _tmp13_ = {0};
	RemoteServer _tmp14_ = {0};
	RemoteServer* _tmp15_ = NULL;
	gint _tmp15__length1 = 0;
	_tmp0_ = g_new0 (RemoteServer, 0);
	test_server_list = _tmp0_;
	test_server_list_length1 = 0;
	_test_server_list_size_ = test_server_list_length1;
	memset (&remote_server, 0, sizeof (RemoteServer));
	_tmp1_ = g_strdup ("uccs");
	_g_free0 (remote_server.type);
	remote_server.type = _tmp1_;
	_tmp2_ = g_strdup ("Remote Login");
	_g_free0 (remote_server.name);
	remote_server.name = _tmp2_;
	_tmp3_ = g_strdup ("http://crazyurl.com");
	_g_free0 (remote_server.url);
	remote_server.url = _tmp3_;
	remote_server.last_used_server = FALSE;
	_tmp4_ = g_new0 (RemoteServerField, 0);
	remote_server.fields = (_vala_RemoteServerField_array_free (remote_server.fields, remote_server.fields_length1), NULL);
	remote_server.fields = _tmp4_;
	remote_server.fields_length1 = 0;
	memset (&field1, 0, sizeof (RemoteServerField));
	_tmp5_ = g_strdup ("email");
	_g_free0 (field1.type);
	field1.type = _tmp5_;
	memset (&field2, 0, sizeof (RemoteServerField));
	_tmp6_ = g_strdup ("password");
	_g_free0 (field2.type);
	field2.type = _tmp6_;
	_tmp7_ = field1;
	remote_server_field_copy (&_tmp7_, &_tmp8_);
	_tmp9_ = field2;
	remote_server_field_copy (&_tmp9_, &_tmp10_);
	_tmp11_ = g_new0 (RemoteServerField, 2);
	_tmp11_[0] = _tmp8_;
	_tmp11_[1] = _tmp10_;
	remote_server.fields = (_vala_RemoteServerField_array_free (remote_server.fields, remote_server.fields_length1), NULL);
	remote_server.fields = _tmp11_;
	remote_server.fields_length1 = 2;
	_tmp12_ = test_server_list;
	_tmp12__length1 = test_server_list_length1;
	_tmp13_ = remote_server;
	remote_server_copy (&_tmp13_, &_tmp14_);
	_vala_array_add2 (&test_server_list, &test_server_list_length1, &_test_server_list_size_, &_tmp14_);
	_tmp15_ = test_server_list;
	_tmp15__length1 = test_server_list_length1;
	user_list_set_remote_directory_servers (self, _tmp15_, _tmp15__length1);
	result = FALSE;
	remote_server_field_destroy (&field2);
	remote_server_field_destroy (&field1);
	remote_server_destroy (&remote_server);
	test_server_list = (_vala_RemoteServer_array_free (test_server_list, test_server_list_length1), NULL);
	return result;
}


static gboolean ____lambda45__gsource_func (gpointer self) {
	gboolean result;
	result = ___lambda45_ (self);
	return result;
}


static void user_list_test_fill_list (UserList* self) {
	UnityGreeter* _tmp7_ = NULL;
	gboolean _tmp8_ = FALSE;
	gint _tmp10_ = 0;
	UnityGreeter* _tmp12_ = NULL;
	gboolean _tmp13_ = FALSE;
	UnityGreeter* _tmp14_ = NULL;
	gboolean _tmp15_ = FALSE;
	UnityGreeter* _tmp16_ = NULL;
	gboolean _tmp17_ = FALSE;
	gchar* last_user = NULL;
	UnityGreeter* _tmp18_ = NULL;
	gchar* _tmp19_ = NULL;
	const gchar* _tmp20_ = NULL;
	GError * _inner_error_ = NULL;
	g_return_if_fail (self != NULL);
	__g_list_free__g_free0_0 (self->priv->test_backgrounds);
	self->priv->test_backgrounds = NULL;
	{
		GDir* dir = NULL;
		GDir* _tmp0_ = NULL;
		_tmp0_ = g_dir_open ("/usr/share/backgrounds/", (guint) 0, &_inner_error_);
		dir = _tmp0_;
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == G_FILE_ERROR) {
				goto __catch43_g_file_error;
			}
			g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return;
		}
		while (TRUE) {
			gchar* bg = NULL;
			GDir* _tmp1_ = NULL;
			const gchar* _tmp2_ = NULL;
			gchar* _tmp3_ = NULL;
			const gchar* _tmp4_ = NULL;
			const gchar* _tmp5_ = NULL;
			gchar* _tmp6_ = NULL;
			_tmp1_ = dir;
			_tmp2_ = g_dir_read_name (_tmp1_);
			_tmp3_ = g_strdup (_tmp2_);
			bg = _tmp3_;
			_tmp4_ = bg;
			if (_tmp4_ == NULL) {
				_g_free0 (bg);
				break;
			}
			_tmp5_ = bg;
			_tmp6_ = g_strconcat ("/usr/share/backgrounds/", _tmp5_, NULL);
			self->priv->test_backgrounds = g_list_append (self->priv->test_backgrounds, _tmp6_);
			_g_free0 (bg);
		}
		_g_dir_close0 (dir);
	}
	goto __finally43;
	__catch43_g_file_error:
	{
		GError* e = NULL;
		e = _inner_error_;
		_inner_error_ = NULL;
		_g_error_free0 (e);
	}
	__finally43:
	if (_inner_error_ != NULL) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return;
	}
	_tmp7_ = unity_greeter_singleton;
	_tmp8_ = unity_greeter_hide_users_hint (_tmp7_);
	if (!_tmp8_) {
		while (TRUE) {
			gboolean _tmp9_ = FALSE;
			_tmp9_ = user_list_add_test_entry (self);
			if (!_tmp9_) {
				break;
			}
		}
	}
	_tmp10_ = self->priv->n_test_entries;
	if (_tmp10_ <= 0) {
		gint _tmp11_ = 0;
		greeter_list_add_manual_entry ((GreeterList*) self);
		greeter_list_set_active_entry ((GreeterList*) self, "*other");
		_tmp11_ = self->priv->n_test_entries;
		self->priv->n_test_entries = _tmp11_ + 1;
	}
	_tmp12_ = unity_greeter_singleton;
	_tmp13_ = unity_greeter_has_guest_account_hint (_tmp12_);
	user_list_set_offer_guest (self, _tmp13_);
	_tmp14_ = unity_greeter_singleton;
	_tmp15_ = unity_greeter_show_manual_login_hint (_tmp14_);
	greeter_list_set_always_show_manual ((GreeterList*) self, _tmp15_);
	g_signal_connect_object ((GtkWidget*) self, "key-press-event", (GCallback) _user_list_test_key_press_cb_gtk_widget_key_press_event, self, 0);
	_tmp16_ = unity_greeter_singleton;
	_tmp17_ = unity_greeter_show_remote_login_hint (_tmp16_);
	if (_tmp17_) {
		g_timeout_add_full (G_PRIORITY_DEFAULT, (guint) 1000, ____lambda45__gsource_func, g_object_ref (self), g_object_unref);
	}
	_tmp18_ = unity_greeter_singleton;
	_tmp19_ = unity_greeter_get_state (_tmp18_, "last-user");
	last_user = _tmp19_;
	_tmp20_ = last_user;
	if (_tmp20_ != NULL) {
		const gchar* _tmp21_ = NULL;
		_tmp21_ = last_user;
		greeter_list_set_active_entry ((GreeterList*) self, _tmp21_);
	}
	_g_free0 (last_user);
}


static void _vala_array_add3 (RemoteServer** array, int* length, int* size, const RemoteServer* value) {
	if ((*length) == (*size)) {
		*size = (*size) ? (2 * (*size)) : 4;
		*array = g_renew (RemoteServer, *array, *size);
	}
	(*array)[(*length)++] = *value;
}


static void user_list_test_call_set_remote_directory_servers (UserList* self) {
	RemoteServer* test_server_list = NULL;
	RemoteServer* _tmp0_ = NULL;
	gint test_server_list_length1 = 0;
	gint _test_server_list_size_ = 0;
	RemoteServer remote_server = {0};
	gchar* _tmp1_ = NULL;
	gchar* _tmp2_ = NULL;
	gchar* _tmp3_ = NULL;
	RemoteServerField* _tmp4_ = NULL;
	RemoteServerField field1 = {0};
	gchar* _tmp5_ = NULL;
	RemoteServerField field2 = {0};
	gchar* _tmp6_ = NULL;
	RemoteServerField _tmp7_ = {0};
	RemoteServerField _tmp8_ = {0};
	RemoteServerField _tmp9_ = {0};
	RemoteServerField _tmp10_ = {0};
	RemoteServerField* _tmp11_ = NULL;
	RemoteServer* _tmp12_ = NULL;
	gint _tmp12__length1 = 0;
	RemoteServer _tmp13_ = {0};
	RemoteServer _tmp14_ = {0};
	RemoteServer* _tmp15_ = NULL;
	gint _tmp15__length1 = 0;
	g_return_if_fail (self != NULL);
	_tmp0_ = g_new0 (RemoteServer, 0);
	test_server_list = _tmp0_;
	test_server_list_length1 = 0;
	_test_server_list_size_ = test_server_list_length1;
	memset (&remote_server, 0, sizeof (RemoteServer));
	_tmp1_ = g_strdup ("uccs");
	_g_free0 (remote_server.type);
	remote_server.type = _tmp1_;
	_tmp2_ = g_strdup ("Corporate Remote Login");
	_g_free0 (remote_server.name);
	remote_server.name = _tmp2_;
	_tmp3_ = g_strdup ("http://internalcompayserver.com");
	_g_free0 (remote_server.url);
	remote_server.url = _tmp3_;
	remote_server.last_used_server = FALSE;
	_tmp4_ = g_new0 (RemoteServerField, 0);
	remote_server.fields = (_vala_RemoteServerField_array_free (remote_server.fields, remote_server.fields_length1), NULL);
	remote_server.fields = _tmp4_;
	remote_server.fields_length1 = 0;
	memset (&field1, 0, sizeof (RemoteServerField));
	_tmp5_ = g_strdup ("email");
	_g_free0 (field1.type);
	field1.type = _tmp5_;
	memset (&field2, 0, sizeof (RemoteServerField));
	_tmp6_ = g_strdup ("password");
	_g_free0 (field2.type);
	field2.type = _tmp6_;
	_tmp7_ = field1;
	remote_server_field_copy (&_tmp7_, &_tmp8_);
	_tmp9_ = field2;
	remote_server_field_copy (&_tmp9_, &_tmp10_);
	_tmp11_ = g_new0 (RemoteServerField, 2);
	_tmp11_[0] = _tmp8_;
	_tmp11_[1] = _tmp10_;
	remote_server.fields = (_vala_RemoteServerField_array_free (remote_server.fields, remote_server.fields_length1), NULL);
	remote_server.fields = _tmp11_;
	remote_server.fields_length1 = 2;
	_tmp12_ = test_server_list;
	_tmp12__length1 = test_server_list_length1;
	_tmp13_ = remote_server;
	remote_server_copy (&_tmp13_, &_tmp14_);
	_vala_array_add3 (&test_server_list, &test_server_list_length1, &_test_server_list_size_, &_tmp14_);
	_tmp15_ = test_server_list;
	_tmp15__length1 = test_server_list_length1;
	user_list_set_remote_directory_servers (self, _tmp15_, _tmp15__length1);
	remote_server_field_destroy (&field2);
	remote_server_field_destroy (&field1);
	remote_server_destroy (&remote_server);
	test_server_list = (_vala_RemoteServer_array_free (test_server_list, test_server_list_length1), NULL);
}


static void user_list_test_call_remote_login_servers_updated (UserList* self) {
	RemoteServer* server_list = NULL;
	RemoteServer* _tmp0_ = NULL;
	gint server_list_length1 = 0;
	gint _server_list_size_ = 0;
	RemoteServer remote_server1 = {0};
	gchar* _tmp1_ = NULL;
	gchar* _tmp2_ = NULL;
	gchar* _tmp3_ = NULL;
	RemoteServerField* _tmp4_ = NULL;
	RemoteServerField field1 = {0};
	gchar* _tmp5_ = NULL;
	RemoteServerField field2 = {0};
	gchar* _tmp6_ = NULL;
	RemoteServerField field3 = {0};
	gchar* _tmp7_ = NULL;
	RemoteServerField _tmp8_ = {0};
	RemoteServerField _tmp9_ = {0};
	RemoteServerField _tmp10_ = {0};
	RemoteServerField _tmp11_ = {0};
	RemoteServerField _tmp12_ = {0};
	RemoteServerField _tmp13_ = {0};
	RemoteServerField* _tmp14_ = NULL;
	RemoteServer remote_server2 = {0};
	gchar* _tmp15_ = NULL;
	gchar* _tmp16_ = NULL;
	gchar* _tmp17_ = NULL;
	RemoteServerField* _tmp18_ = NULL;
	RemoteServerField field21 = {0};
	gchar* _tmp19_ = NULL;
	RemoteServerField field22 = {0};
	gchar* _tmp20_ = NULL;
	RemoteServerField _tmp21_ = {0};
	RemoteServerField _tmp22_ = {0};
	RemoteServerField _tmp23_ = {0};
	RemoteServerField _tmp24_ = {0};
	RemoteServerField* _tmp25_ = NULL;
	gint _tmp26_ = 0;
	RemoteServer _tmp27_ = {0};
	RemoteServer _tmp28_ = {0};
	RemoteServer _tmp29_ = {0};
	RemoteServer _tmp30_ = {0};
	RemoteServer _tmp31_ = {0};
	RemoteServer _tmp32_ = {0};
	const gchar* _tmp33_ = NULL;
	const gchar* _tmp34_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = g_new0 (RemoteServer, 0);
	server_list = _tmp0_;
	server_list_length1 = 0;
	_server_list_size_ = server_list_length1;
	memset (&remote_server1, 0, sizeof (RemoteServer));
	_tmp1_ = g_strdup ("rdp");
	_g_free0 (remote_server1.type);
	remote_server1.type = _tmp1_;
	_tmp2_ = g_strdup ("Cool RDP server");
	_g_free0 (remote_server1.name);
	remote_server1.name = _tmp2_;
	_tmp3_ = g_strdup ("http://coolrdpserver.com");
	_g_free0 (remote_server1.url);
	remote_server1.url = _tmp3_;
	remote_server1.last_used_server = FALSE;
	_tmp4_ = g_new0 (RemoteServerField, 0);
	remote_server1.fields = (_vala_RemoteServerField_array_free (remote_server1.fields, remote_server1.fields_length1), NULL);
	remote_server1.fields = _tmp4_;
	remote_server1.fields_length1 = 0;
	memset (&field1, 0, sizeof (RemoteServerField));
	_tmp5_ = g_strdup ("username");
	_g_free0 (field1.type);
	field1.type = _tmp5_;
	memset (&field2, 0, sizeof (RemoteServerField));
	_tmp6_ = g_strdup ("password");
	_g_free0 (field2.type);
	field2.type = _tmp6_;
	memset (&field3, 0, sizeof (RemoteServerField));
	_tmp7_ = g_strdup ("domain");
	_g_free0 (field3.type);
	field3.type = _tmp7_;
	_tmp8_ = field1;
	remote_server_field_copy (&_tmp8_, &_tmp9_);
	_tmp10_ = field2;
	remote_server_field_copy (&_tmp10_, &_tmp11_);
	_tmp12_ = field3;
	remote_server_field_copy (&_tmp12_, &_tmp13_);
	_tmp14_ = g_new0 (RemoteServerField, 3);
	_tmp14_[0] = _tmp9_;
	_tmp14_[1] = _tmp11_;
	_tmp14_[2] = _tmp13_;
	remote_server1.fields = (_vala_RemoteServerField_array_free (remote_server1.fields, remote_server1.fields_length1), NULL);
	remote_server1.fields = _tmp14_;
	remote_server1.fields_length1 = 3;
	memset (&remote_server2, 0, sizeof (RemoteServer));
	_tmp15_ = g_strdup ("rdp");
	_g_free0 (remote_server2.type);
	remote_server2.type = _tmp15_;
	_tmp16_ = g_strdup ("MegaCool RDP server");
	_g_free0 (remote_server2.name);
	remote_server2.name = _tmp16_;
	_tmp17_ = g_strdup ("http://megacoolrdpserver.com");
	_g_free0 (remote_server2.url);
	remote_server2.url = _tmp17_;
	remote_server2.last_used_server = FALSE;
	_tmp18_ = g_new0 (RemoteServerField, 0);
	remote_server2.fields = (_vala_RemoteServerField_array_free (remote_server2.fields, remote_server2.fields_length1), NULL);
	remote_server2.fields = _tmp18_;
	remote_server2.fields_length1 = 0;
	memset (&field21, 0, sizeof (RemoteServerField));
	_tmp19_ = g_strdup ("username");
	_g_free0 (field21.type);
	field21.type = _tmp19_;
	memset (&field22, 0, sizeof (RemoteServerField));
	_tmp20_ = g_strdup ("password");
	_g_free0 (field22.type);
	field22.type = _tmp20_;
	_tmp21_ = field21;
	remote_server_field_copy (&_tmp21_, &_tmp22_);
	_tmp23_ = field22;
	remote_server_field_copy (&_tmp23_, &_tmp24_);
	_tmp25_ = g_new0 (RemoteServerField, 2);
	_tmp25_[0] = _tmp22_;
	_tmp25_[1] = _tmp24_;
	remote_server2.fields = (_vala_RemoteServerField_array_free (remote_server2.fields, remote_server2.fields_length1), NULL);
	remote_server2.fields = _tmp25_;
	remote_server2.fields_length1 = 2;
	_tmp26_ = 2;
	server_list = g_renew (RemoteServer, server_list, 2);
	(_tmp26_ > server_list_length1) ? memset (server_list + server_list_length1, 0, sizeof (RemoteServer) * (_tmp26_ - server_list_length1)) : NULL;
	server_list_length1 = _tmp26_;
	_server_list_size_ = _tmp26_;
	_tmp27_ = remote_server1;
	remote_server_copy (&_tmp27_, &_tmp28_);
	remote_server_destroy (&server_list[0]);
	server_list[0] = _tmp28_;
	_tmp29_ = server_list[0];
	_tmp30_ = remote_server2;
	remote_server_copy (&_tmp30_, &_tmp31_);
	remote_server_destroy (&server_list[1]);
	server_list[1] = _tmp31_;
	_tmp32_ = server_list[1];
	_tmp33_ = self->priv->currently_browsing_server_url;
	_tmp34_ = self->priv->currently_browsing_server_email;
	user_list_remote_login_servers_updated (self, _tmp33_, _tmp34_, "", server_list, server_list_length1);
	remote_server_field_destroy (&field22);
	remote_server_field_destroy (&field21);
	remote_server_destroy (&remote_server2);
	remote_server_field_destroy (&field3);
	remote_server_field_destroy (&field2);
	remote_server_field_destroy (&field1);
	remote_server_destroy (&remote_server1);
	server_list = (_vala_RemoteServer_array_free (server_list, server_list_length1), NULL);
}


static void _g_variant_unref0_ (gpointer var) {
	(var == NULL) ? NULL : (var = (g_variant_unref (var), NULL));
}


static GVariant* _variant_new1 (gchar** value, gint value_length1) {
	gchar** _tmp34_;
	GVariantBuilder _tmp35_;
	int _tmp36_;
	_tmp34_ = value;
	g_variant_builder_init (&_tmp35_, G_VARIANT_TYPE ("as"));
	for (_tmp36_ = 0; _tmp36_ < value_length1; _tmp36_++) {
		g_variant_builder_add_value (&_tmp35_, g_variant_new_string (*_tmp34_));
		_tmp34_++;
	}
	return g_variant_ref_sink (g_variant_builder_end (&_tmp35_));
}


static GVariant* _variant_new2 (gchar** value, gint value_length1) {
	gchar** _tmp60_;
	GVariantBuilder _tmp61_;
	int _tmp62_;
	_tmp60_ = value;
	g_variant_builder_init (&_tmp61_, G_VARIANT_TYPE ("as"));
	for (_tmp62_ = 0; _tmp62_ < value_length1; _tmp62_++) {
		g_variant_builder_add_value (&_tmp61_, g_variant_new_string (*_tmp60_));
		_tmp60_++;
	}
	return g_variant_ref_sink (g_variant_builder_end (&_tmp61_));
}


static GVariant* _variant_new3 (gboolean value) {
	return g_variant_ref_sink (g_variant_new_boolean (value));
}


static void user_list_test_fill_remote_login_servers (UserList* self, RemoteServer** server_list, int* server_list_length1) {
	RemoteServer* _vala_server_list = NULL;
	int _vala_server_list_length1 = 0;
	gchar** domains = NULL;
	gchar* _tmp0_ = NULL;
	gchar* _tmp1_ = NULL;
	gchar* _tmp2_ = NULL;
	gchar** _tmp3_ = NULL;
	gint domains_length1 = 0;
	gint _domains_size_ = 0;
	RemoteServer* _tmp4_ = NULL;
	RemoteServer remote_server1 = {0};
	gchar* _tmp5_ = NULL;
	gchar* _tmp6_ = NULL;
	gchar* _tmp7_ = NULL;
	RemoteServerField* _tmp8_ = NULL;
	RemoteServerField field1 = {0};
	gchar* _tmp9_ = NULL;
	RemoteServerField field2 = {0};
	gchar* _tmp10_ = NULL;
	RemoteServerField field3 = {0};
	gchar* _tmp11_ = NULL;
	RemoteServerField _tmp12_ = {0};
	RemoteServerField _tmp13_ = {0};
	RemoteServerField _tmp14_ = {0};
	RemoteServerField _tmp15_ = {0};
	RemoteServerField _tmp16_ = {0};
	RemoteServerField _tmp17_ = {0};
	RemoteServerField* _tmp18_ = NULL;
	RemoteServer remote_server2 = {0};
	gchar* _tmp19_ = NULL;
	gchar* _tmp20_ = NULL;
	gchar* _tmp21_ = NULL;
	RemoteServerField* _tmp22_ = NULL;
	RemoteServerField field21 = {0};
	gchar* _tmp23_ = NULL;
	GVariant* _tmp24_ = NULL;
	RemoteServerField field22 = {0};
	gchar* _tmp25_ = NULL;
	RemoteServerField field23 = {0};
	gchar* _tmp26_ = NULL;
	GVariant* _tmp27_ = NULL;
	GHashFunc _tmp28_ = NULL;
	GEqualFunc _tmp29_ = NULL;
	GHashTable* _tmp30_ = NULL;
	RemoteServerField _tmp31_ = {0};
	GHashTable* _tmp32_ = NULL;
	gchar* _tmp33_ = NULL;
	GVariant* _tmp37_ = NULL;
	RemoteServerField _tmp38_ = {0};
	RemoteServerField _tmp39_ = {0};
	RemoteServerField _tmp40_ = {0};
	RemoteServerField _tmp41_ = {0};
	RemoteServerField _tmp42_ = {0};
	RemoteServerField _tmp43_ = {0};
	RemoteServerField* _tmp44_ = NULL;
	RemoteServer remote_server3 = {0};
	gchar* _tmp45_ = NULL;
	gchar* _tmp46_ = NULL;
	gchar* _tmp47_ = NULL;
	RemoteServerField* _tmp48_ = NULL;
	RemoteServerField field31 = {0};
	gchar* _tmp49_ = NULL;
	GVariant* _tmp50_ = NULL;
	RemoteServerField field32 = {0};
	gchar* _tmp51_ = NULL;
	RemoteServerField field33 = {0};
	gchar* _tmp52_ = NULL;
	GVariant* _tmp53_ = NULL;
	GHashFunc _tmp54_ = NULL;
	GEqualFunc _tmp55_ = NULL;
	GHashTable* _tmp56_ = NULL;
	RemoteServerField _tmp57_ = {0};
	GHashTable* _tmp58_ = NULL;
	gchar* _tmp59_ = NULL;
	GVariant* _tmp63_ = NULL;
	RemoteServerField _tmp64_ = {0};
	GHashTable* _tmp65_ = NULL;
	gchar* _tmp66_ = NULL;
	GVariant* _tmp67_ = NULL;
	RemoteServerField _tmp68_ = {0};
	RemoteServerField _tmp69_ = {0};
	RemoteServerField _tmp70_ = {0};
	RemoteServerField _tmp71_ = {0};
	RemoteServerField _tmp72_ = {0};
	RemoteServerField _tmp73_ = {0};
	RemoteServerField* _tmp74_ = NULL;
	RemoteServer remote_server4 = {0};
	gchar* _tmp75_ = NULL;
	gchar* _tmp76_ = NULL;
	gchar* _tmp77_ = NULL;
	RemoteServerField* _tmp78_ = NULL;
	RemoteServerField field41 = {0};
	gchar* _tmp79_ = NULL;
	RemoteServerField field42 = {0};
	gchar* _tmp80_ = NULL;
	RemoteServerField field43 = {0};
	gchar* _tmp81_ = NULL;
	RemoteServerField _tmp82_ = {0};
	RemoteServerField _tmp83_ = {0};
	RemoteServerField _tmp84_ = {0};
	RemoteServerField _tmp85_ = {0};
	RemoteServerField _tmp86_ = {0};
	RemoteServerField _tmp87_ = {0};
	RemoteServerField* _tmp88_ = NULL;
	gint _tmp89_ = 0;
	RemoteServer _tmp90_ = {0};
	RemoteServer _tmp91_ = {0};
	RemoteServer _tmp92_ = {0};
	RemoteServer _tmp93_ = {0};
	RemoteServer _tmp94_ = {0};
	RemoteServer _tmp95_ = {0};
	RemoteServer _tmp96_ = {0};
	RemoteServer _tmp97_ = {0};
	RemoteServer _tmp98_ = {0};
	RemoteServer _tmp99_ = {0};
	RemoteServer _tmp100_ = {0};
	RemoteServer _tmp101_ = {0};
	g_return_if_fail (self != NULL);
	_tmp0_ = g_strdup ("SCANNERS");
	_tmp1_ = g_strdup ("PRINTERS");
	_tmp2_ = g_strdup ("ROUTERS");
	_tmp3_ = g_new0 (gchar*, 3 + 1);
	_tmp3_[0] = _tmp0_;
	_tmp3_[1] = _tmp1_;
	_tmp3_[2] = _tmp2_;
	domains = _tmp3_;
	domains_length1 = 3;
	_domains_size_ = domains_length1;
	_tmp4_ = g_new0 (RemoteServer, 0);
	_vala_server_list = (_vala_RemoteServer_array_free (_vala_server_list, _vala_server_list_length1), NULL);
	_vala_server_list = _tmp4_;
	_vala_server_list_length1 = 0;
	memset (&remote_server1, 0, sizeof (RemoteServer));
	_tmp5_ = g_strdup ("rdp");
	_g_free0 (remote_server1.type);
	remote_server1.type = _tmp5_;
	_tmp6_ = g_strdup ("Cool RDP server");
	_g_free0 (remote_server1.name);
	remote_server1.name = _tmp6_;
	_tmp7_ = g_strdup ("http://coolrdpserver.com");
	_g_free0 (remote_server1.url);
	remote_server1.url = _tmp7_;
	remote_server1.last_used_server = FALSE;
	_tmp8_ = g_new0 (RemoteServerField, 0);
	remote_server1.fields = (_vala_RemoteServerField_array_free (remote_server1.fields, remote_server1.fields_length1), NULL);
	remote_server1.fields = _tmp8_;
	remote_server1.fields_length1 = 0;
	memset (&field1, 0, sizeof (RemoteServerField));
	_tmp9_ = g_strdup ("username");
	_g_free0 (field1.type);
	field1.type = _tmp9_;
	memset (&field2, 0, sizeof (RemoteServerField));
	_tmp10_ = g_strdup ("password");
	_g_free0 (field2.type);
	field2.type = _tmp10_;
	memset (&field3, 0, sizeof (RemoteServerField));
	_tmp11_ = g_strdup ("domain");
	_g_free0 (field3.type);
	field3.type = _tmp11_;
	_tmp12_ = field1;
	remote_server_field_copy (&_tmp12_, &_tmp13_);
	_tmp14_ = field2;
	remote_server_field_copy (&_tmp14_, &_tmp15_);
	_tmp16_ = field3;
	remote_server_field_copy (&_tmp16_, &_tmp17_);
	_tmp18_ = g_new0 (RemoteServerField, 3);
	_tmp18_[0] = _tmp13_;
	_tmp18_[1] = _tmp15_;
	_tmp18_[2] = _tmp17_;
	remote_server1.fields = (_vala_RemoteServerField_array_free (remote_server1.fields, remote_server1.fields_length1), NULL);
	remote_server1.fields = _tmp18_;
	remote_server1.fields_length1 = 3;
	memset (&remote_server2, 0, sizeof (RemoteServer));
	_tmp19_ = g_strdup ("rdp");
	_g_free0 (remote_server2.type);
	remote_server2.type = _tmp19_;
	_tmp20_ = g_strdup ("RDP server with default username, and editable domain");
	_g_free0 (remote_server2.name);
	remote_server2.name = _tmp20_;
	_tmp21_ = g_strdup ("http://rdpdefaultusername.com");
	_g_free0 (remote_server2.url);
	remote_server2.url = _tmp21_;
	remote_server2.last_used_server = FALSE;
	_tmp22_ = g_new0 (RemoteServerField, 0);
	remote_server2.fields = (_vala_RemoteServerField_array_free (remote_server2.fields, remote_server2.fields_length1), NULL);
	remote_server2.fields = _tmp22_;
	remote_server2.fields_length1 = 0;
	memset (&field21, 0, sizeof (RemoteServerField));
	_tmp23_ = g_strdup ("username");
	_g_free0 (field21.type);
	field21.type = _tmp23_;
	_tmp24_ = g_variant_new_string ("alowl");
	g_variant_ref_sink (_tmp24_);
	_g_variant_unref0 (field21.default_value);
	field21.default_value = _tmp24_;
	memset (&field22, 0, sizeof (RemoteServerField));
	_tmp25_ = g_strdup ("password");
	_g_free0 (field22.type);
	field22.type = _tmp25_;
	memset (&field23, 0, sizeof (RemoteServerField));
	_tmp26_ = g_strdup ("domain");
	_g_free0 (field23.type);
	field23.type = _tmp26_;
	_tmp27_ = g_variant_new_string ("PRINTERS");
	g_variant_ref_sink (_tmp27_);
	_g_variant_unref0 (field23.default_value);
	field23.default_value = _tmp27_;
	_tmp28_ = g_str_hash;
	_tmp29_ = g_str_equal;
	_tmp30_ = g_hash_table_new_full (_tmp28_, _tmp29_, _g_free0_, _g_variant_unref0_);
	_g_hash_table_unref0 (field23.properties);
	field23.properties = _tmp30_;
	_tmp31_ = field23;
	_tmp32_ = _tmp31_.properties;
	_tmp33_ = g_strdup ("domains");
	_tmp37_ = _variant_new1 (domains, domains_length1);
	g_hash_table_insert (_tmp32_, _tmp33_, _tmp37_);
	_tmp38_ = field21;
	remote_server_field_copy (&_tmp38_, &_tmp39_);
	_tmp40_ = field22;
	remote_server_field_copy (&_tmp40_, &_tmp41_);
	_tmp42_ = field23;
	remote_server_field_copy (&_tmp42_, &_tmp43_);
	_tmp44_ = g_new0 (RemoteServerField, 3);
	_tmp44_[0] = _tmp39_;
	_tmp44_[1] = _tmp41_;
	_tmp44_[2] = _tmp43_;
	remote_server2.fields = (_vala_RemoteServerField_array_free (remote_server2.fields, remote_server2.fields_length1), NULL);
	remote_server2.fields = _tmp44_;
	remote_server2.fields_length1 = 3;
	memset (&remote_server3, 0, sizeof (RemoteServer));
	_tmp45_ = g_strdup ("rdp");
	_g_free0 (remote_server3.type);
	remote_server3.type = _tmp45_;
	_tmp46_ = g_strdup ("RDP server with default username, and non editable domain");
	_g_free0 (remote_server3.name);
	remote_server3.name = _tmp46_;
	_tmp47_ = g_strdup ("http://rdpdefaultusername2.com");
	_g_free0 (remote_server3.url);
	remote_server3.url = _tmp47_;
	remote_server3.last_used_server = TRUE;
	_tmp48_ = g_new0 (RemoteServerField, 0);
	remote_server3.fields = (_vala_RemoteServerField_array_free (remote_server3.fields, remote_server3.fields_length1), NULL);
	remote_server3.fields = _tmp48_;
	remote_server3.fields_length1 = 0;
	memset (&field31, 0, sizeof (RemoteServerField));
	_tmp49_ = g_strdup ("username");
	_g_free0 (field31.type);
	field31.type = _tmp49_;
	_tmp50_ = g_variant_new_string ("lwola");
	g_variant_ref_sink (_tmp50_);
	_g_variant_unref0 (field31.default_value);
	field31.default_value = _tmp50_;
	memset (&field32, 0, sizeof (RemoteServerField));
	_tmp51_ = g_strdup ("password");
	_g_free0 (field32.type);
	field32.type = _tmp51_;
	memset (&field33, 0, sizeof (RemoteServerField));
	_tmp52_ = g_strdup ("domain");
	_g_free0 (field33.type);
	field33.type = _tmp52_;
	_tmp53_ = g_variant_new_string ("PRINTERS");
	g_variant_ref_sink (_tmp53_);
	_g_variant_unref0 (field33.default_value);
	field33.default_value = _tmp53_;
	_tmp54_ = g_str_hash;
	_tmp55_ = g_str_equal;
	_tmp56_ = g_hash_table_new_full (_tmp54_, _tmp55_, _g_free0_, _g_variant_unref0_);
	_g_hash_table_unref0 (field33.properties);
	field33.properties = _tmp56_;
	_tmp57_ = field33;
	_tmp58_ = _tmp57_.properties;
	_tmp59_ = g_strdup ("domains");
	_tmp63_ = _variant_new2 (domains, domains_length1);
	g_hash_table_insert (_tmp58_, _tmp59_, _tmp63_);
	_tmp64_ = field33;
	_tmp65_ = _tmp64_.properties;
	_tmp66_ = g_strdup ("read-only");
	_tmp67_ = _variant_new3 (TRUE);
	g_hash_table_insert (_tmp65_, _tmp66_, _tmp67_);
	_tmp68_ = field31;
	remote_server_field_copy (&_tmp68_, &_tmp69_);
	_tmp70_ = field32;
	remote_server_field_copy (&_tmp70_, &_tmp71_);
	_tmp72_ = field33;
	remote_server_field_copy (&_tmp72_, &_tmp73_);
	_tmp74_ = g_new0 (RemoteServerField, 3);
	_tmp74_[0] = _tmp69_;
	_tmp74_[1] = _tmp71_;
	_tmp74_[2] = _tmp73_;
	remote_server3.fields = (_vala_RemoteServerField_array_free (remote_server3.fields, remote_server3.fields_length1), NULL);
	remote_server3.fields = _tmp74_;
	remote_server3.fields_length1 = 3;
	memset (&remote_server4, 0, sizeof (RemoteServer));
	_tmp75_ = g_strdup ("notsupported");
	_g_free0 (remote_server4.type);
	remote_server4.type = _tmp75_;
	_tmp76_ = g_strdup ("Not supported server");
	_g_free0 (remote_server4.name);
	remote_server4.name = _tmp76_;
	_tmp77_ = g_strdup ("http://notsupportedserver.com");
	_g_free0 (remote_server4.url);
	remote_server4.url = _tmp77_;
	_tmp78_ = g_new0 (RemoteServerField, 0);
	remote_server4.fields = (_vala_RemoteServerField_array_free (remote_server4.fields, remote_server4.fields_length1), NULL);
	remote_server4.fields = _tmp78_;
	remote_server4.fields_length1 = 0;
	memset (&field41, 0, sizeof (RemoteServerField));
	_tmp79_ = g_strdup ("username");
	_g_free0 (field41.type);
	field41.type = _tmp79_;
	memset (&field42, 0, sizeof (RemoteServerField));
	_tmp80_ = g_strdup ("password");
	_g_free0 (field42.type);
	field42.type = _tmp80_;
	memset (&field43, 0, sizeof (RemoteServerField));
	_tmp81_ = g_strdup ("domain");
	_g_free0 (field43.type);
	field43.type = _tmp81_;
	_tmp82_ = field41;
	remote_server_field_copy (&_tmp82_, &_tmp83_);
	_tmp84_ = field42;
	remote_server_field_copy (&_tmp84_, &_tmp85_);
	_tmp86_ = field43;
	remote_server_field_copy (&_tmp86_, &_tmp87_);
	_tmp88_ = g_new0 (RemoteServerField, 3);
	_tmp88_[0] = _tmp83_;
	_tmp88_[1] = _tmp85_;
	_tmp88_[2] = _tmp87_;
	remote_server4.fields = (_vala_RemoteServerField_array_free (remote_server4.fields, remote_server4.fields_length1), NULL);
	remote_server4.fields = _tmp88_;
	remote_server4.fields_length1 = 3;
	_tmp89_ = 4;
	_vala_server_list = g_renew (RemoteServer, _vala_server_list, 4);
	(_tmp89_ > _vala_server_list_length1) ? memset (_vala_server_list + _vala_server_list_length1, 0, sizeof (RemoteServer) * (_tmp89_ - _vala_server_list_length1)) : NULL;
	_vala_server_list_length1 = _tmp89_;
	_tmp90_ = remote_server1;
	remote_server_copy (&_tmp90_, &_tmp91_);
	remote_server_destroy (&_vala_server_list[0]);
	_vala_server_list[0] = _tmp91_;
	_tmp92_ = _vala_server_list[0];
	_tmp93_ = remote_server2;
	remote_server_copy (&_tmp93_, &_tmp94_);
	remote_server_destroy (&_vala_server_list[1]);
	_vala_server_list[1] = _tmp94_;
	_tmp95_ = _vala_server_list[1];
	_tmp96_ = remote_server3;
	remote_server_copy (&_tmp96_, &_tmp97_);
	remote_server_destroy (&_vala_server_list[2]);
	_vala_server_list[2] = _tmp97_;
	_tmp98_ = _vala_server_list[2];
	_tmp99_ = remote_server4;
	remote_server_copy (&_tmp99_, &_tmp100_);
	remote_server_destroy (&_vala_server_list[3]);
	_vala_server_list[3] = _tmp100_;
	_tmp101_ = _vala_server_list[3];
	remote_server_field_destroy (&field43);
	remote_server_field_destroy (&field42);
	remote_server_field_destroy (&field41);
	remote_server_destroy (&remote_server4);
	remote_server_field_destroy (&field33);
	remote_server_field_destroy (&field32);
	remote_server_field_destroy (&field31);
	remote_server_destroy (&remote_server3);
	remote_server_field_destroy (&field23);
	remote_server_field_destroy (&field22);
	remote_server_field_destroy (&field21);
	remote_server_destroy (&remote_server2);
	remote_server_field_destroy (&field3);
	remote_server_field_destroy (&field2);
	remote_server_field_destroy (&field1);
	remote_server_destroy (&remote_server1);
	domains = (_vala_array_free (domains, domains_length1, (GDestroyNotify) g_free), NULL);
	if (server_list) {
		*server_list = _vala_server_list;
	} else {
		_vala_server_list = (_vala_RemoteServer_array_free (_vala_server_list, _vala_server_list_length1), NULL);
	}
	if (server_list_length1) {
		*server_list_length1 = _vala_server_list_length1;
	}
}


static void user_list_test_fill_remote_login_servers_duplicate_entries (UserList* self, RemoteServer** server_list, int* server_list_length1) {
	RemoteServer* _vala_server_list = NULL;
	int _vala_server_list_length1 = 0;
	RemoteServer* _tmp0_ = NULL;
	RemoteServer remote_server2 = {0};
	gchar* _tmp1_ = NULL;
	gchar* _tmp2_ = NULL;
	gchar* _tmp3_ = NULL;
	RemoteServerField* _tmp4_ = NULL;
	RemoteServerField field21 = {0};
	gchar* _tmp5_ = NULL;
	GVariant* _tmp6_ = NULL;
	RemoteServerField field22 = {0};
	gchar* _tmp7_ = NULL;
	GVariant* _tmp8_ = NULL;
	RemoteServerField field23 = {0};
	gchar* _tmp9_ = NULL;
	GVariant* _tmp10_ = NULL;
	RemoteServerField _tmp11_ = {0};
	RemoteServerField _tmp12_ = {0};
	RemoteServerField _tmp13_ = {0};
	RemoteServerField _tmp14_ = {0};
	RemoteServerField _tmp15_ = {0};
	RemoteServerField _tmp16_ = {0};
	RemoteServerField* _tmp17_ = NULL;
	RemoteServer remote_server5 = {0};
	gchar* _tmp18_ = NULL;
	gchar* _tmp19_ = NULL;
	gchar* _tmp20_ = NULL;
	RemoteServerField* _tmp21_ = NULL;
	RemoteServerField field51 = {0};
	gchar* _tmp22_ = NULL;
	GVariant* _tmp23_ = NULL;
	RemoteServerField field52 = {0};
	gchar* _tmp24_ = NULL;
	GVariant* _tmp25_ = NULL;
	RemoteServerField field53 = {0};
	gchar* _tmp26_ = NULL;
	GVariant* _tmp27_ = NULL;
	RemoteServerField _tmp28_ = {0};
	RemoteServerField _tmp29_ = {0};
	RemoteServerField _tmp30_ = {0};
	RemoteServerField _tmp31_ = {0};
	RemoteServerField _tmp32_ = {0};
	RemoteServerField _tmp33_ = {0};
	RemoteServerField* _tmp34_ = NULL;
	gint _tmp35_ = 0;
	RemoteServer _tmp36_ = {0};
	RemoteServer _tmp37_ = {0};
	RemoteServer _tmp38_ = {0};
	RemoteServer _tmp39_ = {0};
	RemoteServer _tmp40_ = {0};
	RemoteServer _tmp41_ = {0};
	g_return_if_fail (self != NULL);
	_tmp0_ = g_new0 (RemoteServer, 0);
	_vala_server_list = (_vala_RemoteServer_array_free (_vala_server_list, _vala_server_list_length1), NULL);
	_vala_server_list = _tmp0_;
	_vala_server_list_length1 = 0;
	memset (&remote_server2, 0, sizeof (RemoteServer));
	_tmp1_ = g_strdup ("rdp");
	_g_free0 (remote_server2.type);
	remote_server2.type = _tmp1_;
	_tmp2_ = g_strdup ("RDP server with default username, and editable domain");
	_g_free0 (remote_server2.name);
	remote_server2.name = _tmp2_;
	_tmp3_ = g_strdup ("http://rdpdefaultusername.com");
	_g_free0 (remote_server2.url);
	remote_server2.url = _tmp3_;
	remote_server2.last_used_server = FALSE;
	_tmp4_ = g_new0 (RemoteServerField, 0);
	remote_server2.fields = (_vala_RemoteServerField_array_free (remote_server2.fields, remote_server2.fields_length1), NULL);
	remote_server2.fields = _tmp4_;
	remote_server2.fields_length1 = 0;
	memset (&field21, 0, sizeof (RemoteServerField));
	_tmp5_ = g_strdup ("username");
	_g_free0 (field21.type);
	field21.type = _tmp5_;
	_tmp6_ = g_variant_new_string ("alowl1");
	g_variant_ref_sink (_tmp6_);
	_g_variant_unref0 (field21.default_value);
	field21.default_value = _tmp6_;
	memset (&field22, 0, sizeof (RemoteServerField));
	_tmp7_ = g_strdup ("password");
	_g_free0 (field22.type);
	field22.type = _tmp7_;
	_tmp8_ = g_variant_new_string ("duplicate1");
	g_variant_ref_sink (_tmp8_);
	_g_variant_unref0 (field22.default_value);
	field22.default_value = _tmp8_;
	memset (&field23, 0, sizeof (RemoteServerField));
	_tmp9_ = g_strdup ("domain");
	_g_free0 (field23.type);
	field23.type = _tmp9_;
	_tmp10_ = g_variant_new_string ("SCANNERS");
	g_variant_ref_sink (_tmp10_);
	_g_variant_unref0 (field23.default_value);
	field23.default_value = _tmp10_;
	_tmp11_ = field21;
	remote_server_field_copy (&_tmp11_, &_tmp12_);
	_tmp13_ = field22;
	remote_server_field_copy (&_tmp13_, &_tmp14_);
	_tmp15_ = field23;
	remote_server_field_copy (&_tmp15_, &_tmp16_);
	_tmp17_ = g_new0 (RemoteServerField, 3);
	_tmp17_[0] = _tmp12_;
	_tmp17_[1] = _tmp14_;
	_tmp17_[2] = _tmp16_;
	remote_server2.fields = (_vala_RemoteServerField_array_free (remote_server2.fields, remote_server2.fields_length1), NULL);
	remote_server2.fields = _tmp17_;
	remote_server2.fields_length1 = 3;
	memset (&remote_server5, 0, sizeof (RemoteServer));
	_tmp18_ = g_strdup ("rdp");
	_g_free0 (remote_server5.type);
	remote_server5.type = _tmp18_;
	_tmp19_ = g_strdup ("RDP server with default username, and editable domain");
	_g_free0 (remote_server5.name);
	remote_server5.name = _tmp19_;
	_tmp20_ = g_strdup ("http://rdpdefaultusername.com");
	_g_free0 (remote_server5.url);
	remote_server5.url = _tmp20_;
	remote_server5.last_used_server = FALSE;
	_tmp21_ = g_new0 (RemoteServerField, 0);
	remote_server5.fields = (_vala_RemoteServerField_array_free (remote_server5.fields, remote_server5.fields_length1), NULL);
	remote_server5.fields = _tmp21_;
	remote_server5.fields_length1 = 0;
	memset (&field51, 0, sizeof (RemoteServerField));
	_tmp22_ = g_strdup ("username");
	_g_free0 (field51.type);
	field51.type = _tmp22_;
	_tmp23_ = g_variant_new_string ("alowl2");
	g_variant_ref_sink (_tmp23_);
	_g_variant_unref0 (field51.default_value);
	field51.default_value = _tmp23_;
	memset (&field52, 0, sizeof (RemoteServerField));
	_tmp24_ = g_strdup ("password");
	_g_free0 (field52.type);
	field52.type = _tmp24_;
	_tmp25_ = g_variant_new_string ("duplicate2");
	g_variant_ref_sink (_tmp25_);
	_g_variant_unref0 (field52.default_value);
	field52.default_value = _tmp25_;
	memset (&field53, 0, sizeof (RemoteServerField));
	_tmp26_ = g_strdup ("domain");
	_g_free0 (field53.type);
	field53.type = _tmp26_;
	_tmp27_ = g_variant_new_string ("PRINTERS");
	g_variant_ref_sink (_tmp27_);
	_g_variant_unref0 (field53.default_value);
	field53.default_value = _tmp27_;
	_tmp28_ = field51;
	remote_server_field_copy (&_tmp28_, &_tmp29_);
	_tmp30_ = field52;
	remote_server_field_copy (&_tmp30_, &_tmp31_);
	_tmp32_ = field53;
	remote_server_field_copy (&_tmp32_, &_tmp33_);
	_tmp34_ = g_new0 (RemoteServerField, 3);
	_tmp34_[0] = _tmp29_;
	_tmp34_[1] = _tmp31_;
	_tmp34_[2] = _tmp33_;
	remote_server5.fields = (_vala_RemoteServerField_array_free (remote_server5.fields, remote_server5.fields_length1), NULL);
	remote_server5.fields = _tmp34_;
	remote_server5.fields_length1 = 3;
	_tmp35_ = 2;
	_vala_server_list = g_renew (RemoteServer, _vala_server_list, 2);
	(_tmp35_ > _vala_server_list_length1) ? memset (_vala_server_list + _vala_server_list_length1, 0, sizeof (RemoteServer) * (_tmp35_ - _vala_server_list_length1)) : NULL;
	_vala_server_list_length1 = _tmp35_;
	_tmp36_ = remote_server2;
	remote_server_copy (&_tmp36_, &_tmp37_);
	remote_server_destroy (&_vala_server_list[0]);
	_vala_server_list[0] = _tmp37_;
	_tmp38_ = _vala_server_list[0];
	_tmp39_ = remote_server5;
	remote_server_copy (&_tmp39_, &_tmp40_);
	remote_server_destroy (&_vala_server_list[1]);
	_vala_server_list[1] = _tmp40_;
	_tmp41_ = _vala_server_list[1];
	remote_server_field_destroy (&field53);
	remote_server_field_destroy (&field52);
	remote_server_field_destroy (&field51);
	remote_server_destroy (&remote_server5);
	remote_server_field_destroy (&field23);
	remote_server_field_destroy (&field22);
	remote_server_field_destroy (&field21);
	remote_server_destroy (&remote_server2);
	if (server_list) {
		*server_list = _vala_server_list;
	} else {
		_vala_server_list = (_vala_RemoteServer_array_free (_vala_server_list, _vala_server_list_length1), NULL);
	}
	if (server_list_length1) {
		*server_list_length1 = _vala_server_list_length1;
	}
}


static gboolean user_list_test_key_press_cb (UserList* self, GdkEventKey* event) {
	gboolean result = FALSE;
	GdkEventKey _tmp0_ = {0};
	GdkModifierType _tmp1_ = 0;
	GdkEventKey _tmp2_ = {0};
	guint _tmp3_ = 0U;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (event != NULL, FALSE);
	_tmp0_ = *event;
	_tmp1_ = _tmp0_.state;
	if ((_tmp1_ & GDK_CONTROL_MASK) == 0) {
		result = FALSE;
		return result;
	}
	_tmp2_ = *event;
	_tmp3_ = _tmp2_.keyval;
	switch (_tmp3_) {
		case GDK_KEY_plus:
		{
			user_list_add_test_entry (self);
			break;
		}
		case GDK_KEY_minus:
		{
			user_list_remove_test_entry (self);
			break;
		}
		case GDK_KEY_0:
		{
			while (TRUE) {
				gboolean _tmp4_ = FALSE;
				_tmp4_ = user_list_remove_test_entry (self);
				if (!_tmp4_) {
					break;
				}
			}
			user_list_set_offer_guest (self, FALSE);
			break;
		}
		case GDK_KEY_equal:
		{
			while (TRUE) {
				gboolean _tmp5_ = FALSE;
				_tmp5_ = user_list_add_test_entry (self);
				if (!_tmp5_) {
					break;
				}
			}
			user_list_set_offer_guest (self, TRUE);
			break;
		}
		case GDK_KEY_g:
		{
			user_list_set_offer_guest (self, FALSE);
			break;
		}
		case GDK_KEY_G:
		{
			user_list_set_offer_guest (self, TRUE);
			break;
		}
		case GDK_KEY_m:
		{
			greeter_list_set_always_show_manual ((GreeterList*) self, FALSE);
			break;
		}
		case GDK_KEY_M:
		{
			greeter_list_set_always_show_manual ((GreeterList*) self, TRUE);
			break;
		}
		default:
		break;
	}
	result = FALSE;
	return result;
}


static gboolean user_list_add_test_entry (UserList* self) {
	gboolean result = FALSE;
	UserListTestEntry e = {0};
	gint _tmp0_ = 0;
	UserListTestEntry _tmp1_ = {0};
	UserListTestEntry _tmp2_ = {0};
	UserListTestEntry _tmp3_ = {0};
	const gchar* _tmp4_ = NULL;
	gchar* background = NULL;
	UserListTestEntry _tmp5_ = {0};
	const gchar* _tmp6_ = NULL;
	gchar* _tmp7_ = NULL;
	const gchar* _tmp8_ = NULL;
	UserListTestEntry _tmp26_ = {0};
	const gchar* _tmp27_ = NULL;
	UserListTestEntry _tmp28_ = {0};
	const gchar* _tmp29_ = NULL;
	const gchar* _tmp30_ = NULL;
	UserListTestEntry _tmp31_ = {0};
	gboolean _tmp32_ = FALSE;
	UserListTestEntry _tmp33_ = {0};
	gboolean _tmp34_ = FALSE;
	UserListTestEntry _tmp35_ = {0};
	const gchar* _tmp36_ = NULL;
	gint _tmp37_ = 0;
	g_return_val_if_fail (self != NULL, FALSE);
	_tmp0_ = self->priv->n_test_entries;
	_tmp1_ = USER_LIST_test_entries[_tmp0_];
	user_list_test_entry_copy (&_tmp1_, &_tmp2_);
	e = _tmp2_;
	_tmp3_ = e;
	_tmp4_ = _tmp3_.username;
	if (g_strcmp0 (_tmp4_, "") == 0) {
		result = FALSE;
		user_list_test_entry_destroy (&e);
		return result;
	}
	_tmp5_ = e;
	_tmp6_ = _tmp5_.background;
	_tmp7_ = g_strdup (_tmp6_);
	background = _tmp7_;
	_tmp8_ = background;
	if (g_strcmp0 (_tmp8_, "*") == 0) {
		gint background_index = 0;
		GList* _tmp18_ = NULL;
		guint _tmp19_ = 0U;
		background_index = 0;
		{
			gint i = 0;
			i = 0;
			{
				gboolean _tmp9_ = FALSE;
				_tmp9_ = TRUE;
				while (TRUE) {
					gboolean _tmp10_ = FALSE;
					gint _tmp12_ = 0;
					gint _tmp13_ = 0;
					gint _tmp14_ = 0;
					UserListTestEntry _tmp15_ = {0};
					const gchar* _tmp16_ = NULL;
					_tmp10_ = _tmp9_;
					if (!_tmp10_) {
						gint _tmp11_ = 0;
						_tmp11_ = i;
						i = _tmp11_ + 1;
					}
					_tmp9_ = FALSE;
					_tmp12_ = i;
					_tmp13_ = self->priv->n_test_entries;
					if (!(_tmp12_ < _tmp13_)) {
						break;
					}
					_tmp14_ = i;
					_tmp15_ = USER_LIST_test_entries[_tmp14_];
					_tmp16_ = _tmp15_.background;
					if (g_strcmp0 (_tmp16_, "*") == 0) {
						gint _tmp17_ = 0;
						_tmp17_ = background_index;
						background_index = _tmp17_ + 1;
					}
				}
			}
		}
		_tmp18_ = self->priv->test_backgrounds;
		_tmp19_ = g_list_length (_tmp18_);
		if (_tmp19_ > ((guint) 0)) {
			GList* _tmp20_ = NULL;
			gint _tmp21_ = 0;
			GList* _tmp22_ = NULL;
			guint _tmp23_ = 0U;
			gconstpointer _tmp24_ = NULL;
			gchar* _tmp25_ = NULL;
			_tmp20_ = self->priv->test_backgrounds;
			_tmp21_ = background_index;
			_tmp22_ = self->priv->test_backgrounds;
			_tmp23_ = g_list_length (_tmp22_);
			_tmp24_ = g_list_nth_data (_tmp20_, _tmp21_ % _tmp23_);
			_tmp25_ = g_strdup ((const gchar*) _tmp24_);
			_g_free0 (background);
			background = _tmp25_;
		}
	}
	_tmp26_ = e;
	_tmp27_ = _tmp26_.username;
	_tmp28_ = e;
	_tmp29_ = _tmp28_.real_name;
	_tmp30_ = background;
	_tmp31_ = e;
	_tmp32_ = _tmp31_.is_active;
	_tmp33_ = e;
	_tmp34_ = _tmp33_.has_messages;
	_tmp35_ = e;
	_tmp36_ = _tmp35_.session;
	user_list_add_user (self, _tmp27_, _tmp29_, _tmp30_, _tmp32_, _tmp34_, _tmp36_);
	_tmp37_ = self->priv->n_test_entries;
	self->priv->n_test_entries = _tmp37_ + 1;
	result = TRUE;
	_g_free0 (background);
	user_list_test_entry_destroy (&e);
	return result;
}


static gboolean user_list_remove_test_entry (UserList* self) {
	gboolean result = FALSE;
	gint _tmp0_ = 0;
	gint _tmp1_ = 0;
	UserListTestEntry _tmp2_ = {0};
	const gchar* _tmp3_ = NULL;
	gint _tmp4_ = 0;
	g_return_val_if_fail (self != NULL, FALSE);
	_tmp0_ = self->priv->n_test_entries;
	if (_tmp0_ == 0) {
		result = FALSE;
		return result;
	}
	_tmp1_ = self->priv->n_test_entries;
	_tmp2_ = USER_LIST_test_entries[_tmp1_ - 1];
	_tmp3_ = _tmp2_.username;
	greeter_list_remove_entry ((GreeterList*) self, _tmp3_);
	_tmp4_ = self->priv->n_test_entries;
	self->priv->n_test_entries = _tmp4_ - 1;
	result = TRUE;
	return result;
}


static void user_list_test_respond (UserList* self, const gchar* text) {
	const gchar* _tmp0_ = NULL;
	gchar* _tmp1_ = NULL;
	gchar* _tmp2_ = NULL;
	GQuark _tmp4_ = 0U;
	static GQuark _tmp3_label0 = 0;
	static GQuark _tmp3_label1 = 0;
	static GQuark _tmp3_label2 = 0;
	static GQuark _tmp3_label3 = 0;
	static GQuark _tmp3_label4 = 0;
	static GQuark _tmp3_label5 = 0;
	static GQuark _tmp3_label6 = 0;
	g_return_if_fail (self != NULL);
	g_return_if_fail (text != NULL);
	_tmp0_ = text;
	g_debug ("user-list.vala:1454: response %s", _tmp0_);
	_tmp1_ = greeter_list_get_selected_id ((GreeterList*) self);
	_tmp2_ = _tmp1_;
	_tmp4_ = (NULL == _tmp2_) ? 0 : g_quark_from_string (_tmp2_);
	g_free (_tmp2_);
	if (_tmp4_ == ((0 != _tmp3_label0) ? _tmp3_label0 : (_tmp3_label0 = g_quark_from_static_string ("*other")))) {
		switch (0) {
			default:
			{
				const gchar* _tmp5_ = NULL;
				_tmp5_ = ((GreeterList*) self)->test_username;
				if (_tmp5_ == NULL) {
					const gchar* _tmp6_ = NULL;
					const gchar* _tmp7_ = NULL;
					gchar* _tmp8_ = NULL;
					_tmp6_ = text;
					g_debug ("user-list.vala:1460: username=%s", _tmp6_);
					_tmp7_ = text;
					_tmp8_ = g_strdup (_tmp7_);
					_g_free0 (((GreeterList*) self)->test_username);
					((GreeterList*) self)->test_username = _tmp8_;
					greeter_list_show_prompt_cb ((GreeterList*) self, "Password:", LIGHTDM_PROMPT_TYPE_SECRET);
				} else {
					const gchar* _tmp9_ = NULL;
					_tmp9_ = text;
					((GreeterList*) self)->test_is_authenticated = g_strcmp0 (_tmp9_, "password") == 0;
					greeter_list_authentication_complete_cb ((GreeterList*) self);
				}
				break;
			}
		}
	} else if (_tmp4_ == ((0 != _tmp3_label1) ? _tmp3_label1 : (_tmp3_label1 = g_quark_from_static_string ("two-factor")))) {
		switch (0) {
			default:
			{
				gboolean _tmp10_ = FALSE;
				_tmp10_ = self->priv->test_prompted_sso;
				if (!_tmp10_) {
					const gchar* _tmp11_ = NULL;
					_tmp11_ = text;
					if (g_strcmp0 (_tmp11_, "password") == 0) {
						g_debug ("user-list.vala:1475: prompt otp");
						self->priv->test_prompted_sso = TRUE;
						greeter_list_show_prompt_cb ((GreeterList*) self, "OTP:", LIGHTDM_PROMPT_TYPE_QUESTION);
					} else {
						((GreeterList*) self)->test_is_authenticated = FALSE;
						greeter_list_authentication_complete_cb ((GreeterList*) self);
					}
				} else {
					const gchar* _tmp12_ = NULL;
					_tmp12_ = text;
					((GreeterList*) self)->test_is_authenticated = g_strcmp0 (_tmp12_, "otp") == 0;
					greeter_list_authentication_complete_cb ((GreeterList*) self);
				}
				break;
			}
		}
	} else if (_tmp4_ == ((0 != _tmp3_label2) ? _tmp3_label2 : (_tmp3_label2 = g_quark_from_static_string ("two-prompts")))) {
		switch (0) {
			default:
			{
				const gchar* _tmp13_ = NULL;
				_tmp13_ = self->priv->test_two_prompts_first;
				if (_tmp13_ == NULL) {
					const gchar* _tmp14_ = NULL;
					gchar* _tmp15_ = NULL;
					_tmp14_ = text;
					_tmp15_ = g_strdup (_tmp14_);
					_g_free0 (self->priv->test_two_prompts_first);
					self->priv->test_two_prompts_first = _tmp15_;
				} else {
					gboolean _tmp16_ = FALSE;
					const gchar* _tmp17_ = NULL;
					gboolean _tmp19_ = FALSE;
					_tmp17_ = self->priv->test_two_prompts_first;
					if (g_strcmp0 (_tmp17_, "blue") == 0) {
						const gchar* _tmp18_ = NULL;
						_tmp18_ = text;
						_tmp16_ = g_strcmp0 (_tmp18_, "password") == 0;
					} else {
						_tmp16_ = FALSE;
					}
					_tmp19_ = _tmp16_;
					((GreeterList*) self)->test_is_authenticated = _tmp19_;
					greeter_list_authentication_complete_cb ((GreeterList*) self);
				}
				break;
			}
		}
	} else if (_tmp4_ == ((0 != _tmp3_label3) ? _tmp3_label3 : (_tmp3_label3 = g_quark_from_static_string ("change-password")))) {
		switch (0) {
			default:
			{
				const gchar* _tmp20_ = NULL;
				_tmp20_ = self->priv->test_new_password;
				if (_tmp20_ != NULL) {
					const gchar* _tmp21_ = NULL;
					const gchar* _tmp22_ = NULL;
					_tmp21_ = text;
					_tmp22_ = self->priv->test_new_password;
					((GreeterList*) self)->test_is_authenticated = g_strcmp0 (_tmp21_, _tmp22_) == 0;
					greeter_list_authentication_complete_cb ((GreeterList*) self);
				} else {
					gboolean _tmp23_ = FALSE;
					_tmp23_ = self->priv->test_request_new_password;
					if (_tmp23_) {
						const gchar* _tmp24_ = NULL;
						gchar* _tmp25_ = NULL;
						_tmp24_ = text;
						_tmp25_ = g_strdup (_tmp24_);
						_g_free0 (self->priv->test_new_password);
						self->priv->test_new_password = _tmp25_;
						greeter_list_show_prompt_cb ((GreeterList*) self, "Retype new UNIX password: ", LIGHTDM_PROMPT_TYPE_SECRET);
					} else {
						const gchar* _tmp26_ = NULL;
						_tmp26_ = text;
						if (g_strcmp0 (_tmp26_, "password") != 0) {
							((GreeterList*) self)->test_is_authenticated = FALSE;
							greeter_list_authentication_complete_cb ((GreeterList*) self);
						} else {
							self->priv->test_request_new_password = TRUE;
							greeter_list_show_message_cb ((GreeterList*) self, "You are required to change your password immediately (root enforced)", LIGHTDM_MESSAGE_TYPE_ERROR);
							greeter_list_show_prompt_cb ((GreeterList*) self, "Enter new UNIX password: ", LIGHTDM_PROMPT_TYPE_SECRET);
						}
					}
				}
				break;
			}
		}
	} else if (_tmp4_ == ((0 != _tmp3_label4) ? _tmp3_label4 : (_tmp3_label4 = g_quark_from_static_string ("no-response")))) {
		switch (0) {
			default:
			{
				break;
			}
		}
	} else if (_tmp4_ == ((0 != _tmp3_label5) ? _tmp3_label5 : (_tmp3_label5 = g_quark_from_static_string ("locked")))) {
		switch (0) {
			default:
			{
				((GreeterList*) self)->test_is_authenticated = FALSE;
				greeter_list_show_message_cb ((GreeterList*) self, "Account is locked", LIGHTDM_MESSAGE_TYPE_ERROR);
				greeter_list_authentication_complete_cb ((GreeterList*) self);
				break;
			}
		}
	} else if (_tmp4_ == ((0 != _tmp3_label6) ? _tmp3_label6 : (_tmp3_label6 = g_quark_from_static_string ("messages-after-login")))) {
		switch (0) {
			default:
			{
				const gchar* _tmp27_ = NULL;
				gboolean _tmp28_ = FALSE;
				_tmp27_ = text;
				((GreeterList*) self)->test_is_authenticated = g_strcmp0 (_tmp27_, "password") == 0;
				_tmp28_ = ((GreeterList*) self)->test_is_authenticated;
				if (_tmp28_) {
					greeter_list_show_message_cb ((GreeterList*) self, "Congratulations on logging in!", LIGHTDM_MESSAGE_TYPE_INFO);
				}
				greeter_list_authentication_complete_cb ((GreeterList*) self);
				break;
			}
		}
	} else {
		switch (0) {
			default:
			{
				const gchar* _tmp29_ = NULL;
				_tmp29_ = text;
				((GreeterList*) self)->test_is_authenticated = g_strcmp0 (_tmp29_, "password") == 0;
				greeter_list_authentication_complete_cb ((GreeterList*) self);
				break;
			}
		}
	}
}


static void user_list_real_test_start_authentication (GreeterList* base) {
	UserList * self;
	gchar* _tmp0_ = NULL;
	gchar* _tmp1_ = NULL;
	GQuark _tmp3_ = 0U;
	static GQuark _tmp2_label0 = 0;
	static GQuark _tmp2_label1 = 0;
	static GQuark _tmp2_label2 = 0;
	static GQuark _tmp2_label3 = 0;
	static GQuark _tmp2_label4 = 0;
	static GQuark _tmp2_label5 = 0;
	static GQuark _tmp2_label6 = 0;
	static GQuark _tmp2_label7 = 0;
	static GQuark _tmp2_label8 = 0;
	static GQuark _tmp2_label9 = 0;
	self = (UserList*) base;
	_g_free0 (((GreeterList*) self)->test_username);
	((GreeterList*) self)->test_username = NULL;
	((GreeterList*) self)->test_is_authenticated = FALSE;
	self->priv->test_prompted_sso = FALSE;
	_g_free0 (self->priv->test_two_prompts_first);
	self->priv->test_two_prompts_first = NULL;
	self->priv->test_request_new_password = FALSE;
	_g_free0 (self->priv->test_new_password);
	self->priv->test_new_password = NULL;
	_tmp0_ = greeter_list_get_selected_id ((GreeterList*) self);
	_tmp1_ = _tmp0_;
	_tmp3_ = (NULL == _tmp1_) ? 0 : g_quark_from_string (_tmp1_);
	g_free (_tmp1_);
	if (_tmp3_ == ((0 != _tmp2_label0) ? _tmp2_label0 : (_tmp2_label0 = g_quark_from_static_string ("*other")))) {
		switch (0) {
			default:
			{
				const gchar* _tmp4_ = NULL;
				_tmp4_ = self->priv->authenticate_user;
				if (_tmp4_ != NULL) {
					const gchar* _tmp5_ = NULL;
					gchar* _tmp6_ = NULL;
					_tmp5_ = self->priv->authenticate_user;
					_tmp6_ = g_strdup (_tmp5_);
					_g_free0 (((GreeterList*) self)->test_username);
					((GreeterList*) self)->test_username = _tmp6_;
					_g_free0 (self->priv->authenticate_user);
					self->priv->authenticate_user = NULL;
					greeter_list_show_prompt_cb ((GreeterList*) self, "Password:", LIGHTDM_PROMPT_TYPE_SECRET);
				} else {
					greeter_list_show_prompt_cb ((GreeterList*) self, "Username:", LIGHTDM_PROMPT_TYPE_QUESTION);
				}
				break;
			}
		}
	} else if (_tmp3_ == ((0 != _tmp2_label1) ? _tmp2_label1 : (_tmp2_label1 = g_quark_from_static_string ("*guest")))) {
		switch (0) {
			default:
			{
				((GreeterList*) self)->test_is_authenticated = TRUE;
				greeter_list_authentication_complete_cb ((GreeterList*) self);
				break;
			}
		}
	} else if (_tmp3_ == ((0 != _tmp2_label2) ? _tmp2_label2 : (_tmp2_label2 = g_quark_from_static_string ("different-prompt")))) {
		switch (0) {
			default:
			{
				greeter_list_show_prompt_cb ((GreeterList*) self, "Secret word", LIGHTDM_PROMPT_TYPE_SECRET);
				break;
			}
		}
	} else if (_tmp3_ == ((0 != _tmp2_label3) ? _tmp2_label3 : (_tmp2_label3 = g_quark_from_static_string ("no-password")))) {
		switch (0) {
			default:
			{
				((GreeterList*) self)->test_is_authenticated = TRUE;
				greeter_list_authentication_complete_cb ((GreeterList*) self);
				break;
			}
		}
	} else if (_tmp3_ == ((0 != _tmp2_label4) ? _tmp2_label4 : (_tmp2_label4 = g_quark_from_static_string ("auth-error")))) {
		switch (0) {
			default:
			{
				greeter_list_show_message_cb ((GreeterList*) self, "Authentication Error", LIGHTDM_MESSAGE_TYPE_ERROR);
				((GreeterList*) self)->test_is_authenticated = FALSE;
				greeter_list_authentication_complete_cb ((GreeterList*) self);
				break;
			}
		}
	} else if (_tmp3_ == ((0 != _tmp2_label5) ? _tmp2_label5 : (_tmp2_label5 = g_quark_from_static_string ("info-prompt")))) {
		switch (0) {
			default:
			{
				greeter_list_show_message_cb ((GreeterList*) self, "Welcome to Unity Greeter", LIGHTDM_MESSAGE_TYPE_INFO);
				greeter_list_show_prompt_cb ((GreeterList*) self, "Password:", LIGHTDM_PROMPT_TYPE_SECRET);
				break;
			}
		}
	} else if (_tmp3_ == ((0 != _tmp2_label6) ? _tmp2_label6 : (_tmp2_label6 = g_quark_from_static_string ("long-info-prompt")))) {
		switch (0) {
			default:
			{
				greeter_list_show_message_cb ((GreeterList*) self, "Welcome to Unity Greeter\n" \
"\n" \
"We like to annoy you with long messages.\n" \
"Like this one\n" \
"\n" \
"This is the last line of a multiple line message.", LIGHTDM_MESSAGE_TYPE_INFO);
				greeter_list_show_prompt_cb ((GreeterList*) self, "Password:", LIGHTDM_PROMPT_TYPE_SECRET);
				break;
			}
		}
	} else if (_tmp3_ == ((0 != _tmp2_label7) ? _tmp2_label7 : (_tmp2_label7 = g_quark_from_static_string ("wide-info-prompt")))) {
		switch (0) {
			default:
			{
				greeter_list_show_message_cb ((GreeterList*) self, "Welcome to Unity Greeter, the greeteriest greeter that ever did appear" \
" in these fine lands", LIGHTDM_MESSAGE_TYPE_INFO);
				greeter_list_show_prompt_cb ((GreeterList*) self, "Password:", LIGHTDM_PROMPT_TYPE_SECRET);
				break;
			}
		}
	} else if (_tmp3_ == ((0 != _tmp2_label8) ? _tmp2_label8 : (_tmp2_label8 = g_quark_from_static_string ("multi-info-prompt")))) {
		switch (0) {
			default:
			{
				greeter_list_show_message_cb ((GreeterList*) self, "Welcome to Unity Greeter", LIGHTDM_MESSAGE_TYPE_INFO);
				greeter_list_show_message_cb ((GreeterList*) self, "This is an error", LIGHTDM_MESSAGE_TYPE_ERROR);
				greeter_list_show_message_cb ((GreeterList*) self, "You should have seen three messages", LIGHTDM_MESSAGE_TYPE_INFO);
				greeter_list_show_prompt_cb ((GreeterList*) self, "Password:", LIGHTDM_PROMPT_TYPE_SECRET);
				break;
			}
		}
	} else if (_tmp3_ == ((0 != _tmp2_label9) ? _tmp2_label9 : (_tmp2_label9 = g_quark_from_static_string ("two-prompts")))) {
		switch (0) {
			default:
			{
				greeter_list_show_prompt_cb ((GreeterList*) self, "Favorite Color (blue):", LIGHTDM_PROMPT_TYPE_QUESTION);
				greeter_list_show_prompt_cb ((GreeterList*) self, "Password:", LIGHTDM_PROMPT_TYPE_SECRET);
				break;
			}
		}
	} else {
		switch (0) {
			default:
			{
				greeter_list_show_prompt_cb ((GreeterList*) self, "Password:", LIGHTDM_PROMPT_TYPE_SECRET);
				break;
			}
		}
	}
}


gboolean user_list_get_offer_guest (UserList* self) {
	gboolean result;
	gboolean _tmp0_ = FALSE;
	g_return_val_if_fail (self != NULL, FALSE);
	_tmp0_ = self->priv->_offer_guest;
	result = _tmp0_;
	return result;
}


void user_list_set_offer_guest (UserList* self, gboolean value) {
	gboolean _tmp0_ = FALSE;
	gboolean _tmp1_ = FALSE;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	self->priv->_offer_guest = _tmp0_;
	_tmp1_ = value;
	if (_tmp1_) {
		const gchar* _tmp2_ = NULL;
		_tmp2_ = _ ("Guest Session");
		user_list_add_user (self, "*guest", _tmp2_, NULL, FALSE, FALSE, NULL);
	} else {
		greeter_list_remove_entry ((GreeterList*) self, "*guest");
	}
	g_object_notify ((GObject *) self, "offer-guest");
}


gboolean user_list_get_show_hidden_users (UserList* self) {
	gboolean result;
	gboolean _tmp0_ = FALSE;
	g_return_val_if_fail (self != NULL, FALSE);
	_tmp0_ = self->priv->show_hidden_users_;
	result = _tmp0_;
	return result;
}


void user_list_set_show_hidden_users (UserList* self, gboolean value) {
	gboolean _tmp0_ = FALSE;
	UnityGreeter* _tmp1_ = NULL;
	gboolean _tmp2_ = FALSE;
	gchar** hidden_users = NULL;
	gint _tmp4_ = 0;
	gchar** _tmp5_ = NULL;
	gint hidden_users_length1 = 0;
	gint _hidden_users_size_ = 0;
	gboolean _tmp6_ = FALSE;
	LightDMUserList* users = NULL;
	LightDMUserList* _tmp10_ = NULL;
	LightDMUserList* _tmp11_ = NULL;
	LightDMUserList* _tmp12_ = NULL;
	GList* _tmp13_ = NULL;
	GList* _tmp14_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	self->priv->show_hidden_users_ = _tmp0_;
	_tmp1_ = unity_greeter_singleton;
	_tmp2_ = _tmp1_->test_mode;
	if (_tmp2_) {
		gboolean _tmp3_ = FALSE;
		_tmp3_ = value;
		if (_tmp3_) {
			user_list_add_user (self, "hidden", "Hidden User", NULL, FALSE, FALSE, NULL);
		} else {
			greeter_list_remove_entry ((GreeterList*) self, "hidden");
		}
		return;
	}
	_tmp5_ = ug_settings_get_strv (UG_SETTINGS_KEY_HIDDEN_USERS, &_tmp4_);
	hidden_users = _tmp5_;
	hidden_users_length1 = _tmp4_;
	_hidden_users_size_ = hidden_users_length1;
	_tmp6_ = value;
	if (!_tmp6_) {
		gchar** _tmp7_ = NULL;
		gint _tmp7__length1 = 0;
		_tmp7_ = hidden_users;
		_tmp7__length1 = hidden_users_length1;
		{
			gchar** username_collection = NULL;
			gint username_collection_length1 = 0;
			gint _username_collection_size_ = 0;
			gint username_it = 0;
			username_collection = _tmp7_;
			username_collection_length1 = _tmp7__length1;
			for (username_it = 0; username_it < _tmp7__length1; username_it = username_it + 1) {
				gchar* _tmp8_ = NULL;
				gchar* username = NULL;
				_tmp8_ = g_strdup (username_collection[username_it]);
				username = _tmp8_;
				{
					const gchar* _tmp9_ = NULL;
					_tmp9_ = username;
					greeter_list_remove_entry ((GreeterList*) self, _tmp9_);
					_g_free0 (username);
				}
			}
		}
		hidden_users = (_vala_array_free (hidden_users, hidden_users_length1, (GDestroyNotify) g_free), NULL);
		return;
	}
	_tmp10_ = lightdm_user_list_get_instance ();
	_tmp11_ = _g_object_ref0 (_tmp10_);
	users = _tmp11_;
	_tmp12_ = users;
	_tmp13_ = lightdm_user_list_get_users (_tmp12_);
	_tmp14_ = _tmp13_;
	{
		GList* user_collection = NULL;
		GList* user_it = NULL;
		user_collection = _tmp14_;
		for (user_it = user_collection; user_it != NULL; user_it = user_it->next) {
			LightDMUser* user = NULL;
			user = (LightDMUser*) user_it->data;
			{
				gchar** _tmp15_ = NULL;
				gint _tmp15__length1 = 0;
				_tmp15_ = hidden_users;
				_tmp15__length1 = hidden_users_length1;
				{
					gchar** username_collection = NULL;
					gint username_collection_length1 = 0;
					gint _username_collection_size_ = 0;
					gint username_it = 0;
					username_collection = _tmp15_;
					username_collection_length1 = _tmp15__length1;
					for (username_it = 0; username_it < _tmp15__length1; username_it = username_it + 1) {
						gchar* _tmp16_ = NULL;
						gchar* username = NULL;
						_tmp16_ = g_strdup (username_collection[username_it]);
						username = _tmp16_;
						{
							LightDMUser* _tmp17_ = NULL;
							const gchar* _tmp18_ = NULL;
							const gchar* _tmp19_ = NULL;
							const gchar* _tmp20_ = NULL;
							_tmp17_ = user;
							_tmp18_ = lightdm_user_get_name (_tmp17_);
							_tmp19_ = _tmp18_;
							_tmp20_ = username;
							if (g_strcmp0 (_tmp19_, _tmp20_) == 0) {
								const gchar* _tmp21_ = NULL;
								LightDMUser* _tmp22_ = NULL;
								_tmp21_ = username;
								g_debug ("user-list.vala:98: Showing hidden user %s", _tmp21_);
								_tmp22_ = user;
								user_list_user_added_cb (self, _tmp22_);
							}
							_g_free0 (username);
						}
					}
				}
			}
		}
	}
	_g_object_unref0 (users);
	hidden_users = (_vala_array_free (hidden_users, hidden_users_length1, (GDestroyNotify) g_free), NULL);
	g_object_notify ((GObject *) self, "show-hidden-users");
}


const gchar* user_list_get_default_session (UserList* self) {
	const gchar* result;
	const gchar* _tmp0_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->_default_session;
	result = _tmp0_;
	return result;
}


void user_list_set_default_session (UserList* self, const gchar* value) {
	const gchar* _tmp0_ = NULL;
	gchar* _tmp1_ = NULL;
	PromptBox* _tmp2_ = NULL;
	PromptBox* _tmp3_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	_tmp1_ = g_strdup (_tmp0_);
	_g_free0 (self->priv->_default_session);
	self->priv->_default_session = _tmp1_;
	_tmp2_ = greeter_list_get_selected_entry ((GreeterList*) self);
	_tmp3_ = _tmp2_;
	if (_tmp3_ != NULL) {
		PromptBox* _tmp4_ = NULL;
		PromptBox* _tmp5_ = NULL;
		GdkPixbuf* _tmp6_ = NULL;
		GdkPixbuf* _tmp7_ = NULL;
		_tmp4_ = greeter_list_get_selected_entry ((GreeterList*) self);
		_tmp5_ = _tmp4_;
		_tmp6_ = user_list_get_badge (self);
		_tmp7_ = _tmp6_;
		prompt_box_set_options_image (_tmp5_, _tmp7_);
		_g_object_unref0 (_tmp7_);
	}
	g_object_notify ((GObject *) self, "default-session");
}


const gchar* user_list_get_session (UserList* self) {
	const gchar* result;
	const gchar* _tmp0_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->_session;
	result = _tmp0_;
	return result;
}


void user_list_set_session (UserList* self, const gchar* value) {
	const gchar* _tmp0_ = NULL;
	gchar* _tmp1_ = NULL;
	PromptBox* _tmp2_ = NULL;
	PromptBox* _tmp3_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	_tmp1_ = g_strdup (_tmp0_);
	_g_free0 (self->priv->_session);
	self->priv->_session = _tmp1_;
	_tmp2_ = greeter_list_get_selected_entry ((GreeterList*) self);
	_tmp3_ = _tmp2_;
	if (_tmp3_ != NULL) {
		PromptBox* _tmp4_ = NULL;
		PromptBox* _tmp5_ = NULL;
		GdkPixbuf* _tmp6_ = NULL;
		GdkPixbuf* _tmp7_ = NULL;
		_tmp4_ = greeter_list_get_selected_entry ((GreeterList*) self);
		_tmp5_ = _tmp4_;
		_tmp6_ = user_list_get_badge (self);
		_tmp7_ = _tmp6_;
		prompt_box_set_options_image (_tmp5_, _tmp7_);
		_g_object_unref0 (_tmp7_);
	}
	g_object_notify ((GObject *) self, "session");
}


static void _user_list___lambda46_ (UserList* self) {
	user_list_change_background (self);
}


static void __user_list___lambda46__greeter_list_entry_displayed_start (GreeterList* _sender, gpointer self) {
	_user_list___lambda46_ (self);
}


static void _user_list___lambda47_ (UserList* self) {
	user_list_change_background (self);
}


static void __user_list___lambda47__greeter_list_entry_displayed_done (GreeterList* _sender, gpointer self) {
	_user_list___lambda47_ (self);
}


static void _user_list_entry_selected_cb_greeter_list_entry_selected (GreeterList* _sender, const gchar* name, gpointer self) {
	user_list_entry_selected_cb (self, name);
}


static void _user_list_on_remote_login_service_appeared_gbus_name_appeared_callback (GDBusConnection* connection, const gchar* name, const gchar* name_owner, gpointer self) {
	user_list_on_remote_login_service_appeared (self, connection, name);
}


static void _user_list_on_remote_login_service_vanished_gbus_name_vanished_callback (GDBusConnection* connection, const gchar* name, gpointer self) {
	user_list_on_remote_login_service_vanished (self, connection, name);
}


static GObject * user_list_constructor (GType type, guint n_construct_properties, GObjectConstructParam * construct_properties) {
	GObject * obj;
	GObjectClass * parent_class;
	UserList * self;
	gboolean _tmp7_ = FALSE;
	UnityGreeter* _tmp8_ = NULL;
	gboolean _tmp9_ = FALSE;
	gboolean _tmp12_ = FALSE;
	GError * _inner_error_ = NULL;
	parent_class = G_OBJECT_CLASS (user_list_parent_class);
	obj = parent_class->constructor (type, n_construct_properties, construct_properties);
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, TYPE_USER_LIST, UserList);
	g_signal_connect_object ((GreeterList*) self, "entry-displayed-start", (GCallback) __user_list___lambda46__greeter_list_entry_displayed_start, self, 0);
	g_signal_connect_object ((GreeterList*) self, "entry-displayed-done", (GCallback) __user_list___lambda47__greeter_list_entry_displayed_done, self, 0);
	{
		GdkPixbuf* _tmp0_ = NULL;
		gchar* _tmp1_ = NULL;
		gchar* _tmp2_ = NULL;
		GdkPixbuf* _tmp3_ = NULL;
		GdkPixbuf* _tmp4_ = NULL;
		_tmp1_ = g_build_filename (PKGDATADIR, "message.png", NULL, NULL);
		_tmp2_ = _tmp1_;
		_tmp3_ = gdk_pixbuf_new_from_file (_tmp2_, &_inner_error_);
		_tmp4_ = _tmp3_;
		_g_free0 (_tmp2_);
		_tmp0_ = _tmp4_;
		if (_inner_error_ != NULL) {
			goto __catch44_g_error;
		}
		_g_object_unref0 (self->priv->message_pixbuf);
		self->priv->message_pixbuf = _tmp0_;
	}
	goto __finally44;
	__catch44_g_error:
	{
		GError* e = NULL;
		GError* _tmp5_ = NULL;
		const gchar* _tmp6_ = NULL;
		e = _inner_error_;
		_inner_error_ = NULL;
		_tmp5_ = e;
		_tmp6_ = _tmp5_->message;
		g_debug ("user-list.vala:162: Error loading message image: %s", _tmp6_);
		_g_error_free0 (e);
	}
	__finally44:
	if (_inner_error_ != NULL) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
	}
	user_list_fill_list (self);
	g_signal_connect_object ((GreeterList*) self, "entry-selected", (GCallback) _user_list_entry_selected_cb_greeter_list_entry_selected, self, 0);
	greeter_list_connect_to_lightdm ((GreeterList*) self);
	_tmp8_ = unity_greeter_singleton;
	_tmp9_ = _tmp8_->test_mode;
	if (!_tmp9_) {
		UnityGreeter* _tmp10_ = NULL;
		gboolean _tmp11_ = FALSE;
		_tmp10_ = unity_greeter_singleton;
		_tmp11_ = unity_greeter_show_remote_login_hint (_tmp10_);
		_tmp7_ = _tmp11_;
	} else {
		_tmp7_ = FALSE;
	}
	_tmp12_ = _tmp7_;
	if (_tmp12_) {
		guint _tmp13_ = 0U;
		_tmp13_ = g_bus_watch_name_with_closures (G_BUS_TYPE_SESSION, "com.canonical.RemoteLogin", G_BUS_NAME_WATCHER_FLAGS_AUTO_START, (GClosure*) ((_user_list_on_remote_login_service_appeared_gbus_name_appeared_callback == NULL) ? NULL : g_cclosure_new ((GCallback) _user_list_on_remote_login_service_appeared_gbus_name_appeared_callback, g_object_ref (self), g_object_unref)), (GClosure*) ((_user_list_on_remote_login_service_vanished_gbus_name_vanished_callback == NULL) ? NULL : g_cclosure_new ((GCallback) _user_list_on_remote_login_service_vanished_gbus_name_vanished_callback, g_object_ref (self), g_object_unref)));
		self->priv->remote_login_service_watch = _tmp13_;
	}
	return obj;
}


static void user_list_test_entry_copy (const UserListTestEntry* self, UserListTestEntry* dest) {
	const gchar* _tmp0_ = NULL;
	gchar* _tmp1_ = NULL;
	const gchar* _tmp2_ = NULL;
	gchar* _tmp3_ = NULL;
	const gchar* _tmp4_ = NULL;
	gchar* _tmp5_ = NULL;
	gboolean _tmp6_ = FALSE;
	gboolean _tmp7_ = FALSE;
	const gchar* _tmp8_ = NULL;
	gchar* _tmp9_ = NULL;
	_tmp0_ = (*self).username;
	_tmp1_ = g_strdup (_tmp0_);
	_g_free0 ((*dest).username);
	(*dest).username = _tmp1_;
	_tmp2_ = (*self).real_name;
	_tmp3_ = g_strdup (_tmp2_);
	_g_free0 ((*dest).real_name);
	(*dest).real_name = _tmp3_;
	_tmp4_ = (*self).background;
	_tmp5_ = g_strdup (_tmp4_);
	_g_free0 ((*dest).background);
	(*dest).background = _tmp5_;
	_tmp6_ = (*self).is_active;
	(*dest).is_active = _tmp6_;
	_tmp7_ = (*self).has_messages;
	(*dest).has_messages = _tmp7_;
	_tmp8_ = (*self).session;
	_tmp9_ = g_strdup (_tmp8_);
	_g_free0 ((*dest).session);
	(*dest).session = _tmp9_;
}


static void user_list_test_entry_destroy (UserListTestEntry* self) {
	_g_free0 ((*self).username);
	_g_free0 ((*self).real_name);
	_g_free0 ((*self).background);
	_g_free0 ((*self).session);
}


static UserListTestEntry* user_list_test_entry_dup (const UserListTestEntry* self) {
	UserListTestEntry* dup;
	dup = g_new0 (UserListTestEntry, 1);
	user_list_test_entry_copy (self, dup);
	return dup;
}


static void user_list_test_entry_free (UserListTestEntry* self) {
	user_list_test_entry_destroy (self);
	g_free (self);
}


static GType user_list_test_entry_get_type (void) {
	static volatile gsize user_list_test_entry_type_id__volatile = 0;
	if (g_once_init_enter (&user_list_test_entry_type_id__volatile)) {
		GType user_list_test_entry_type_id;
		user_list_test_entry_type_id = g_boxed_type_register_static ("UserListTestEntry", (GBoxedCopyFunc) user_list_test_entry_dup, (GBoxedFreeFunc) user_list_test_entry_free);
		g_once_init_leave (&user_list_test_entry_type_id__volatile, user_list_test_entry_type_id);
	}
	return user_list_test_entry_type_id__volatile;
}


static void user_list_class_init (UserListClass * klass) {
	user_list_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (UserListPrivate));
	GREETER_LIST_CLASS (klass)->insert_entry = user_list_real_insert_entry;
	GREETER_LIST_CLASS (klass)->setup_prompt_box = user_list_real_setup_prompt_box;
	GREETER_LIST_CLASS (klass)->start_authentication = user_list_real_start_authentication;
	GREETER_LIST_CLASS (klass)->focus_prompt = user_list_real_focus_prompt;
	GREETER_LIST_CLASS (klass)->show_authenticated = user_list_real_show_authenticated;
	GREETER_LIST_CLASS (klass)->add_manual_entry = user_list_real_add_manual_entry;
	GREETER_LIST_CLASS (klass)->get_lightdm_session = user_list_real_get_lightdm_session;
	GREETER_LIST_CLASS (klass)->show_prompt_cb = user_list_real_show_prompt_cb;
	GREETER_LIST_CLASS (klass)->test_start_authentication = user_list_real_test_start_authentication;
	G_OBJECT_CLASS (klass)->get_property = _vala_user_list_get_property;
	G_OBJECT_CLASS (klass)->set_property = _vala_user_list_set_property;
	G_OBJECT_CLASS (klass)->constructor = user_list_constructor;
	G_OBJECT_CLASS (klass)->finalize = user_list_finalize;
	g_object_class_install_property (G_OBJECT_CLASS (klass), USER_LIST_OFFER_GUEST, g_param_spec_boolean ("offer-guest", "offer-guest", "offer-guest", FALSE, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), USER_LIST_SHOW_HIDDEN_USERS, g_param_spec_boolean ("show-hidden-users", "show-hidden-users", "show-hidden-users", FALSE, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), USER_LIST_DEFAULT_SESSION, g_param_spec_string ("default-session", "default-session", "default-session", NULL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), USER_LIST_SESSION, g_param_spec_string ("session", "session", "session", NULL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
}


static void user_list_instance_init (UserList * self) {
	gchar* _tmp0_ = NULL;
	self->priv = USER_LIST_GET_PRIVATE (self);
	self->priv->_offer_guest = FALSE;
	self->priv->change_background_timeout = (guint) 0;
	self->priv->remote_directory_server_list = NULL;
	self->priv->remote_login_server_list = NULL;
	self->priv->authenticate_user = NULL;
	self->priv->show_hidden_users_ = FALSE;
	_tmp0_ = g_strdup ("ubuntu");
	self->priv->_default_session = _tmp0_;
	self->priv->_session = NULL;
	self->priv->n_test_entries = 0;
	self->priv->test_prompted_sso = FALSE;
	self->priv->test_two_prompts_first = NULL;
	self->priv->test_request_new_password = FALSE;
	self->priv->test_new_password = NULL;
}


static void user_list_finalize (GObject* obj) {
	UserList * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, TYPE_USER_LIST, UserList);
	_g_object_unref0 (self->priv->message_pixbuf);
	_g_object_unref0 (self->priv->remote_login_service);
	__g_list_free__remote_server_free0_0 (self->priv->remote_directory_server_list);
	__g_list_free__remote_server_free0_0 (self->priv->remote_login_server_list);
	_g_hash_table_unref0 (self->priv->current_remote_fields);
	_g_free0 (self->priv->currently_browsing_server_url);
	_g_free0 (self->priv->currently_browsing_server_email);
	_email_autocompleter_unref0 (self->priv->remote_server_email_field_autocompleter);
	_g_free0 (self->priv->authenticate_user);
	_g_free0 (self->priv->_default_session);
	_g_free0 (self->priv->_session);
	__g_list_free__g_free0_0 (self->priv->test_backgrounds);
	_g_free0 (self->priv->test_two_prompts_first);
	_g_free0 (self->priv->test_new_password);
	G_OBJECT_CLASS (user_list_parent_class)->finalize (obj);
}


GType user_list_get_type (void) {
	static volatile gsize user_list_type_id__volatile = 0;
	if (g_once_init_enter (&user_list_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (UserListClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) user_list_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (UserList), 0, (GInstanceInitFunc) user_list_instance_init, NULL };
		GType user_list_type_id;
		user_list_type_id = g_type_register_static (TYPE_GREETER_LIST, "UserList", &g_define_type_info, 0);
		g_once_init_leave (&user_list_type_id__volatile, user_list_type_id);
	}
	return user_list_type_id__volatile;
}


static void _vala_user_list_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec) {
	UserList * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (object, TYPE_USER_LIST, UserList);
	switch (property_id) {
		case USER_LIST_OFFER_GUEST:
		g_value_set_boolean (value, user_list_get_offer_guest (self));
		break;
		case USER_LIST_SHOW_HIDDEN_USERS:
		g_value_set_boolean (value, user_list_get_show_hidden_users (self));
		break;
		case USER_LIST_DEFAULT_SESSION:
		g_value_set_string (value, user_list_get_default_session (self));
		break;
		case USER_LIST_SESSION:
		g_value_set_string (value, user_list_get_session (self));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


static void _vala_user_list_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec) {
	UserList * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (object, TYPE_USER_LIST, UserList);
	switch (property_id) {
		case USER_LIST_OFFER_GUEST:
		user_list_set_offer_guest (self, g_value_get_boolean (value));
		break;
		case USER_LIST_SHOW_HIDDEN_USERS:
		user_list_set_show_hidden_users (self, g_value_get_boolean (value));
		break;
		case USER_LIST_DEFAULT_SESSION:
		user_list_set_default_session (self, g_value_get_string (value));
		break;
		case USER_LIST_SESSION:
		user_list_set_session (self, g_value_get_string (value));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	if ((array != NULL) && (destroy_func != NULL)) {
		int i;
		for (i = 0; i < array_length; i = i + 1) {
			if (((gpointer*) array)[i] != NULL) {
				destroy_func (((gpointer*) array)[i]);
			}
		}
	}
}


static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	_vala_array_destroy (array, array_length, destroy_func);
	g_free (array);
}


static gint _vala_array_length (gpointer array) {
	int length;
	length = 0;
	if (array) {
		while (((gpointer*) array)[length]) {
			length++;
		}
	}
	return length;
}



